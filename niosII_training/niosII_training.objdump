
niosII_training.elf:     file format elf32-littlenios2
niosII_training.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x01200240

Program Header:
    LOAD off    0x00001000 vaddr 0x00800000 paddr 0x00800000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001020 vaddr 0x01200020 paddr 0x01200020 align 2**12
         filesz 0x00009b58 memsz 0x00009cb0 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00800000  00800000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000220  01200020  01200020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00007d78  01200240  01200240  00001240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000070  01207fb8  01207fb8  00008fb8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b50  01208028  01208028  00009028  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000158  01209b78  01209b78  0000ab78  2**2
                  ALLOC, SMALL_DATA
  6 .ext_flash_ctl 00000000  00800020  00800020  0000ab78  2**0
                  CONTENTS
  7 .ext_ram_ctl  00000000  01209cd0  01209cd0  0000ab78  2**0
                  CONTENTS
  8 .instruction_tcm 00000000  02000000  02000000  0000ab78  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  0000ab78  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000a10  00000000  00000000  0000aba0  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00018a01  00000000  00000000  0000b5b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000066a9  00000000  00000000  00023fb1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000071bd  00000000  00000000  0002a65a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001b1c  00000000  00000000  00031818  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00002e00  00000000  00000000  00033334  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00004683  00000000  00000000  00036134  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  0003a7b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000308  00000000  00000000  0003a808  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0003d7b0  2**0
                  CONTENTS, READONLY
 20 .cpu          00000003  00000000  00000000  0003d7b3  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0003d7b6  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0003d7b7  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0003d7b8  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  0003d7bc  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  0003d7c0  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   00000009  00000000  00000000  0003d7c4  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    00000009  00000000  00000000  0003d7cd  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   00000009  00000000  00000000  0003d7d6  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000006  00000000  00000000  0003d7df  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 00000057  00000000  00000000  0003d7e5  2**0
                  CONTENTS, READONLY
 31 .jdi          00003635  00000000  00000000  0003d83c  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     00070dbf  00000000  00000000  00040e71  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00800000 l    d  .entry	00000000 .entry
01200020 l    d  .exceptions	00000000 .exceptions
01200240 l    d  .text	00000000 .text
01207fb8 l    d  .rodata	00000000 .rodata
01208028 l    d  .rwdata	00000000 .rwdata
01209b78 l    d  .bss	00000000 .bss
00800020 l    d  .ext_flash_ctl	00000000 .ext_flash_ctl
01209cd0 l    d  .ext_ram_ctl	00000000 .ext_ram_ctl
02000000 l    d  .instruction_tcm	00000000 .instruction_tcm
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../niosII_training_bsp//obj/HAL/src/crt0.o
01200284 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 simple.c
01200288 l     F .text	0000006c handle_button_interrupts
012002f4 l     F .text	00000074 init_button_pio
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
01208028 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
01201f44 l     F .text	00000008 __fp_lock
01201f4c l     F .text	00000008 __fp_unlock
01201f60 l     F .text	000001a0 __sinit.part.1
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 alt_close.c
01202fa8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
012030c8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
012030f4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
012034c4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
012035b8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
01203794 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
01209b64 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
01203a20 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
01203b68 l     F .text	00000038 alt_dev_reg
012089fc l     O .rwdata	000000dc ext_flash_ctl
01208ad8 l     O .rwdata	00001060 jtag_uart
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
01203c40 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
01204a7c l     F .text	00000080 alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
01205b48 l     F .text	00000204 altera_avalon_jtag_uart_irq
01205d4c l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0120636c l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
01206774 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
01206a74 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
01206bac l     F .text	00000050 alt_get_errno
01206bfc l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
01207370 l     F .text	000000cc alt_write_word_amd
01207254 l     F .text	0000011c alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
01207644 l     F .text	00000178 alt_unlock_block_intel
012077bc l     F .text	000000d4 alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
01207e58 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 alt_exit.c
01209b9c g     O .bss	00000004 alt_instruction_exception_handler
01202e9c g     F .text	00000054 _isatty_r
012036dc g     F .text	00000078 alt_main
0120049c g     F .text	000000b8 _puts_r
01204548 g     F .text	00000040 alt_read_query_entry_32bit
01209bd0 g     O .bss	00000100 alt_irq
01202ef0 g     F .text	0000005c _lseek_r
01203d08 g     F .text	000002a8 alt_flash_cfi_write
01209cd0 g       *ABS*	00000000 __alt_heap_start
01202c1c g     F .text	0000005c __sseek
01202294 g     F .text	00000010 __sinit
01202100 g     F .text	00000064 __sfmoreglue
01203774 g     F .text	00000020 __malloc_unlock
0120146c g     F .text	0000015c memmove
0120227c g     F .text	00000018 _cleanup
01206fbc g     F .text	00000020 altera_nios2_gen2_irq_init
00000000  w      *UND*	00000000 __errno
02000000 g       *ABS*	00000000 __alt_mem_instruction_tcm
012046e0 g     F .text	00000050 alt_write_flash_command_32bit_device_16bit_mode
00800000 g     F .entry	00000000 __reset
01209b78 g     O .bss	00000004 edge_capture
01202e44 g     F .text	00000058 _fstat_r
012041f8 g     F .text	000002d4 alt_flash_program_block
01209b88 g     O .bss	00000004 errno
01202b98 g     F .text	00000008 __seofread
01209b94 g     O .bss	00000004 alt_argv
01211b38 g       *ABS*	00000000 _gp
012039f0 g     F .text	00000030 usleep
0120887c g     O .rwdata	00000180 alt_fd_list
01207890 g     F .text	00000090 alt_find_dev
01201334 g     F .text	00000138 memcpy
01201f54 g     F .text	0000000c _cleanup_r
01206b34 g     F .text	00000078 alt_io_redirect
01200000 g       *ABS*	00000000 __alt_mem_ext_ram_ctl
01207fb8 g       *ABS*	00000000 __DTOR_END__
01200554 g     F .text	00000014 puts
012069d8 g     F .text	0000009c alt_exception_cause_generated_bad_addr
01205f48 g     F .text	0000020c altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
01207f74 g     F .text	00000008 .hidden __udivsi3
01203514 g     F .text	000000a4 isatty
01209b84 g     O .bss	00000004 __malloc_top_pad
01200600 g     F .text	000004a4 __sfvwrite_r
01201b68 g     F .text	00000054 _sbrk_r
0120743c g     F .text	00000080 alt_program_intel
01202f4c g     F .text	0000005c _read_r
01206700 g     F .text	00000074 alt_dcache_flush
01209b58 g     O .rwdata	00000004 alt_max_fd
012044cc g     F .text	0000003c alt_read_query_entry_8bit
01202d30 g     F .text	00000100 _fclose_r
012074bc g     F .text	00000188 alt_erase_block_intel
01201f14 g     F .text	00000030 fflush
01209b80 g     O .bss	00000004 __malloc_max_sbrked_mem
01203608 g     F .text	000000d4 lseek
01209b38 g     O .rwdata	00000004 _global_impure_ptr
012015c8 g     F .text	000005a0 _realloc_r
01209cd0 g       *ABS*	00000000 __bss_end
012033d4 g     F .text	000000f0 alt_iic_isr_register
01206eb8 g     F .text	00000104 alt_tick
012022b4 g     F .text	00000018 __fp_lock_all
01203388 g     F .text	0000004c alt_ic_irq_enabled
01206e20 g     F .text	00000098 alt_alarm_stop
01209b8c g     O .bss	00000004 alt_irq_active
012000fc g     F .exceptions	000000d0 alt_irq_handler
01208854 g     O .rwdata	00000028 alt_dev_null
012049e0 g     F .text	0000009c alt_set_flash_algorithm_func
01204588 g     F .text	00000044 alt_write_flash_command_8bit_device_8bit_mode
01209b50 g     O .rwdata	00000008 alt_dev_list
01203a70 g     F .text	000000f8 write
01203144 g     F .text	000000b0 fstat
01205848 g     F .text	000000d8 alt_check_primary_table
01207f7c g     F .text	00000008 .hidden __umodsi3
0120403c g     F .text	00000064 alt_flash_cfi_read
01204780 g     F .text	00000038 alt_write_native_8bit
01209cd0 g       *ABS*	00000000 end
012045cc g     F .text	00000078 alt_write_flash_command_16bit_device_8bit_mode
01204afc g     F .text	000005c8 alt_read_cfi_table
01205a84 g     F .text	000000c4 altera_avalon_jtag_uart_init
012001cc g     F .exceptions	00000074 alt_instruction_exception_entry
01207fb8 g       *ABS*	00000000 __CTOR_LIST__
01400000 g       *ABS*	00000000 __alt_stack_pointer
012063e0 g     F .text	00000088 alt_avalon_timer_sc_init
01206154 g     F .text	00000218 altera_avalon_jtag_uart_write
01203c78 g     F .text	00000090 alt_flash_cfi_init
012022a4 g     F .text	00000004 __sfp_lock_acquire
0120124c g     F .text	000000e8 memchr
01202408 g     F .text	000002f0 _free_r
01207cc4 g     F .text	00000194 __call_exitprocs
01209b40 g     O .rwdata	00000004 __malloc_sbrk_base
01200240 g     F .text	00000048 _start
01209ba0 g     O .bss	00000004 _alt_tick_rate
01209ba4 g     O .bss	00000004 _alt_nticks
012037e4 g     F .text	000000fc read
01203bd4 g     F .text	0000006c alt_sys_init
01207bb0 g     F .text	00000114 __register_exitproc
01204508 g     F .text	00000040 alt_read_query_entry_16bit
01205df4 g     F .text	00000068 altera_avalon_jtag_uart_close
00800000 g       *ABS*	00000000 __alt_mem_ext_flash_ctl
01209ba8 g     O .bss	00000028 __malloc_current_mallinfo
01204824 g     F .text	000001bc alt_set_flash_width_func
01205920 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
01207a34 g     F .text	000000b4 alt_get_fd
012065a8 g     F .text	00000158 alt_busy_sleep
01202cdc g     F .text	00000054 _close_r
01207044 g     F .text	00000210 alt_erase_block_amd
01207b34 g     F .text	0000007c memcmp
012059e0 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
01209cd0 g       *ABS*	00000000 __alt_stack_base
01205a30 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
01201bbc g     F .text	00000130 __swsetup_r
012050c4 g     F .text	00000784 alt_read_cfi_width
01202164 g     F .text	00000118 __sfp
0120844c g     O .rwdata	00000408 __malloc_av_
012022b0 g     F .text	00000004 __sinit_lock_release
01202b44 g     F .text	00000054 __sread
01207920 g     F .text	00000114 alt_find_file
012067c4 g     F .text	000000a4 alt_dev_llist_insert
01203754 g     F .text	00000020 __malloc_lock
01203940 g     F .text	000000b0 sbrk
01201cec g     F .text	00000228 _fflush_r
01209b68 g     O .rwdata	00000008 alt_flash_dev_list
01204694 g     F .text	0000004c alt_write_flash_command_16bit_device_16bit_mode
01209b78 g       *ABS*	00000000 __bss_start
01202a20 g     F .text	00000124 memset
01200368 g     F .text	00000134 main
01209b98 g     O .bss	00000004 alt_envp
01209b7c g     O .bss	00000004 __malloc_max_total_mem
01205980 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
01202c78 g     F .text	00000008 __sclose
01400000 g       *ABS*	00000000 __alt_heap_limit
01202e30 g     F .text	00000014 fclose
01200aa4 g     F .text	000007a8 _malloc_r
01209b5c g     O .rwdata	00000004 alt_errno
01204730 g     F .text	00000050 alt_write_flash_command_32bit_device_32bit_mode
012026f8 g     F .text	000000b8 _fwalk
012040a0 g     F .text	00000158 alt_write_value_to_flash
012047b8 g     F .text	00000038 alt_write_native_16bit
01207ec4 g     F .text	00000054 .hidden __divsi3
012022e4 g     F .text	00000124 _malloc_trim_r
01207fb8 g       *ABS*	00000000 __CTOR_END__
01207fb8 g       *ABS*	00000000 __DTOR_LIST__
01203ba0 g     F .text	00000034 alt_irq_init
012038e0 g     F .text	00000060 alt_release_fd
01207ae8 g     F .text	00000014 atexit
01202c80 g     F .text	0000005c _write_r
01209b3c g     O .rwdata	00000004 _impure_ptr
01209b90 g     O .bss	00000004 alt_argc
012068c4 g     F .text	0000005c _do_dtors
01200020 g       .exceptions	00000000 alt_irq_entry
012022cc g     F .text	00000018 __fp_unlock_all
01209b48 g     O .rwdata	00000008 alt_fs_list
01204644 g     F .text	00000050 alt_write_flash_command_32bit_device_8bit_mode
012031f4 g     F .text	00000050 alt_ic_isr_register
01209b78 g       *ABS*	00000000 _edata
01209cd0 g       *ABS*	00000000 _end
01206920 g     F .text	00000068 alt_flash_open_dev
01205e5c g     F .text	000000ec altera_avalon_jtag_uart_ioctl
012032e4 g     F .text	000000a4 alt_ic_irq_disable
01202ba0 g     F .text	0000007c __swrite
01209b44 g     O .rwdata	00000004 __malloc_trim_threshold
01207afc g     F .text	00000038 exit
012027b0 g     F .text	000000b8 _fwalk_reent
01206988 g     F .text	00000050 alt_flash_close_dev
01207f18 g     F .text	0000005c .hidden __modsi3
01400000 g       *ABS*	00000000 __alt_data_end
01200020 g     F .exceptions	00000000 alt_exception
012022a8 g     F .text	00000004 __sfp_lock_release
01207f84 g     F .text	00000034 _exit
01206468 g     F .text	00000140 alt_alarm_start
01202868 g     F .text	000001b8 __smakebuf_r
012047f0 g     F .text	00000034 alt_write_native_32bit
01200568 g     F .text	00000098 strlen
01206cc8 g     F .text	00000158 open
01203fb0 g     F .text	0000008c alt_flash_cfi_get_info
01209b60 g     O .rwdata	00000004 alt_priority_mask
01203244 g     F .text	000000a0 alt_ic_irq_enable
01209b70 g     O .rwdata	00000008 alt_alarm_list
01206868 g     F .text	0000005c _do_ctors
01202ff8 g     F .text	000000d0 close
01206fdc g     F .text	00000068 alt_program_amd
00000000  w      *UND*	00000000 free
012022ac g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .exceptions:

01200020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 1200020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 1200024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 1200028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 120002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 1200030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 1200034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 1200038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 120003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 1200040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 1200044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 1200048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 120004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 1200050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 1200054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 1200058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 120005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 1200060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 1200064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 1200068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 120006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 1200070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 1200074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 1200078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 120007c:	10000326 	beq	r2,zero,120008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 1200080:	20000226 	beq	r4,zero,120008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 1200084:	12000fc0 	call	12000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 1200088:	00000706 	br	12000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 120008c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 1200090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 1200094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 1200098:	12001cc0 	call	12001cc <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 120009c:	1000021e 	bne	r2,zero,12000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 12000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 12000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 12000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 12000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 12000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 12000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 12000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 12000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 12000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 12000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 12000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 12000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 12000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 12000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 12000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 12000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 12000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 12000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 12000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 12000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 12000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 12000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 12000f8:	ef80083a 	eret

012000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 12000fc:	defff904 	addi	sp,sp,-28
 1200100:	dfc00615 	stw	ra,24(sp)
 1200104:	df000515 	stw	fp,20(sp)
 1200108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 120010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 1200110:	0005313a 	rdctl	r2,ipending
 1200114:	e0bffe15 	stw	r2,-8(fp)

  return active;
 1200118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 120011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 1200120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 1200124:	00800044 	movi	r2,1
 1200128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 120012c:	e0fffb17 	ldw	r3,-20(fp)
 1200130:	e0bffc17 	ldw	r2,-16(fp)
 1200134:	1884703a 	and	r2,r3,r2
 1200138:	10001426 	beq	r2,zero,120018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 120013c:	00804874 	movhi	r2,289
 1200140:	10a6f404 	addi	r2,r2,-25648
 1200144:	e0fffd17 	ldw	r3,-12(fp)
 1200148:	180690fa 	slli	r3,r3,3
 120014c:	10c5883a 	add	r2,r2,r3
 1200150:	10c00017 	ldw	r3,0(r2)
 1200154:	00804874 	movhi	r2,289
 1200158:	10a6f404 	addi	r2,r2,-25648
 120015c:	e13ffd17 	ldw	r4,-12(fp)
 1200160:	200890fa 	slli	r4,r4,3
 1200164:	1105883a 	add	r2,r2,r4
 1200168:	10800104 	addi	r2,r2,4
 120016c:	10800017 	ldw	r2,0(r2)
 1200170:	1009883a 	mov	r4,r2
 1200174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 1200178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 120017c:	0005313a 	rdctl	r2,ipending
 1200180:	e0bfff15 	stw	r2,-4(fp)

  return active;
 1200184:	e0bfff17 	ldw	r2,-4(fp)
 1200188:	00000706 	br	12001a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 120018c:	e0bffc17 	ldw	r2,-16(fp)
 1200190:	1085883a 	add	r2,r2,r2
 1200194:	e0bffc15 	stw	r2,-16(fp)
      i++;
 1200198:	e0bffd17 	ldw	r2,-12(fp)
 120019c:	10800044 	addi	r2,r2,1
 12001a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 12001a4:	003fe106 	br	120012c <__alt_mem_instruction_tcm+0xff20012c>

    active = alt_irq_pending ();
 12001a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 12001ac:	e0bffb17 	ldw	r2,-20(fp)
 12001b0:	103fdb1e 	bne	r2,zero,1200120 <__alt_mem_instruction_tcm+0xff200120>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 12001b4:	0001883a 	nop
}
 12001b8:	e037883a 	mov	sp,fp
 12001bc:	dfc00117 	ldw	ra,4(sp)
 12001c0:	df000017 	ldw	fp,0(sp)
 12001c4:	dec00204 	addi	sp,sp,8
 12001c8:	f800283a 	ret

012001cc <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 12001cc:	defffb04 	addi	sp,sp,-20
 12001d0:	dfc00415 	stw	ra,16(sp)
 12001d4:	df000315 	stw	fp,12(sp)
 12001d8:	df000304 	addi	fp,sp,12
 12001dc:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
 12001e0:	000531fa 	rdctl	r2,exception
 12001e4:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
 12001e8:	e0bffd17 	ldw	r2,-12(fp)
 12001ec:	10801f0c 	andi	r2,r2,124
 12001f0:	1004d0ba 	srli	r2,r2,2
 12001f4:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
 12001f8:	0005333a 	rdctl	r2,badaddr
 12001fc:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 1200200:	d0a01917 	ldw	r2,-32668(gp)
 1200204:	10000726 	beq	r2,zero,1200224 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 1200208:	d0a01917 	ldw	r2,-32668(gp)
 120020c:	e0fffd17 	ldw	r3,-12(fp)
 1200210:	1809883a 	mov	r4,r3
 1200214:	e17fff17 	ldw	r5,-4(fp)
 1200218:	e1bffe17 	ldw	r6,-8(fp)
 120021c:	103ee83a 	callr	r2
 1200220:	00000206 	br	120022c <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 1200224:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 1200228:	0005883a 	mov	r2,zero
}
 120022c:	e037883a 	mov	sp,fp
 1200230:	dfc00117 	ldw	ra,4(sp)
 1200234:	df000017 	ldw	fp,0(sp)
 1200238:	dec00204 	addi	sp,sp,8
 120023c:	f800283a 	ret

Disassembly of section .text:

01200240 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 1200240:	00840014 	movui	r2,4096
#endif

0:
    initd 0(r2)
 1200244:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 1200248:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 120024c:	00bffd16 	blt	zero,r2,1200244 <__alt_mem_instruction_tcm+0xff200244>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 1200250:	06c05034 	movhi	sp,320
    ori sp, sp, %lo(__alt_stack_pointer)
 1200254:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 1200258:	06804874 	movhi	gp,289
    ori gp, gp, %lo(_gp)
 120025c:	d686ce14 	ori	gp,gp,6968
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 1200260:	00804834 	movhi	r2,288
    ori r2, r2, %lo(__bss_start)
 1200264:	10a6de14 	ori	r2,r2,39800

    movhi r3, %hi(__bss_end)
 1200268:	00c04834 	movhi	r3,288
    ori r3, r3, %lo(__bss_end)
 120026c:	18e73414 	ori	r3,r3,40144

    beq r2, r3, 1f
 1200270:	10c00326 	beq	r2,r3,1200280 <_start+0x40>

0:
    stw zero, (r2)
 1200274:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 1200278:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 120027c:	10fffd36 	bltu	r2,r3,1200274 <__alt_mem_instruction_tcm+0xff200274>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 1200280:	12036dc0 	call	12036dc <alt_main>

01200284 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 1200284:	003fff06 	br	1200284 <__alt_mem_instruction_tcm+0xff200284>

01200288 <handle_button_interrupts>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    static void handle_button_interrupts(void* context)
#else
    static void handle_button_interrupts(void* context, alt_u32 id)
#endif
{
 1200288:	defffc04 	addi	sp,sp,-16
 120028c:	dfc00315 	stw	ra,12(sp)
 1200290:	df000215 	stw	fp,8(sp)
 1200294:	df000204 	addi	fp,sp,8
 1200298:	e13fff15 	stw	r4,-4(fp)
    /* Cast context to edge_capture's type. It is important that this
    be declared volatile to avoid unwanted compiler optimization. */
    volatile int* edge_capture_ptr = (volatile int*) context;
 120029c:	e0bfff17 	ldw	r2,-4(fp)
 12002a0:	e0bffe15 	stw	r2,-8(fp)
    /*
    * Read the edge capture register on the button PIO.
    * Store value.
    */
    *edge_capture_ptr =
    IORD_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE);
 12002a4:	00805034 	movhi	r2,320
 12002a8:	10841304 	addi	r2,r2,4172
 12002ac:	10c00037 	ldwio	r3,0(r2)
    volatile int* edge_capture_ptr = (volatile int*) context;
    /*
    * Read the edge capture register on the button PIO.
    * Store value.
    */
    *edge_capture_ptr =
 12002b0:	e0bffe17 	ldw	r2,-8(fp)
 12002b4:	10c00015 	stw	r3,0(r2)
    IORD_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE);
    /* Write to the edge capture register to reset it. */
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0);
 12002b8:	0007883a 	mov	r3,zero
 12002bc:	00805034 	movhi	r2,320
 12002c0:	10841304 	addi	r2,r2,4172
 12002c4:	10c00035 	stwio	r3,0(r2)
    /* Read the PIO to delay ISR exit. This is done to prevent a
    spurious interrupt in systems with high processor -> pio
    latency and fast interrupts. */
    IORD_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE);
 12002c8:	00805034 	movhi	r2,320
 12002cc:	10841304 	addi	r2,r2,4172
 12002d0:	10800037 	ldwio	r2,0(r2)
    printf("Handler captured!\n");
 12002d4:	01004834 	movhi	r4,288
 12002d8:	211fee04 	addi	r4,r4,32696
 12002dc:	12005540 	call	1200554 <puts>
}
 12002e0:	e037883a 	mov	sp,fp
 12002e4:	dfc00117 	ldw	ra,4(sp)
 12002e8:	df000017 	ldw	fp,0(sp)
 12002ec:	dec00204 	addi	sp,sp,8
 12002f0:	f800283a 	ret

012002f4 <init_button_pio>:

/* Initialize the button_pio. */
static void init_button_pio()
{
 12002f4:	defffc04 	addi	sp,sp,-16
 12002f8:	dfc00315 	stw	ra,12(sp)
 12002fc:	df000215 	stw	fp,8(sp)
 1200300:	df000204 	addi	fp,sp,8
    /* Recast the edge_capture pointer to match the
    alt_irq_register() function prototype. */
    void* edge_capture_ptr = (void*) &edge_capture;
 1200304:	d0a01004 	addi	r2,gp,-32704
 1200308:	e0bfff15 	stw	r2,-4(fp)
    /* Enable all 4 button interrupts. */
    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(BUTTONS_BASE, 0xf);
 120030c:	00c003c4 	movi	r3,15
 1200310:	00805034 	movhi	r2,320
 1200314:	10841204 	addi	r2,r2,4168
 1200318:	10c00035 	stwio	r3,0(r2)
    /* Reset the edge capture register. */
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(BUTTONS_BASE, 0x0);
 120031c:	0007883a 	mov	r3,zero
 1200320:	00805034 	movhi	r2,320
 1200324:	10841304 	addi	r2,r2,4172
 1200328:	10c00035 	stwio	r3,0(r2)
    /* Register the ISR. */
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(BUTTONS_IRQ_INTERRUPT_CONTROLLER_ID,
 120032c:	d8000015 	stw	zero,0(sp)
 1200330:	0009883a 	mov	r4,zero
 1200334:	01400084 	movi	r5,2
 1200338:	01804834 	movhi	r6,288
 120033c:	3180a204 	addi	r6,r6,648
 1200340:	e1ffff17 	ldw	r7,-4(fp)
 1200344:	12031f40 	call	12031f4 <alt_ic_isr_register>
            edge_capture_ptr, 0x0);
    #else
        alt_irq_register( BUTTON_PIO_IRQ, edge_capture_ptr, handle_button_interrupts );
    #endif

    printf("Init done!\n");
 1200348:	01004834 	movhi	r4,288
 120034c:	211ff304 	addi	r4,r4,32716
 1200350:	12005540 	call	1200554 <puts>
}
 1200354:	e037883a 	mov	sp,fp
 1200358:	dfc00117 	ldw	ra,4(sp)
 120035c:	df000017 	ldw	fp,0(sp)
 1200360:	dec00204 	addi	sp,sp,8
 1200364:	f800283a 	ret

01200368 <main>:

int main(void)
{
 1200368:	defffd04 	addi	sp,sp,-12
 120036c:	dfc00215 	stw	ra,8(sp)
 1200370:	df000115 	stw	fp,4(sp)
 1200374:	df000104 	addi	fp,sp,4
    int led = 0x01;
 1200378:	00800044 	movi	r2,1
 120037c:	e0bfff15 	stw	r2,-4(fp)
    edge_capture = 0xF;
 1200380:	008003c4 	movi	r2,15
 1200384:	d0a01015 	stw	r2,-32704(gp)

    init_button_pio();
 1200388:	12002f40 	call	12002f4 <init_button_pio>

    printf("Simple\n");   // print a message to show that program is running
 120038c:	01004834 	movhi	r4,288
 1200390:	211ff604 	addi	r4,r4,32728
 1200394:	12005540 	call	1200554 <puts>

    IOWR_ALTERA_AVALON_PIO_DATA(GREEN_LED_BASE,led); // write initial value
 1200398:	00805034 	movhi	r2,320
 120039c:	10841404 	addi	r2,r2,4176
 12003a0:	e0ffff17 	ldw	r3,-4(fp)
 12003a4:	10c00035 	stwio	r3,0(r2)
    while (1)
    {
        if (edge_capture != NONE_PRESSED)  // if button pressed
 12003a8:	d0a01017 	ldw	r2,-32704(gp)
 12003ac:	108003e0 	cmpeqi	r2,r2,15
 12003b0:	1000391e 	bne	r2,zero,1200498 <main+0x130>
        {
            switch(edge_capture) {
 12003b4:	d0a01017 	ldw	r2,-32704(gp)
 12003b8:	10c000a0 	cmpeqi	r3,r2,2
 12003bc:	1800101e 	bne	r3,zero,1200400 <main+0x98>
 12003c0:	10c000c8 	cmpgei	r3,r2,3
 12003c4:	1800031e 	bne	r3,zero,12003d4 <main+0x6c>
 12003c8:	10800060 	cmpeqi	r2,r2,1
 12003cc:	1000061e 	bne	r2,zero,12003e8 <main+0x80>
 12003d0:	00001f06 	br	1200450 <main+0xe8>
 12003d4:	10c00120 	cmpeqi	r3,r2,4
 12003d8:	1800131e 	bne	r3,zero,1200428 <main+0xc0>
 12003dc:	10800220 	cmpeqi	r2,r2,8
 12003e0:	1000041e 	bne	r2,zero,12003f4 <main+0x8c>
 12003e4:	00001a06 	br	1200450 <main+0xe8>
                case BTN_RIGHT_PRESSED:
                    led = 0x01;
 12003e8:	00800044 	movi	r2,1
 12003ec:	e0bfff15 	stw	r2,-4(fp)
                    break;
 12003f0:	00001706 	br	1200450 <main+0xe8>
                case BTN_LEFT_PRESSED:
                    led = 0x80;
 12003f4:	00802004 	movi	r2,128
 12003f8:	e0bfff15 	stw	r2,-4(fp)
                    break;
 12003fc:	00001406 	br	1200450 <main+0xe8>
                case BTN_CNTR_RIGHT:
                    if (led == 0x1)
 1200400:	e0bfff17 	ldw	r2,-4(fp)
 1200404:	10800058 	cmpnei	r2,r2,1
 1200408:	1000031e 	bne	r2,zero,1200418 <main+0xb0>
                        led = 0x80;
 120040c:	00802004 	movi	r2,128
 1200410:	e0bfff15 	stw	r2,-4(fp)
                    else
                        led = led >> 1;
                    break;
 1200414:	00000e06 	br	1200450 <main+0xe8>
                    break;
                case BTN_CNTR_RIGHT:
                    if (led == 0x1)
                        led = 0x80;
                    else
                        led = led >> 1;
 1200418:	e0bfff17 	ldw	r2,-4(fp)
 120041c:	1005d07a 	srai	r2,r2,1
 1200420:	e0bfff15 	stw	r2,-4(fp)
                    break;
 1200424:	00000a06 	br	1200450 <main+0xe8>
                case BTN_CNTR_LEFT:
                    if (led == 0x80)
 1200428:	e0bfff17 	ldw	r2,-4(fp)
 120042c:	10802018 	cmpnei	r2,r2,128
 1200430:	1000031e 	bne	r2,zero,1200440 <main+0xd8>
                        led = 0x1;
 1200434:	00800044 	movi	r2,1
 1200438:	e0bfff15 	stw	r2,-4(fp)
                    else
                        led = led << 1;
                    break;
 120043c:	00000306 	br	120044c <main+0xe4>
                    break;
                case BTN_CNTR_LEFT:
                    if (led == 0x80)
                        led = 0x1;
                    else
                        led = led << 1;
 1200440:	e0bfff17 	ldw	r2,-4(fp)
 1200444:	1085883a 	add	r2,r2,r2
 1200448:	e0bfff15 	stw	r2,-4(fp)
                    break;
 120044c:	0001883a 	nop

            }
            edge_capture = 0xF;
 1200450:	008003c4 	movi	r2,15
 1200454:	d0a01015 	stw	r2,-32704(gp)

            IOWR_ALTERA_AVALON_PIO_DATA(GREEN_LED_BASE, led);
 1200458:	00805034 	movhi	r2,320
 120045c:	10841404 	addi	r2,r2,4176
 1200460:	e0ffff17 	ldw	r3,-4(fp)
 1200464:	10c00035 	stwio	r3,0(r2)

            usleep (DEBOUNCE);
 1200468:	011d4c04 	movi	r4,30000
 120046c:	12039f00 	call	12039f0 <usleep>
            while (edge_capture != NONE_PRESSED)  // wait for button release
 1200470:	00000406 	br	1200484 <main+0x11c>
                edge_capture = IORD_ALTERA_AVALON_PIO_DATA(BUTTONS_BASE);
 1200474:	00805034 	movhi	r2,320
 1200478:	10841004 	addi	r2,r2,4160
 120047c:	10800037 	ldwio	r2,0(r2)
 1200480:	d0a01015 	stw	r2,-32704(gp)
            edge_capture = 0xF;

            IOWR_ALTERA_AVALON_PIO_DATA(GREEN_LED_BASE, led);

            usleep (DEBOUNCE);
            while (edge_capture != NONE_PRESSED)  // wait for button release
 1200484:	d0a01017 	ldw	r2,-32704(gp)
 1200488:	108003d8 	cmpnei	r2,r2,15
 120048c:	103ff91e 	bne	r2,zero,1200474 <__alt_mem_instruction_tcm+0xff200474>
                edge_capture = IORD_ALTERA_AVALON_PIO_DATA(BUTTONS_BASE);
            usleep (DEBOUNCE);
 1200490:	011d4c04 	movi	r4,30000
 1200494:	12039f00 	call	12039f0 <usleep>
        }

    }
 1200498:	003fc306 	br	12003a8 <__alt_mem_instruction_tcm+0xff2003a8>

0120049c <_puts_r>:
 120049c:	defff604 	addi	sp,sp,-40
 12004a0:	dc000715 	stw	r16,28(sp)
 12004a4:	2021883a 	mov	r16,r4
 12004a8:	2809883a 	mov	r4,r5
 12004ac:	dc400815 	stw	r17,32(sp)
 12004b0:	dfc00915 	stw	ra,36(sp)
 12004b4:	2823883a 	mov	r17,r5
 12004b8:	12005680 	call	1200568 <strlen>
 12004bc:	00c04874 	movhi	r3,289
 12004c0:	18e6cf04 	addi	r3,r3,-25796
 12004c4:	18c00017 	ldw	r3,0(r3)
 12004c8:	11000044 	addi	r4,r2,1
 12004cc:	d8800115 	stw	r2,4(sp)
 12004d0:	18c00217 	ldw	r3,8(r3)
 12004d4:	01404834 	movhi	r5,288
 12004d8:	295ff804 	addi	r5,r5,32736
 12004dc:	1880030b 	ldhu	r2,12(r3)
 12004e0:	d9400215 	stw	r5,8(sp)
 12004e4:	d9000615 	stw	r4,24(sp)
 12004e8:	01400044 	movi	r5,1
 12004ec:	01000084 	movi	r4,2
 12004f0:	d9000515 	stw	r4,20(sp)
 12004f4:	dc400015 	stw	r17,0(sp)
 12004f8:	d9400315 	stw	r5,12(sp)
 12004fc:	dec00415 	stw	sp,16(sp)
 1200500:	1108000c 	andi	r4,r2,8192
 1200504:	2000061e 	bne	r4,zero,1200520 <_puts_r+0x84>
 1200508:	19401917 	ldw	r5,100(r3)
 120050c:	0137ffc4 	movi	r4,-8193
 1200510:	10880014 	ori	r2,r2,8192
 1200514:	2908703a 	and	r4,r5,r4
 1200518:	1880030d 	sth	r2,12(r3)
 120051c:	19001915 	stw	r4,100(r3)
 1200520:	81400217 	ldw	r5,8(r16)
 1200524:	8009883a 	mov	r4,r16
 1200528:	d9800404 	addi	r6,sp,16
 120052c:	12006000 	call	1200600 <__sfvwrite_r>
 1200530:	1000061e 	bne	r2,zero,120054c <_puts_r+0xb0>
 1200534:	00800284 	movi	r2,10
 1200538:	dfc00917 	ldw	ra,36(sp)
 120053c:	dc400817 	ldw	r17,32(sp)
 1200540:	dc000717 	ldw	r16,28(sp)
 1200544:	dec00a04 	addi	sp,sp,40
 1200548:	f800283a 	ret
 120054c:	00bfffc4 	movi	r2,-1
 1200550:	003ff906 	br	1200538 <__alt_mem_instruction_tcm+0xff200538>

01200554 <puts>:
 1200554:	00804874 	movhi	r2,289
 1200558:	10a6cf04 	addi	r2,r2,-25796
 120055c:	200b883a 	mov	r5,r4
 1200560:	11000017 	ldw	r4,0(r2)
 1200564:	120049c1 	jmpi	120049c <_puts_r>

01200568 <strlen>:
 1200568:	208000cc 	andi	r2,r4,3
 120056c:	10002026 	beq	r2,zero,12005f0 <strlen+0x88>
 1200570:	20800007 	ldb	r2,0(r4)
 1200574:	10002026 	beq	r2,zero,12005f8 <strlen+0x90>
 1200578:	2005883a 	mov	r2,r4
 120057c:	00000206 	br	1200588 <strlen+0x20>
 1200580:	10c00007 	ldb	r3,0(r2)
 1200584:	18001826 	beq	r3,zero,12005e8 <strlen+0x80>
 1200588:	10800044 	addi	r2,r2,1
 120058c:	10c000cc 	andi	r3,r2,3
 1200590:	183ffb1e 	bne	r3,zero,1200580 <__alt_mem_instruction_tcm+0xff200580>
 1200594:	10c00017 	ldw	r3,0(r2)
 1200598:	01ffbff4 	movhi	r7,65279
 120059c:	39ffbfc4 	addi	r7,r7,-257
 12005a0:	00ca303a 	nor	r5,zero,r3
 12005a4:	01a02074 	movhi	r6,32897
 12005a8:	19c7883a 	add	r3,r3,r7
 12005ac:	31a02004 	addi	r6,r6,-32640
 12005b0:	1946703a 	and	r3,r3,r5
 12005b4:	1986703a 	and	r3,r3,r6
 12005b8:	1800091e 	bne	r3,zero,12005e0 <strlen+0x78>
 12005bc:	10800104 	addi	r2,r2,4
 12005c0:	10c00017 	ldw	r3,0(r2)
 12005c4:	19cb883a 	add	r5,r3,r7
 12005c8:	00c6303a 	nor	r3,zero,r3
 12005cc:	28c6703a 	and	r3,r5,r3
 12005d0:	1986703a 	and	r3,r3,r6
 12005d4:	183ff926 	beq	r3,zero,12005bc <__alt_mem_instruction_tcm+0xff2005bc>
 12005d8:	00000106 	br	12005e0 <strlen+0x78>
 12005dc:	10800044 	addi	r2,r2,1
 12005e0:	10c00007 	ldb	r3,0(r2)
 12005e4:	183ffd1e 	bne	r3,zero,12005dc <__alt_mem_instruction_tcm+0xff2005dc>
 12005e8:	1105c83a 	sub	r2,r2,r4
 12005ec:	f800283a 	ret
 12005f0:	2005883a 	mov	r2,r4
 12005f4:	003fe706 	br	1200594 <__alt_mem_instruction_tcm+0xff200594>
 12005f8:	0005883a 	mov	r2,zero
 12005fc:	f800283a 	ret

01200600 <__sfvwrite_r>:
 1200600:	30800217 	ldw	r2,8(r6)
 1200604:	10004526 	beq	r2,zero,120071c <__sfvwrite_r+0x11c>
 1200608:	28c0030b 	ldhu	r3,12(r5)
 120060c:	defff404 	addi	sp,sp,-48
 1200610:	dd400715 	stw	r21,28(sp)
 1200614:	dcc00515 	stw	r19,20(sp)
 1200618:	dc000215 	stw	r16,8(sp)
 120061c:	dfc00b15 	stw	ra,44(sp)
 1200620:	df000a15 	stw	fp,40(sp)
 1200624:	ddc00915 	stw	r23,36(sp)
 1200628:	dd800815 	stw	r22,32(sp)
 120062c:	dd000615 	stw	r20,24(sp)
 1200630:	dc800415 	stw	r18,16(sp)
 1200634:	dc400315 	stw	r17,12(sp)
 1200638:	1880020c 	andi	r2,r3,8
 120063c:	2821883a 	mov	r16,r5
 1200640:	202b883a 	mov	r21,r4
 1200644:	3027883a 	mov	r19,r6
 1200648:	10002526 	beq	r2,zero,12006e0 <__sfvwrite_r+0xe0>
 120064c:	28800417 	ldw	r2,16(r5)
 1200650:	10002326 	beq	r2,zero,12006e0 <__sfvwrite_r+0xe0>
 1200654:	1880008c 	andi	r2,r3,2
 1200658:	9c400017 	ldw	r17,0(r19)
 120065c:	10003126 	beq	r2,zero,1200724 <__sfvwrite_r+0x124>
 1200660:	0029883a 	mov	r20,zero
 1200664:	0025883a 	mov	r18,zero
 1200668:	05810004 	movi	r22,1024
 120066c:	a00d883a 	mov	r6,r20
 1200670:	a809883a 	mov	r4,r21
 1200674:	90002526 	beq	r18,zero,120070c <__sfvwrite_r+0x10c>
 1200678:	900f883a 	mov	r7,r18
 120067c:	81400717 	ldw	r5,28(r16)
 1200680:	b480012e 	bgeu	r22,r18,1200688 <__sfvwrite_r+0x88>
 1200684:	01c10004 	movi	r7,1024
 1200688:	80800917 	ldw	r2,36(r16)
 120068c:	103ee83a 	callr	r2
 1200690:	0080510e 	bge	zero,r2,12007d8 <__sfvwrite_r+0x1d8>
 1200694:	98c00217 	ldw	r3,8(r19)
 1200698:	a0a9883a 	add	r20,r20,r2
 120069c:	90a5c83a 	sub	r18,r18,r2
 12006a0:	1885c83a 	sub	r2,r3,r2
 12006a4:	98800215 	stw	r2,8(r19)
 12006a8:	103ff01e 	bne	r2,zero,120066c <__alt_mem_instruction_tcm+0xff20066c>
 12006ac:	0005883a 	mov	r2,zero
 12006b0:	dfc00b17 	ldw	ra,44(sp)
 12006b4:	df000a17 	ldw	fp,40(sp)
 12006b8:	ddc00917 	ldw	r23,36(sp)
 12006bc:	dd800817 	ldw	r22,32(sp)
 12006c0:	dd400717 	ldw	r21,28(sp)
 12006c4:	dd000617 	ldw	r20,24(sp)
 12006c8:	dcc00517 	ldw	r19,20(sp)
 12006cc:	dc800417 	ldw	r18,16(sp)
 12006d0:	dc400317 	ldw	r17,12(sp)
 12006d4:	dc000217 	ldw	r16,8(sp)
 12006d8:	dec00c04 	addi	sp,sp,48
 12006dc:	f800283a 	ret
 12006e0:	a809883a 	mov	r4,r21
 12006e4:	800b883a 	mov	r5,r16
 12006e8:	1201bbc0 	call	1201bbc <__swsetup_r>
 12006ec:	80c0030b 	ldhu	r3,12(r16)
 12006f0:	103fd826 	beq	r2,zero,1200654 <__alt_mem_instruction_tcm+0xff200654>
 12006f4:	18c01014 	ori	r3,r3,64
 12006f8:	80c0030d 	sth	r3,12(r16)
 12006fc:	00c00244 	movi	r3,9
 1200700:	00bfffc4 	movi	r2,-1
 1200704:	a8c00015 	stw	r3,0(r21)
 1200708:	003fe906 	br	12006b0 <__alt_mem_instruction_tcm+0xff2006b0>
 120070c:	8d000017 	ldw	r20,0(r17)
 1200710:	8c800117 	ldw	r18,4(r17)
 1200714:	8c400204 	addi	r17,r17,8
 1200718:	003fd406 	br	120066c <__alt_mem_instruction_tcm+0xff20066c>
 120071c:	0005883a 	mov	r2,zero
 1200720:	f800283a 	ret
 1200724:	1880004c 	andi	r2,r3,1
 1200728:	1000301e 	bne	r2,zero,12007ec <__sfvwrite_r+0x1ec>
 120072c:	002f883a 	mov	r23,zero
 1200730:	0025883a 	mov	r18,zero
 1200734:	90001c26 	beq	r18,zero,12007a8 <__sfvwrite_r+0x1a8>
 1200738:	1880800c 	andi	r2,r3,512
 120073c:	85000217 	ldw	r20,8(r16)
 1200740:	10006c26 	beq	r2,zero,12008f4 <__sfvwrite_r+0x2f4>
 1200744:	a02d883a 	mov	r22,r20
 1200748:	95008536 	bltu	r18,r20,1200960 <__sfvwrite_r+0x360>
 120074c:	1881200c 	andi	r2,r3,1152
 1200750:	10009d1e 	bne	r2,zero,12009c8 <__sfvwrite_r+0x3c8>
 1200754:	81000017 	ldw	r4,0(r16)
 1200758:	a039883a 	mov	fp,r20
 120075c:	9029883a 	mov	r20,r18
 1200760:	b80b883a 	mov	r5,r23
 1200764:	b00d883a 	mov	r6,r22
 1200768:	120146c0 	call	120146c <memmove>
 120076c:	80c00217 	ldw	r3,8(r16)
 1200770:	81000017 	ldw	r4,0(r16)
 1200774:	9005883a 	mov	r2,r18
 1200778:	1f39c83a 	sub	fp,r3,fp
 120077c:	258f883a 	add	r7,r4,r22
 1200780:	87000215 	stw	fp,8(r16)
 1200784:	81c00015 	stw	r7,0(r16)
 1200788:	98c00217 	ldw	r3,8(r19)
 120078c:	b8af883a 	add	r23,r23,r2
 1200790:	90a5c83a 	sub	r18,r18,r2
 1200794:	1d05c83a 	sub	r2,r3,r20
 1200798:	98800215 	stw	r2,8(r19)
 120079c:	103fc326 	beq	r2,zero,12006ac <__alt_mem_instruction_tcm+0xff2006ac>
 12007a0:	80c0030b 	ldhu	r3,12(r16)
 12007a4:	903fe41e 	bne	r18,zero,1200738 <__alt_mem_instruction_tcm+0xff200738>
 12007a8:	8dc00017 	ldw	r23,0(r17)
 12007ac:	8c800117 	ldw	r18,4(r17)
 12007b0:	8c400204 	addi	r17,r17,8
 12007b4:	003fdf06 	br	1200734 <__alt_mem_instruction_tcm+0xff200734>
 12007b8:	12015c80 	call	12015c8 <_realloc_r>
 12007bc:	102d883a 	mov	r22,r2
 12007c0:	1000a01e 	bne	r2,zero,1200a44 <__sfvwrite_r+0x444>
 12007c4:	81400417 	ldw	r5,16(r16)
 12007c8:	a809883a 	mov	r4,r21
 12007cc:	12024080 	call	1202408 <_free_r>
 12007d0:	00800304 	movi	r2,12
 12007d4:	a8800015 	stw	r2,0(r21)
 12007d8:	80c0030b 	ldhu	r3,12(r16)
 12007dc:	00bfffc4 	movi	r2,-1
 12007e0:	18c01014 	ori	r3,r3,64
 12007e4:	80c0030d 	sth	r3,12(r16)
 12007e8:	003fb106 	br	12006b0 <__alt_mem_instruction_tcm+0xff2006b0>
 12007ec:	0029883a 	mov	r20,zero
 12007f0:	0011883a 	mov	r8,zero
 12007f4:	0039883a 	mov	fp,zero
 12007f8:	0025883a 	mov	r18,zero
 12007fc:	90001f26 	beq	r18,zero,120087c <__sfvwrite_r+0x27c>
 1200800:	40006826 	beq	r8,zero,12009a4 <__sfvwrite_r+0x3a4>
 1200804:	a02f883a 	mov	r23,r20
 1200808:	9500012e 	bgeu	r18,r20,1200810 <__sfvwrite_r+0x210>
 120080c:	902f883a 	mov	r23,r18
 1200810:	81000017 	ldw	r4,0(r16)
 1200814:	80800417 	ldw	r2,16(r16)
 1200818:	b82d883a 	mov	r22,r23
 120081c:	81800217 	ldw	r6,8(r16)
 1200820:	81c00517 	ldw	r7,20(r16)
 1200824:	1100022e 	bgeu	r2,r4,1200830 <__sfvwrite_r+0x230>
 1200828:	31c7883a 	add	r3,r6,r7
 120082c:	1dc01816 	blt	r3,r23,1200890 <__sfvwrite_r+0x290>
 1200830:	b9c03f16 	blt	r23,r7,1200930 <__sfvwrite_r+0x330>
 1200834:	80800917 	ldw	r2,36(r16)
 1200838:	81400717 	ldw	r5,28(r16)
 120083c:	a809883a 	mov	r4,r21
 1200840:	da000115 	stw	r8,4(sp)
 1200844:	e00d883a 	mov	r6,fp
 1200848:	103ee83a 	callr	r2
 120084c:	102d883a 	mov	r22,r2
 1200850:	da000117 	ldw	r8,4(sp)
 1200854:	00bfe00e 	bge	zero,r2,12007d8 <__alt_mem_instruction_tcm+0xff2007d8>
 1200858:	a5a9c83a 	sub	r20,r20,r22
 120085c:	a0001f26 	beq	r20,zero,12008dc <__sfvwrite_r+0x2dc>
 1200860:	98800217 	ldw	r2,8(r19)
 1200864:	e5b9883a 	add	fp,fp,r22
 1200868:	95a5c83a 	sub	r18,r18,r22
 120086c:	15adc83a 	sub	r22,r2,r22
 1200870:	9d800215 	stw	r22,8(r19)
 1200874:	b03f8d26 	beq	r22,zero,12006ac <__alt_mem_instruction_tcm+0xff2006ac>
 1200878:	903fe11e 	bne	r18,zero,1200800 <__alt_mem_instruction_tcm+0xff200800>
 120087c:	8f000017 	ldw	fp,0(r17)
 1200880:	8c800117 	ldw	r18,4(r17)
 1200884:	0011883a 	mov	r8,zero
 1200888:	8c400204 	addi	r17,r17,8
 120088c:	003fdb06 	br	12007fc <__alt_mem_instruction_tcm+0xff2007fc>
 1200890:	180d883a 	mov	r6,r3
 1200894:	e00b883a 	mov	r5,fp
 1200898:	da000115 	stw	r8,4(sp)
 120089c:	d8c00015 	stw	r3,0(sp)
 12008a0:	120146c0 	call	120146c <memmove>
 12008a4:	d8c00017 	ldw	r3,0(sp)
 12008a8:	80800017 	ldw	r2,0(r16)
 12008ac:	a809883a 	mov	r4,r21
 12008b0:	800b883a 	mov	r5,r16
 12008b4:	10c5883a 	add	r2,r2,r3
 12008b8:	80800015 	stw	r2,0(r16)
 12008bc:	d8c00015 	stw	r3,0(sp)
 12008c0:	1201cec0 	call	1201cec <_fflush_r>
 12008c4:	d8c00017 	ldw	r3,0(sp)
 12008c8:	da000117 	ldw	r8,4(sp)
 12008cc:	103fc21e 	bne	r2,zero,12007d8 <__alt_mem_instruction_tcm+0xff2007d8>
 12008d0:	182d883a 	mov	r22,r3
 12008d4:	a5a9c83a 	sub	r20,r20,r22
 12008d8:	a03fe11e 	bne	r20,zero,1200860 <__alt_mem_instruction_tcm+0xff200860>
 12008dc:	a809883a 	mov	r4,r21
 12008e0:	800b883a 	mov	r5,r16
 12008e4:	1201cec0 	call	1201cec <_fflush_r>
 12008e8:	103fbb1e 	bne	r2,zero,12007d8 <__alt_mem_instruction_tcm+0xff2007d8>
 12008ec:	0011883a 	mov	r8,zero
 12008f0:	003fdb06 	br	1200860 <__alt_mem_instruction_tcm+0xff200860>
 12008f4:	81000017 	ldw	r4,0(r16)
 12008f8:	80800417 	ldw	r2,16(r16)
 12008fc:	1100012e 	bgeu	r2,r4,1200904 <__sfvwrite_r+0x304>
 1200900:	a4805a36 	bltu	r20,r18,1200a6c <__sfvwrite_r+0x46c>
 1200904:	81c00517 	ldw	r7,20(r16)
 1200908:	91c01a36 	bltu	r18,r7,1200974 <__sfvwrite_r+0x374>
 120090c:	80800917 	ldw	r2,36(r16)
 1200910:	81400717 	ldw	r5,28(r16)
 1200914:	a809883a 	mov	r4,r21
 1200918:	b80d883a 	mov	r6,r23
 120091c:	103ee83a 	callr	r2
 1200920:	1029883a 	mov	r20,r2
 1200924:	00bfac0e 	bge	zero,r2,12007d8 <__alt_mem_instruction_tcm+0xff2007d8>
 1200928:	a005883a 	mov	r2,r20
 120092c:	003f9606 	br	1200788 <__alt_mem_instruction_tcm+0xff200788>
 1200930:	b80d883a 	mov	r6,r23
 1200934:	e00b883a 	mov	r5,fp
 1200938:	da000115 	stw	r8,4(sp)
 120093c:	120146c0 	call	120146c <memmove>
 1200940:	80800217 	ldw	r2,8(r16)
 1200944:	80c00017 	ldw	r3,0(r16)
 1200948:	da000117 	ldw	r8,4(sp)
 120094c:	15c5c83a 	sub	r2,r2,r23
 1200950:	1def883a 	add	r23,r3,r23
 1200954:	80800215 	stw	r2,8(r16)
 1200958:	85c00015 	stw	r23,0(r16)
 120095c:	003fbe06 	br	1200858 <__alt_mem_instruction_tcm+0xff200858>
 1200960:	81000017 	ldw	r4,0(r16)
 1200964:	9039883a 	mov	fp,r18
 1200968:	9029883a 	mov	r20,r18
 120096c:	902d883a 	mov	r22,r18
 1200970:	003f7b06 	br	1200760 <__alt_mem_instruction_tcm+0xff200760>
 1200974:	b80b883a 	mov	r5,r23
 1200978:	900d883a 	mov	r6,r18
 120097c:	120146c0 	call	120146c <memmove>
 1200980:	80c00217 	ldw	r3,8(r16)
 1200984:	80800017 	ldw	r2,0(r16)
 1200988:	9029883a 	mov	r20,r18
 120098c:	1c87c83a 	sub	r3,r3,r18
 1200990:	1485883a 	add	r2,r2,r18
 1200994:	80800015 	stw	r2,0(r16)
 1200998:	80c00215 	stw	r3,8(r16)
 120099c:	9005883a 	mov	r2,r18
 12009a0:	003f7906 	br	1200788 <__alt_mem_instruction_tcm+0xff200788>
 12009a4:	e009883a 	mov	r4,fp
 12009a8:	01400284 	movi	r5,10
 12009ac:	900d883a 	mov	r6,r18
 12009b0:	120124c0 	call	120124c <memchr>
 12009b4:	10003826 	beq	r2,zero,1200a98 <__sfvwrite_r+0x498>
 12009b8:	10800044 	addi	r2,r2,1
 12009bc:	1729c83a 	sub	r20,r2,fp
 12009c0:	02000044 	movi	r8,1
 12009c4:	003f8f06 	br	1200804 <__alt_mem_instruction_tcm+0xff200804>
 12009c8:	80800517 	ldw	r2,20(r16)
 12009cc:	81400417 	ldw	r5,16(r16)
 12009d0:	87000017 	ldw	fp,0(r16)
 12009d4:	10a9883a 	add	r20,r2,r2
 12009d8:	a085883a 	add	r2,r20,r2
 12009dc:	1028d7fa 	srli	r20,r2,31
 12009e0:	e179c83a 	sub	fp,fp,r5
 12009e4:	e1000044 	addi	r4,fp,1
 12009e8:	a085883a 	add	r2,r20,r2
 12009ec:	1029d07a 	srai	r20,r2,1
 12009f0:	2485883a 	add	r2,r4,r18
 12009f4:	a00d883a 	mov	r6,r20
 12009f8:	a080022e 	bgeu	r20,r2,1200a04 <__sfvwrite_r+0x404>
 12009fc:	1029883a 	mov	r20,r2
 1200a00:	100d883a 	mov	r6,r2
 1200a04:	18c1000c 	andi	r3,r3,1024
 1200a08:	a809883a 	mov	r4,r21
 1200a0c:	183f6a26 	beq	r3,zero,12007b8 <__alt_mem_instruction_tcm+0xff2007b8>
 1200a10:	300b883a 	mov	r5,r6
 1200a14:	1200aa40 	call	1200aa4 <_malloc_r>
 1200a18:	102d883a 	mov	r22,r2
 1200a1c:	103f6c26 	beq	r2,zero,12007d0 <__alt_mem_instruction_tcm+0xff2007d0>
 1200a20:	81400417 	ldw	r5,16(r16)
 1200a24:	1009883a 	mov	r4,r2
 1200a28:	e00d883a 	mov	r6,fp
 1200a2c:	12013340 	call	1201334 <memcpy>
 1200a30:	8080030b 	ldhu	r2,12(r16)
 1200a34:	00fedfc4 	movi	r3,-1153
 1200a38:	10c4703a 	and	r2,r2,r3
 1200a3c:	10802014 	ori	r2,r2,128
 1200a40:	8080030d 	sth	r2,12(r16)
 1200a44:	b709883a 	add	r4,r22,fp
 1200a48:	a707c83a 	sub	r3,r20,fp
 1200a4c:	85800415 	stw	r22,16(r16)
 1200a50:	85000515 	stw	r20,20(r16)
 1200a54:	81000015 	stw	r4,0(r16)
 1200a58:	9039883a 	mov	fp,r18
 1200a5c:	80c00215 	stw	r3,8(r16)
 1200a60:	9029883a 	mov	r20,r18
 1200a64:	902d883a 	mov	r22,r18
 1200a68:	003f3d06 	br	1200760 <__alt_mem_instruction_tcm+0xff200760>
 1200a6c:	b80b883a 	mov	r5,r23
 1200a70:	a00d883a 	mov	r6,r20
 1200a74:	120146c0 	call	120146c <memmove>
 1200a78:	80800017 	ldw	r2,0(r16)
 1200a7c:	a809883a 	mov	r4,r21
 1200a80:	800b883a 	mov	r5,r16
 1200a84:	1505883a 	add	r2,r2,r20
 1200a88:	80800015 	stw	r2,0(r16)
 1200a8c:	1201cec0 	call	1201cec <_fflush_r>
 1200a90:	103fa526 	beq	r2,zero,1200928 <__alt_mem_instruction_tcm+0xff200928>
 1200a94:	003f5006 	br	12007d8 <__alt_mem_instruction_tcm+0xff2007d8>
 1200a98:	95000044 	addi	r20,r18,1
 1200a9c:	02000044 	movi	r8,1
 1200aa0:	003f5806 	br	1200804 <__alt_mem_instruction_tcm+0xff200804>

01200aa4 <_malloc_r>:
 1200aa4:	defff504 	addi	sp,sp,-44
 1200aa8:	dc800315 	stw	r18,12(sp)
 1200aac:	dfc00a15 	stw	ra,40(sp)
 1200ab0:	df000915 	stw	fp,36(sp)
 1200ab4:	ddc00815 	stw	r23,32(sp)
 1200ab8:	dd800715 	stw	r22,28(sp)
 1200abc:	dd400615 	stw	r21,24(sp)
 1200ac0:	dd000515 	stw	r20,20(sp)
 1200ac4:	dcc00415 	stw	r19,16(sp)
 1200ac8:	dc400215 	stw	r17,8(sp)
 1200acc:	dc000115 	stw	r16,4(sp)
 1200ad0:	288002c4 	addi	r2,r5,11
 1200ad4:	00c00584 	movi	r3,22
 1200ad8:	2025883a 	mov	r18,r4
 1200adc:	18802a2e 	bgeu	r3,r2,1200b88 <_malloc_r+0xe4>
 1200ae0:	047ffe04 	movi	r17,-8
 1200ae4:	1462703a 	and	r17,r2,r17
 1200ae8:	88009e16 	blt	r17,zero,1200d64 <_malloc_r+0x2c0>
 1200aec:	89409d36 	bltu	r17,r5,1200d64 <_malloc_r+0x2c0>
 1200af0:	12037540 	call	1203754 <__malloc_lock>
 1200af4:	00807dc4 	movi	r2,503
 1200af8:	14402736 	bltu	r2,r17,1200b98 <_malloc_r+0xf4>
 1200afc:	8806d0fa 	srli	r3,r17,3
 1200b00:	04c04874 	movhi	r19,289
 1200b04:	9ce11304 	addi	r19,r19,-31668
 1200b08:	18c5883a 	add	r2,r3,r3
 1200b0c:	1085883a 	add	r2,r2,r2
 1200b10:	1085883a 	add	r2,r2,r2
 1200b14:	9885883a 	add	r2,r19,r2
 1200b18:	14000317 	ldw	r16,12(r2)
 1200b1c:	80814a26 	beq	r16,r2,1201048 <_malloc_r+0x5a4>
 1200b20:	80c00117 	ldw	r3,4(r16)
 1200b24:	81000317 	ldw	r4,12(r16)
 1200b28:	00bfff04 	movi	r2,-4
 1200b2c:	1884703a 	and	r2,r3,r2
 1200b30:	81400217 	ldw	r5,8(r16)
 1200b34:	8085883a 	add	r2,r16,r2
 1200b38:	10c00117 	ldw	r3,4(r2)
 1200b3c:	29000315 	stw	r4,12(r5)
 1200b40:	21400215 	stw	r5,8(r4)
 1200b44:	18c00054 	ori	r3,r3,1
 1200b48:	10c00115 	stw	r3,4(r2)
 1200b4c:	9009883a 	mov	r4,r18
 1200b50:	12037740 	call	1203774 <__malloc_unlock>
 1200b54:	80800204 	addi	r2,r16,8
 1200b58:	dfc00a17 	ldw	ra,40(sp)
 1200b5c:	df000917 	ldw	fp,36(sp)
 1200b60:	ddc00817 	ldw	r23,32(sp)
 1200b64:	dd800717 	ldw	r22,28(sp)
 1200b68:	dd400617 	ldw	r21,24(sp)
 1200b6c:	dd000517 	ldw	r20,20(sp)
 1200b70:	dcc00417 	ldw	r19,16(sp)
 1200b74:	dc800317 	ldw	r18,12(sp)
 1200b78:	dc400217 	ldw	r17,8(sp)
 1200b7c:	dc000117 	ldw	r16,4(sp)
 1200b80:	dec00b04 	addi	sp,sp,44
 1200b84:	f800283a 	ret
 1200b88:	04400404 	movi	r17,16
 1200b8c:	89407536 	bltu	r17,r5,1200d64 <_malloc_r+0x2c0>
 1200b90:	12037540 	call	1203754 <__malloc_lock>
 1200b94:	003fd906 	br	1200afc <__alt_mem_instruction_tcm+0xff200afc>
 1200b98:	8806d27a 	srli	r3,r17,9
 1200b9c:	18007526 	beq	r3,zero,1200d74 <_malloc_r+0x2d0>
 1200ba0:	00800104 	movi	r2,4
 1200ba4:	10c0ef36 	bltu	r2,r3,1200f64 <_malloc_r+0x4c0>
 1200ba8:	8806d1ba 	srli	r3,r17,6
 1200bac:	19c00e04 	addi	r7,r3,56
 1200bb0:	39cb883a 	add	r5,r7,r7
 1200bb4:	04c04874 	movhi	r19,289
 1200bb8:	294b883a 	add	r5,r5,r5
 1200bbc:	9ce11304 	addi	r19,r19,-31668
 1200bc0:	294b883a 	add	r5,r5,r5
 1200bc4:	994b883a 	add	r5,r19,r5
 1200bc8:	2c000317 	ldw	r16,12(r5)
 1200bcc:	2c000e26 	beq	r5,r16,1200c08 <_malloc_r+0x164>
 1200bd0:	80800117 	ldw	r2,4(r16)
 1200bd4:	01bfff04 	movi	r6,-4
 1200bd8:	010003c4 	movi	r4,15
 1200bdc:	1184703a 	and	r2,r2,r6
 1200be0:	1447c83a 	sub	r3,r2,r17
 1200be4:	20c00716 	blt	r4,r3,1200c04 <_malloc_r+0x160>
 1200be8:	1800650e 	bge	r3,zero,1200d80 <_malloc_r+0x2dc>
 1200bec:	84000317 	ldw	r16,12(r16)
 1200bf0:	2c000526 	beq	r5,r16,1200c08 <_malloc_r+0x164>
 1200bf4:	80800117 	ldw	r2,4(r16)
 1200bf8:	1184703a 	and	r2,r2,r6
 1200bfc:	1447c83a 	sub	r3,r2,r17
 1200c00:	20fff90e 	bge	r4,r3,1200be8 <__alt_mem_instruction_tcm+0xff200be8>
 1200c04:	39ffffc4 	addi	r7,r7,-1
 1200c08:	38c00044 	addi	r3,r7,1
 1200c0c:	01804874 	movhi	r6,289
 1200c10:	9c000417 	ldw	r16,16(r19)
 1200c14:	31a11304 	addi	r6,r6,-31668
 1200c18:	32400204 	addi	r9,r6,8
 1200c1c:	82410326 	beq	r16,r9,120102c <_malloc_r+0x588>
 1200c20:	81000117 	ldw	r4,4(r16)
 1200c24:	00bfff04 	movi	r2,-4
 1200c28:	208e703a 	and	r7,r4,r2
 1200c2c:	3c45c83a 	sub	r2,r7,r17
 1200c30:	010003c4 	movi	r4,15
 1200c34:	2080ee16 	blt	r4,r2,1200ff0 <_malloc_r+0x54c>
 1200c38:	32400515 	stw	r9,20(r6)
 1200c3c:	32400415 	stw	r9,16(r6)
 1200c40:	1000510e 	bge	r2,zero,1200d88 <_malloc_r+0x2e4>
 1200c44:	00807fc4 	movi	r2,511
 1200c48:	11c0ce36 	bltu	r2,r7,1200f84 <_malloc_r+0x4e0>
 1200c4c:	3808d0fa 	srli	r4,r7,3
 1200c50:	01c00044 	movi	r7,1
 1200c54:	30800117 	ldw	r2,4(r6)
 1200c58:	210b883a 	add	r5,r4,r4
 1200c5c:	294b883a 	add	r5,r5,r5
 1200c60:	2009d0ba 	srai	r4,r4,2
 1200c64:	294b883a 	add	r5,r5,r5
 1200c68:	298b883a 	add	r5,r5,r6
 1200c6c:	2a000217 	ldw	r8,8(r5)
 1200c70:	3908983a 	sll	r4,r7,r4
 1200c74:	81400315 	stw	r5,12(r16)
 1200c78:	82000215 	stw	r8,8(r16)
 1200c7c:	2088b03a 	or	r4,r4,r2
 1200c80:	2c000215 	stw	r16,8(r5)
 1200c84:	31000115 	stw	r4,4(r6)
 1200c88:	44000315 	stw	r16,12(r8)
 1200c8c:	1805d0ba 	srai	r2,r3,2
 1200c90:	01400044 	movi	r5,1
 1200c94:	288a983a 	sll	r5,r5,r2
 1200c98:	21404336 	bltu	r4,r5,1200da8 <_malloc_r+0x304>
 1200c9c:	2144703a 	and	r2,r4,r5
 1200ca0:	10000a1e 	bne	r2,zero,1200ccc <_malloc_r+0x228>
 1200ca4:	00bfff04 	movi	r2,-4
 1200ca8:	294b883a 	add	r5,r5,r5
 1200cac:	1886703a 	and	r3,r3,r2
 1200cb0:	2144703a 	and	r2,r4,r5
 1200cb4:	18c00104 	addi	r3,r3,4
 1200cb8:	1000041e 	bne	r2,zero,1200ccc <_malloc_r+0x228>
 1200cbc:	294b883a 	add	r5,r5,r5
 1200cc0:	2144703a 	and	r2,r4,r5
 1200cc4:	18c00104 	addi	r3,r3,4
 1200cc8:	103ffc26 	beq	r2,zero,1200cbc <__alt_mem_instruction_tcm+0xff200cbc>
 1200ccc:	023fff04 	movi	r8,-4
 1200cd0:	01c003c4 	movi	r7,15
 1200cd4:	18c5883a 	add	r2,r3,r3
 1200cd8:	1085883a 	add	r2,r2,r2
 1200cdc:	1085883a 	add	r2,r2,r2
 1200ce0:	9895883a 	add	r10,r19,r2
 1200ce4:	52c00304 	addi	r11,r10,12
 1200ce8:	1819883a 	mov	r12,r3
 1200cec:	5c000017 	ldw	r16,0(r11)
 1200cf0:	59bffd04 	addi	r6,r11,-12
 1200cf4:	8180041e 	bne	r16,r6,1200d08 <_malloc_r+0x264>
 1200cf8:	0000ce06 	br	1201034 <_malloc_r+0x590>
 1200cfc:	2000d70e 	bge	r4,zero,120105c <_malloc_r+0x5b8>
 1200d00:	84000317 	ldw	r16,12(r16)
 1200d04:	8180cb26 	beq	r16,r6,1201034 <_malloc_r+0x590>
 1200d08:	80800117 	ldw	r2,4(r16)
 1200d0c:	1204703a 	and	r2,r2,r8
 1200d10:	1449c83a 	sub	r4,r2,r17
 1200d14:	393ff90e 	bge	r7,r4,1200cfc <__alt_mem_instruction_tcm+0xff200cfc>
 1200d18:	80800317 	ldw	r2,12(r16)
 1200d1c:	80c00217 	ldw	r3,8(r16)
 1200d20:	89400054 	ori	r5,r17,1
 1200d24:	81400115 	stw	r5,4(r16)
 1200d28:	18800315 	stw	r2,12(r3)
 1200d2c:	10c00215 	stw	r3,8(r2)
 1200d30:	8463883a 	add	r17,r16,r17
 1200d34:	9c400515 	stw	r17,20(r19)
 1200d38:	9c400415 	stw	r17,16(r19)
 1200d3c:	20800054 	ori	r2,r4,1
 1200d40:	88800115 	stw	r2,4(r17)
 1200d44:	8a400315 	stw	r9,12(r17)
 1200d48:	8a400215 	stw	r9,8(r17)
 1200d4c:	8923883a 	add	r17,r17,r4
 1200d50:	89000015 	stw	r4,0(r17)
 1200d54:	9009883a 	mov	r4,r18
 1200d58:	12037740 	call	1203774 <__malloc_unlock>
 1200d5c:	80800204 	addi	r2,r16,8
 1200d60:	003f7d06 	br	1200b58 <__alt_mem_instruction_tcm+0xff200b58>
 1200d64:	00800304 	movi	r2,12
 1200d68:	90800015 	stw	r2,0(r18)
 1200d6c:	0005883a 	mov	r2,zero
 1200d70:	003f7906 	br	1200b58 <__alt_mem_instruction_tcm+0xff200b58>
 1200d74:	01401f84 	movi	r5,126
 1200d78:	01c00fc4 	movi	r7,63
 1200d7c:	003f8d06 	br	1200bb4 <__alt_mem_instruction_tcm+0xff200bb4>
 1200d80:	81000317 	ldw	r4,12(r16)
 1200d84:	003f6a06 	br	1200b30 <__alt_mem_instruction_tcm+0xff200b30>
 1200d88:	81c5883a 	add	r2,r16,r7
 1200d8c:	10c00117 	ldw	r3,4(r2)
 1200d90:	9009883a 	mov	r4,r18
 1200d94:	18c00054 	ori	r3,r3,1
 1200d98:	10c00115 	stw	r3,4(r2)
 1200d9c:	12037740 	call	1203774 <__malloc_unlock>
 1200da0:	80800204 	addi	r2,r16,8
 1200da4:	003f6c06 	br	1200b58 <__alt_mem_instruction_tcm+0xff200b58>
 1200da8:	9c000217 	ldw	r16,8(r19)
 1200dac:	00bfff04 	movi	r2,-4
 1200db0:	85800117 	ldw	r22,4(r16)
 1200db4:	b0ac703a 	and	r22,r22,r2
 1200db8:	b4400336 	bltu	r22,r17,1200dc8 <_malloc_r+0x324>
 1200dbc:	b445c83a 	sub	r2,r22,r17
 1200dc0:	00c003c4 	movi	r3,15
 1200dc4:	18805d16 	blt	r3,r2,1200f3c <_malloc_r+0x498>
 1200dc8:	05c04874 	movhi	r23,289
 1200dcc:	00804874 	movhi	r2,289
 1200dd0:	bde6d004 	addi	r23,r23,-25792
 1200dd4:	10a6e104 	addi	r2,r2,-25724
 1200dd8:	15400017 	ldw	r21,0(r2)
 1200ddc:	b9000017 	ldw	r4,0(r23)
 1200de0:	00ffffc4 	movi	r3,-1
 1200de4:	858d883a 	add	r6,r16,r22
 1200de8:	8d6b883a 	add	r21,r17,r21
 1200dec:	20c0e426 	beq	r4,r3,1201180 <_malloc_r+0x6dc>
 1200df0:	ad4403c4 	addi	r21,r21,4111
 1200df4:	00fc0004 	movi	r3,-4096
 1200df8:	a8ea703a 	and	r21,r21,r3
 1200dfc:	9009883a 	mov	r4,r18
 1200e00:	a80b883a 	mov	r5,r21
 1200e04:	d9800015 	stw	r6,0(sp)
 1200e08:	1201b680 	call	1201b68 <_sbrk_r>
 1200e0c:	00ffffc4 	movi	r3,-1
 1200e10:	1029883a 	mov	r20,r2
 1200e14:	d9800017 	ldw	r6,0(sp)
 1200e18:	10c0a426 	beq	r2,r3,12010ac <_malloc_r+0x608>
 1200e1c:	1180a236 	bltu	r2,r6,12010a8 <_malloc_r+0x604>
 1200e20:	07004874 	movhi	fp,289
 1200e24:	e726ea04 	addi	fp,fp,-25688
 1200e28:	e0c00017 	ldw	r3,0(fp)
 1200e2c:	a8c7883a 	add	r3,r21,r3
 1200e30:	e0c00015 	stw	r3,0(fp)
 1200e34:	3500da26 	beq	r6,r20,12011a0 <_malloc_r+0x6fc>
 1200e38:	b9000017 	ldw	r4,0(r23)
 1200e3c:	00bfffc4 	movi	r2,-1
 1200e40:	2080e426 	beq	r4,r2,12011d4 <_malloc_r+0x730>
 1200e44:	a185c83a 	sub	r2,r20,r6
 1200e48:	1885883a 	add	r2,r3,r2
 1200e4c:	e0800015 	stw	r2,0(fp)
 1200e50:	a0c001cc 	andi	r3,r20,7
 1200e54:	1800b526 	beq	r3,zero,120112c <_malloc_r+0x688>
 1200e58:	a0e9c83a 	sub	r20,r20,r3
 1200e5c:	00840204 	movi	r2,4104
 1200e60:	a5000204 	addi	r20,r20,8
 1200e64:	10c7c83a 	sub	r3,r2,r3
 1200e68:	a545883a 	add	r2,r20,r21
 1200e6c:	1083ffcc 	andi	r2,r2,4095
 1200e70:	18abc83a 	sub	r21,r3,r2
 1200e74:	9009883a 	mov	r4,r18
 1200e78:	a80b883a 	mov	r5,r21
 1200e7c:	1201b680 	call	1201b68 <_sbrk_r>
 1200e80:	00ffffc4 	movi	r3,-1
 1200e84:	10c0d026 	beq	r2,r3,12011c8 <_malloc_r+0x724>
 1200e88:	1507c83a 	sub	r3,r2,r20
 1200e8c:	a8c7883a 	add	r3,r21,r3
 1200e90:	18c00054 	ori	r3,r3,1
 1200e94:	e0800017 	ldw	r2,0(fp)
 1200e98:	9d000215 	stw	r20,8(r19)
 1200e9c:	a0c00115 	stw	r3,4(r20)
 1200ea0:	a887883a 	add	r3,r21,r2
 1200ea4:	e0c00015 	stw	r3,0(fp)
 1200ea8:	84c00e26 	beq	r16,r19,1200ee4 <_malloc_r+0x440>
 1200eac:	018003c4 	movi	r6,15
 1200eb0:	3580a02e 	bgeu	r6,r22,1201134 <_malloc_r+0x690>
 1200eb4:	81400117 	ldw	r5,4(r16)
 1200eb8:	013ffe04 	movi	r4,-8
 1200ebc:	b0bffd04 	addi	r2,r22,-12
 1200ec0:	1104703a 	and	r2,r2,r4
 1200ec4:	2900004c 	andi	r4,r5,1
 1200ec8:	1108b03a 	or	r4,r2,r4
 1200ecc:	81000115 	stw	r4,4(r16)
 1200ed0:	01400144 	movi	r5,5
 1200ed4:	8089883a 	add	r4,r16,r2
 1200ed8:	21400115 	stw	r5,4(r4)
 1200edc:	21400215 	stw	r5,8(r4)
 1200ee0:	3080c036 	bltu	r6,r2,12011e4 <_malloc_r+0x740>
 1200ee4:	00804874 	movhi	r2,289
 1200ee8:	10a6e004 	addi	r2,r2,-25728
 1200eec:	11000017 	ldw	r4,0(r2)
 1200ef0:	20c0012e 	bgeu	r4,r3,1200ef8 <_malloc_r+0x454>
 1200ef4:	10c00015 	stw	r3,0(r2)
 1200ef8:	00804874 	movhi	r2,289
 1200efc:	10a6df04 	addi	r2,r2,-25732
 1200f00:	11000017 	ldw	r4,0(r2)
 1200f04:	9c000217 	ldw	r16,8(r19)
 1200f08:	20c0012e 	bgeu	r4,r3,1200f10 <_malloc_r+0x46c>
 1200f0c:	10c00015 	stw	r3,0(r2)
 1200f10:	80c00117 	ldw	r3,4(r16)
 1200f14:	00bfff04 	movi	r2,-4
 1200f18:	1886703a 	and	r3,r3,r2
 1200f1c:	1c45c83a 	sub	r2,r3,r17
 1200f20:	1c400236 	bltu	r3,r17,1200f2c <_malloc_r+0x488>
 1200f24:	00c003c4 	movi	r3,15
 1200f28:	18800416 	blt	r3,r2,1200f3c <_malloc_r+0x498>
 1200f2c:	9009883a 	mov	r4,r18
 1200f30:	12037740 	call	1203774 <__malloc_unlock>
 1200f34:	0005883a 	mov	r2,zero
 1200f38:	003f0706 	br	1200b58 <__alt_mem_instruction_tcm+0xff200b58>
 1200f3c:	88c00054 	ori	r3,r17,1
 1200f40:	80c00115 	stw	r3,4(r16)
 1200f44:	8463883a 	add	r17,r16,r17
 1200f48:	10800054 	ori	r2,r2,1
 1200f4c:	9c400215 	stw	r17,8(r19)
 1200f50:	88800115 	stw	r2,4(r17)
 1200f54:	9009883a 	mov	r4,r18
 1200f58:	12037740 	call	1203774 <__malloc_unlock>
 1200f5c:	80800204 	addi	r2,r16,8
 1200f60:	003efd06 	br	1200b58 <__alt_mem_instruction_tcm+0xff200b58>
 1200f64:	00800504 	movi	r2,20
 1200f68:	10c0482e 	bgeu	r2,r3,120108c <_malloc_r+0x5e8>
 1200f6c:	00801504 	movi	r2,84
 1200f70:	10c06836 	bltu	r2,r3,1201114 <_malloc_r+0x670>
 1200f74:	8806d33a 	srli	r3,r17,12
 1200f78:	19c01b84 	addi	r7,r3,110
 1200f7c:	39cb883a 	add	r5,r7,r7
 1200f80:	003f0c06 	br	1200bb4 <__alt_mem_instruction_tcm+0xff200bb4>
 1200f84:	3804d27a 	srli	r2,r7,9
 1200f88:	01000104 	movi	r4,4
 1200f8c:	2080422e 	bgeu	r4,r2,1201098 <_malloc_r+0x5f4>
 1200f90:	01000504 	movi	r4,20
 1200f94:	20807c36 	bltu	r4,r2,1201188 <_malloc_r+0x6e4>
 1200f98:	110016c4 	addi	r4,r2,91
 1200f9c:	210b883a 	add	r5,r4,r4
 1200fa0:	294b883a 	add	r5,r5,r5
 1200fa4:	294b883a 	add	r5,r5,r5
 1200fa8:	994b883a 	add	r5,r19,r5
 1200fac:	28800217 	ldw	r2,8(r5)
 1200fb0:	02004874 	movhi	r8,289
 1200fb4:	42211304 	addi	r8,r8,-31668
 1200fb8:	11406326 	beq	r2,r5,1201148 <_malloc_r+0x6a4>
 1200fbc:	01bfff04 	movi	r6,-4
 1200fc0:	11000117 	ldw	r4,4(r2)
 1200fc4:	2188703a 	and	r4,r4,r6
 1200fc8:	3900022e 	bgeu	r7,r4,1200fd4 <_malloc_r+0x530>
 1200fcc:	10800217 	ldw	r2,8(r2)
 1200fd0:	28bffb1e 	bne	r5,r2,1200fc0 <__alt_mem_instruction_tcm+0xff200fc0>
 1200fd4:	11800317 	ldw	r6,12(r2)
 1200fd8:	99000117 	ldw	r4,4(r19)
 1200fdc:	81800315 	stw	r6,12(r16)
 1200fe0:	80800215 	stw	r2,8(r16)
 1200fe4:	34000215 	stw	r16,8(r6)
 1200fe8:	14000315 	stw	r16,12(r2)
 1200fec:	003f2706 	br	1200c8c <__alt_mem_instruction_tcm+0xff200c8c>
 1200ff0:	88c00054 	ori	r3,r17,1
 1200ff4:	80c00115 	stw	r3,4(r16)
 1200ff8:	8463883a 	add	r17,r16,r17
 1200ffc:	34400515 	stw	r17,20(r6)
 1201000:	34400415 	stw	r17,16(r6)
 1201004:	10c00054 	ori	r3,r2,1
 1201008:	8a400315 	stw	r9,12(r17)
 120100c:	8a400215 	stw	r9,8(r17)
 1201010:	88c00115 	stw	r3,4(r17)
 1201014:	88a3883a 	add	r17,r17,r2
 1201018:	88800015 	stw	r2,0(r17)
 120101c:	9009883a 	mov	r4,r18
 1201020:	12037740 	call	1203774 <__malloc_unlock>
 1201024:	80800204 	addi	r2,r16,8
 1201028:	003ecb06 	br	1200b58 <__alt_mem_instruction_tcm+0xff200b58>
 120102c:	31000117 	ldw	r4,4(r6)
 1201030:	003f1606 	br	1200c8c <__alt_mem_instruction_tcm+0xff200c8c>
 1201034:	63000044 	addi	r12,r12,1
 1201038:	608000cc 	andi	r2,r12,3
 120103c:	5ac00204 	addi	r11,r11,8
 1201040:	103f2a1e 	bne	r2,zero,1200cec <__alt_mem_instruction_tcm+0xff200cec>
 1201044:	00002106 	br	12010cc <_malloc_r+0x628>
 1201048:	80800204 	addi	r2,r16,8
 120104c:	84000517 	ldw	r16,20(r16)
 1201050:	143eb31e 	bne	r2,r16,1200b20 <__alt_mem_instruction_tcm+0xff200b20>
 1201054:	18c00084 	addi	r3,r3,2
 1201058:	003eec06 	br	1200c0c <__alt_mem_instruction_tcm+0xff200c0c>
 120105c:	8085883a 	add	r2,r16,r2
 1201060:	10c00117 	ldw	r3,4(r2)
 1201064:	81000317 	ldw	r4,12(r16)
 1201068:	81400217 	ldw	r5,8(r16)
 120106c:	18c00054 	ori	r3,r3,1
 1201070:	10c00115 	stw	r3,4(r2)
 1201074:	29000315 	stw	r4,12(r5)
 1201078:	21400215 	stw	r5,8(r4)
 120107c:	9009883a 	mov	r4,r18
 1201080:	12037740 	call	1203774 <__malloc_unlock>
 1201084:	80800204 	addi	r2,r16,8
 1201088:	003eb306 	br	1200b58 <__alt_mem_instruction_tcm+0xff200b58>
 120108c:	19c016c4 	addi	r7,r3,91
 1201090:	39cb883a 	add	r5,r7,r7
 1201094:	003ec706 	br	1200bb4 <__alt_mem_instruction_tcm+0xff200bb4>
 1201098:	3804d1ba 	srli	r2,r7,6
 120109c:	11000e04 	addi	r4,r2,56
 12010a0:	210b883a 	add	r5,r4,r4
 12010a4:	003fbe06 	br	1200fa0 <__alt_mem_instruction_tcm+0xff200fa0>
 12010a8:	84ff5d26 	beq	r16,r19,1200e20 <__alt_mem_instruction_tcm+0xff200e20>
 12010ac:	9c000217 	ldw	r16,8(r19)
 12010b0:	00bfff04 	movi	r2,-4
 12010b4:	80c00117 	ldw	r3,4(r16)
 12010b8:	1886703a 	and	r3,r3,r2
 12010bc:	003f9706 	br	1200f1c <__alt_mem_instruction_tcm+0xff200f1c>
 12010c0:	52800017 	ldw	r10,0(r10)
 12010c4:	18ffffc4 	addi	r3,r3,-1
 12010c8:	50805c1e 	bne	r10,r2,120123c <_malloc_r+0x798>
 12010cc:	190000cc 	andi	r4,r3,3
 12010d0:	50bffe04 	addi	r2,r10,-8
 12010d4:	203ffa1e 	bne	r4,zero,12010c0 <__alt_mem_instruction_tcm+0xff2010c0>
 12010d8:	98800117 	ldw	r2,4(r19)
 12010dc:	0146303a 	nor	r3,zero,r5
 12010e0:	1884703a 	and	r2,r3,r2
 12010e4:	98800115 	stw	r2,4(r19)
 12010e8:	294b883a 	add	r5,r5,r5
 12010ec:	117f2e36 	bltu	r2,r5,1200da8 <__alt_mem_instruction_tcm+0xff200da8>
 12010f0:	283f2d26 	beq	r5,zero,1200da8 <__alt_mem_instruction_tcm+0xff200da8>
 12010f4:	1146703a 	and	r3,r2,r5
 12010f8:	1800521e 	bne	r3,zero,1201244 <_malloc_r+0x7a0>
 12010fc:	6007883a 	mov	r3,r12
 1201100:	294b883a 	add	r5,r5,r5
 1201104:	1148703a 	and	r4,r2,r5
 1201108:	18c00104 	addi	r3,r3,4
 120110c:	203ffc26 	beq	r4,zero,1201100 <__alt_mem_instruction_tcm+0xff201100>
 1201110:	003ef006 	br	1200cd4 <__alt_mem_instruction_tcm+0xff200cd4>
 1201114:	00805504 	movi	r2,340
 1201118:	10c01336 	bltu	r2,r3,1201168 <_malloc_r+0x6c4>
 120111c:	8806d3fa 	srli	r3,r17,15
 1201120:	19c01dc4 	addi	r7,r3,119
 1201124:	39cb883a 	add	r5,r7,r7
 1201128:	003ea206 	br	1200bb4 <__alt_mem_instruction_tcm+0xff200bb4>
 120112c:	00c40004 	movi	r3,4096
 1201130:	003f4d06 	br	1200e68 <__alt_mem_instruction_tcm+0xff200e68>
 1201134:	00800044 	movi	r2,1
 1201138:	a0800115 	stw	r2,4(r20)
 120113c:	a021883a 	mov	r16,r20
 1201140:	0007883a 	mov	r3,zero
 1201144:	003f7506 	br	1200f1c <__alt_mem_instruction_tcm+0xff200f1c>
 1201148:	200bd0ba 	srai	r5,r4,2
 120114c:	01800044 	movi	r6,1
 1201150:	41000117 	ldw	r4,4(r8)
 1201154:	314a983a 	sll	r5,r6,r5
 1201158:	100d883a 	mov	r6,r2
 120115c:	2908b03a 	or	r4,r5,r4
 1201160:	41000115 	stw	r4,4(r8)
 1201164:	003f9d06 	br	1200fdc <__alt_mem_instruction_tcm+0xff200fdc>
 1201168:	00815504 	movi	r2,1364
 120116c:	10c01336 	bltu	r2,r3,12011bc <_malloc_r+0x718>
 1201170:	8806d4ba 	srli	r3,r17,18
 1201174:	19c01f04 	addi	r7,r3,124
 1201178:	39cb883a 	add	r5,r7,r7
 120117c:	003e8d06 	br	1200bb4 <__alt_mem_instruction_tcm+0xff200bb4>
 1201180:	ad400404 	addi	r21,r21,16
 1201184:	003f1d06 	br	1200dfc <__alt_mem_instruction_tcm+0xff200dfc>
 1201188:	01001504 	movi	r4,84
 120118c:	20801c36 	bltu	r4,r2,1201200 <_malloc_r+0x75c>
 1201190:	3804d33a 	srli	r2,r7,12
 1201194:	11001b84 	addi	r4,r2,110
 1201198:	210b883a 	add	r5,r4,r4
 120119c:	003f8006 	br	1200fa0 <__alt_mem_instruction_tcm+0xff200fa0>
 12011a0:	3083ffcc 	andi	r2,r6,4095
 12011a4:	103f241e 	bne	r2,zero,1200e38 <__alt_mem_instruction_tcm+0xff200e38>
 12011a8:	99000217 	ldw	r4,8(r19)
 12011ac:	ad85883a 	add	r2,r21,r22
 12011b0:	10800054 	ori	r2,r2,1
 12011b4:	20800115 	stw	r2,4(r4)
 12011b8:	003f4a06 	br	1200ee4 <__alt_mem_instruction_tcm+0xff200ee4>
 12011bc:	01403f04 	movi	r5,252
 12011c0:	01c01f84 	movi	r7,126
 12011c4:	003e7b06 	br	1200bb4 <__alt_mem_instruction_tcm+0xff200bb4>
 12011c8:	00c00044 	movi	r3,1
 12011cc:	002b883a 	mov	r21,zero
 12011d0:	003f3006 	br	1200e94 <__alt_mem_instruction_tcm+0xff200e94>
 12011d4:	00804874 	movhi	r2,289
 12011d8:	10a6d004 	addi	r2,r2,-25792
 12011dc:	15000015 	stw	r20,0(r2)
 12011e0:	003f1b06 	br	1200e50 <__alt_mem_instruction_tcm+0xff200e50>
 12011e4:	9009883a 	mov	r4,r18
 12011e8:	81400204 	addi	r5,r16,8
 12011ec:	12024080 	call	1202408 <_free_r>
 12011f0:	00804874 	movhi	r2,289
 12011f4:	10a6ea04 	addi	r2,r2,-25688
 12011f8:	10c00017 	ldw	r3,0(r2)
 12011fc:	003f3906 	br	1200ee4 <__alt_mem_instruction_tcm+0xff200ee4>
 1201200:	01005504 	movi	r4,340
 1201204:	20800436 	bltu	r4,r2,1201218 <_malloc_r+0x774>
 1201208:	3804d3fa 	srli	r2,r7,15
 120120c:	11001dc4 	addi	r4,r2,119
 1201210:	210b883a 	add	r5,r4,r4
 1201214:	003f6206 	br	1200fa0 <__alt_mem_instruction_tcm+0xff200fa0>
 1201218:	01015504 	movi	r4,1364
 120121c:	20800436 	bltu	r4,r2,1201230 <_malloc_r+0x78c>
 1201220:	3804d4ba 	srli	r2,r7,18
 1201224:	11001f04 	addi	r4,r2,124
 1201228:	210b883a 	add	r5,r4,r4
 120122c:	003f5c06 	br	1200fa0 <__alt_mem_instruction_tcm+0xff200fa0>
 1201230:	01403f04 	movi	r5,252
 1201234:	01001f84 	movi	r4,126
 1201238:	003f5906 	br	1200fa0 <__alt_mem_instruction_tcm+0xff200fa0>
 120123c:	98800117 	ldw	r2,4(r19)
 1201240:	003fa906 	br	12010e8 <__alt_mem_instruction_tcm+0xff2010e8>
 1201244:	6007883a 	mov	r3,r12
 1201248:	003ea206 	br	1200cd4 <__alt_mem_instruction_tcm+0xff200cd4>

0120124c <memchr>:
 120124c:	208000cc 	andi	r2,r4,3
 1201250:	280f883a 	mov	r7,r5
 1201254:	10003526 	beq	r2,zero,120132c <memchr+0xe0>
 1201258:	30bfffc4 	addi	r2,r6,-1
 120125c:	30001b26 	beq	r6,zero,12012cc <memchr+0x80>
 1201260:	21800003 	ldbu	r6,0(r4)
 1201264:	28c03fcc 	andi	r3,r5,255
 1201268:	30c01a26 	beq	r6,r3,12012d4 <memchr+0x88>
 120126c:	180d883a 	mov	r6,r3
 1201270:	00000406 	br	1201284 <memchr+0x38>
 1201274:	10001526 	beq	r2,zero,12012cc <memchr+0x80>
 1201278:	20c00003 	ldbu	r3,0(r4)
 120127c:	10bfffc4 	addi	r2,r2,-1
 1201280:	19801426 	beq	r3,r6,12012d4 <memchr+0x88>
 1201284:	21000044 	addi	r4,r4,1
 1201288:	20c000cc 	andi	r3,r4,3
 120128c:	183ff91e 	bne	r3,zero,1201274 <__alt_mem_instruction_tcm+0xff201274>
 1201290:	024000c4 	movi	r9,3
 1201294:	48801136 	bltu	r9,r2,12012dc <memchr+0x90>
 1201298:	10000c26 	beq	r2,zero,12012cc <memchr+0x80>
 120129c:	20c00003 	ldbu	r3,0(r4)
 12012a0:	29403fcc 	andi	r5,r5,255
 12012a4:	19400b26 	beq	r3,r5,12012d4 <memchr+0x88>
 12012a8:	20c00044 	addi	r3,r4,1
 12012ac:	2085883a 	add	r2,r4,r2
 12012b0:	39803fcc 	andi	r6,r7,255
 12012b4:	00000306 	br	12012c4 <memchr+0x78>
 12012b8:	18c00044 	addi	r3,r3,1
 12012bc:	197fffc3 	ldbu	r5,-1(r3)
 12012c0:	29800426 	beq	r5,r6,12012d4 <memchr+0x88>
 12012c4:	1809883a 	mov	r4,r3
 12012c8:	18bffb1e 	bne	r3,r2,12012b8 <__alt_mem_instruction_tcm+0xff2012b8>
 12012cc:	0005883a 	mov	r2,zero
 12012d0:	f800283a 	ret
 12012d4:	2005883a 	mov	r2,r4
 12012d8:	f800283a 	ret
 12012dc:	28c03fcc 	andi	r3,r5,255
 12012e0:	1810923a 	slli	r8,r3,8
 12012e4:	02ffbff4 	movhi	r11,65279
 12012e8:	02a02074 	movhi	r10,32897
 12012ec:	40c6b03a 	or	r3,r8,r3
 12012f0:	1810943a 	slli	r8,r3,16
 12012f4:	5affbfc4 	addi	r11,r11,-257
 12012f8:	52a02004 	addi	r10,r10,-32640
 12012fc:	40d0b03a 	or	r8,r8,r3
 1201300:	20c00017 	ldw	r3,0(r4)
 1201304:	40c6f03a 	xor	r3,r8,r3
 1201308:	1acd883a 	add	r6,r3,r11
 120130c:	00c6303a 	nor	r3,zero,r3
 1201310:	30c6703a 	and	r3,r6,r3
 1201314:	1a86703a 	and	r3,r3,r10
 1201318:	183fdf1e 	bne	r3,zero,1201298 <__alt_mem_instruction_tcm+0xff201298>
 120131c:	10bfff04 	addi	r2,r2,-4
 1201320:	21000104 	addi	r4,r4,4
 1201324:	48bff636 	bltu	r9,r2,1201300 <__alt_mem_instruction_tcm+0xff201300>
 1201328:	003fdb06 	br	1201298 <__alt_mem_instruction_tcm+0xff201298>
 120132c:	3005883a 	mov	r2,r6
 1201330:	003fd706 	br	1201290 <__alt_mem_instruction_tcm+0xff201290>

01201334 <memcpy>:
 1201334:	deffff04 	addi	sp,sp,-4
 1201338:	dc000015 	stw	r16,0(sp)
 120133c:	00c003c4 	movi	r3,15
 1201340:	2005883a 	mov	r2,r4
 1201344:	1980432e 	bgeu	r3,r6,1201454 <memcpy+0x120>
 1201348:	2146b03a 	or	r3,r4,r5
 120134c:	18c000cc 	andi	r3,r3,3
 1201350:	1800421e 	bne	r3,zero,120145c <memcpy+0x128>
 1201354:	343ffc04 	addi	r16,r6,-16
 1201358:	8020d13a 	srli	r16,r16,4
 120135c:	28c00104 	addi	r3,r5,4
 1201360:	23400104 	addi	r13,r4,4
 1201364:	801e913a 	slli	r15,r16,4
 1201368:	2b000204 	addi	r12,r5,8
 120136c:	22c00204 	addi	r11,r4,8
 1201370:	7bc00504 	addi	r15,r15,20
 1201374:	2a800304 	addi	r10,r5,12
 1201378:	22400304 	addi	r9,r4,12
 120137c:	2bdf883a 	add	r15,r5,r15
 1201380:	2811883a 	mov	r8,r5
 1201384:	200f883a 	mov	r7,r4
 1201388:	41000017 	ldw	r4,0(r8)
 120138c:	39c00404 	addi	r7,r7,16
 1201390:	18c00404 	addi	r3,r3,16
 1201394:	393ffc15 	stw	r4,-16(r7)
 1201398:	1bbffc17 	ldw	r14,-16(r3)
 120139c:	6b400404 	addi	r13,r13,16
 12013a0:	5ac00404 	addi	r11,r11,16
 12013a4:	6bbffc15 	stw	r14,-16(r13)
 12013a8:	63800017 	ldw	r14,0(r12)
 12013ac:	4a400404 	addi	r9,r9,16
 12013b0:	42000404 	addi	r8,r8,16
 12013b4:	5bbffc15 	stw	r14,-16(r11)
 12013b8:	53800017 	ldw	r14,0(r10)
 12013bc:	63000404 	addi	r12,r12,16
 12013c0:	52800404 	addi	r10,r10,16
 12013c4:	4bbffc15 	stw	r14,-16(r9)
 12013c8:	1bffef1e 	bne	r3,r15,1201388 <__alt_mem_instruction_tcm+0xff201388>
 12013cc:	81c00044 	addi	r7,r16,1
 12013d0:	380e913a 	slli	r7,r7,4
 12013d4:	310003cc 	andi	r4,r6,15
 12013d8:	02c000c4 	movi	r11,3
 12013dc:	11c7883a 	add	r3,r2,r7
 12013e0:	29cb883a 	add	r5,r5,r7
 12013e4:	59001f2e 	bgeu	r11,r4,1201464 <memcpy+0x130>
 12013e8:	1813883a 	mov	r9,r3
 12013ec:	2811883a 	mov	r8,r5
 12013f0:	200f883a 	mov	r7,r4
 12013f4:	42800017 	ldw	r10,0(r8)
 12013f8:	4a400104 	addi	r9,r9,4
 12013fc:	39ffff04 	addi	r7,r7,-4
 1201400:	4abfff15 	stw	r10,-4(r9)
 1201404:	42000104 	addi	r8,r8,4
 1201408:	59fffa36 	bltu	r11,r7,12013f4 <__alt_mem_instruction_tcm+0xff2013f4>
 120140c:	213fff04 	addi	r4,r4,-4
 1201410:	2008d0ba 	srli	r4,r4,2
 1201414:	318000cc 	andi	r6,r6,3
 1201418:	21000044 	addi	r4,r4,1
 120141c:	2109883a 	add	r4,r4,r4
 1201420:	2109883a 	add	r4,r4,r4
 1201424:	1907883a 	add	r3,r3,r4
 1201428:	290b883a 	add	r5,r5,r4
 120142c:	30000626 	beq	r6,zero,1201448 <memcpy+0x114>
 1201430:	198d883a 	add	r6,r3,r6
 1201434:	29c00003 	ldbu	r7,0(r5)
 1201438:	18c00044 	addi	r3,r3,1
 120143c:	29400044 	addi	r5,r5,1
 1201440:	19ffffc5 	stb	r7,-1(r3)
 1201444:	19bffb1e 	bne	r3,r6,1201434 <__alt_mem_instruction_tcm+0xff201434>
 1201448:	dc000017 	ldw	r16,0(sp)
 120144c:	dec00104 	addi	sp,sp,4
 1201450:	f800283a 	ret
 1201454:	2007883a 	mov	r3,r4
 1201458:	003ff406 	br	120142c <__alt_mem_instruction_tcm+0xff20142c>
 120145c:	2007883a 	mov	r3,r4
 1201460:	003ff306 	br	1201430 <__alt_mem_instruction_tcm+0xff201430>
 1201464:	200d883a 	mov	r6,r4
 1201468:	003ff006 	br	120142c <__alt_mem_instruction_tcm+0xff20142c>

0120146c <memmove>:
 120146c:	2005883a 	mov	r2,r4
 1201470:	29000b2e 	bgeu	r5,r4,12014a0 <memmove+0x34>
 1201474:	298f883a 	add	r7,r5,r6
 1201478:	21c0092e 	bgeu	r4,r7,12014a0 <memmove+0x34>
 120147c:	2187883a 	add	r3,r4,r6
 1201480:	198bc83a 	sub	r5,r3,r6
 1201484:	30004b26 	beq	r6,zero,12015b4 <memmove+0x148>
 1201488:	39ffffc4 	addi	r7,r7,-1
 120148c:	39000003 	ldbu	r4,0(r7)
 1201490:	18ffffc4 	addi	r3,r3,-1
 1201494:	19000005 	stb	r4,0(r3)
 1201498:	197ffb1e 	bne	r3,r5,1201488 <__alt_mem_instruction_tcm+0xff201488>
 120149c:	f800283a 	ret
 12014a0:	00c003c4 	movi	r3,15
 12014a4:	1980412e 	bgeu	r3,r6,12015ac <memmove+0x140>
 12014a8:	1146b03a 	or	r3,r2,r5
 12014ac:	18c000cc 	andi	r3,r3,3
 12014b0:	1800411e 	bne	r3,zero,12015b8 <memmove+0x14c>
 12014b4:	33fffc04 	addi	r15,r6,-16
 12014b8:	781ed13a 	srli	r15,r15,4
 12014bc:	28c00104 	addi	r3,r5,4
 12014c0:	13400104 	addi	r13,r2,4
 12014c4:	781c913a 	slli	r14,r15,4
 12014c8:	2b000204 	addi	r12,r5,8
 12014cc:	12c00204 	addi	r11,r2,8
 12014d0:	73800504 	addi	r14,r14,20
 12014d4:	2a800304 	addi	r10,r5,12
 12014d8:	12400304 	addi	r9,r2,12
 12014dc:	2b9d883a 	add	r14,r5,r14
 12014e0:	2811883a 	mov	r8,r5
 12014e4:	100f883a 	mov	r7,r2
 12014e8:	41000017 	ldw	r4,0(r8)
 12014ec:	39c00404 	addi	r7,r7,16
 12014f0:	18c00404 	addi	r3,r3,16
 12014f4:	393ffc15 	stw	r4,-16(r7)
 12014f8:	193ffc17 	ldw	r4,-16(r3)
 12014fc:	6b400404 	addi	r13,r13,16
 1201500:	5ac00404 	addi	r11,r11,16
 1201504:	693ffc15 	stw	r4,-16(r13)
 1201508:	61000017 	ldw	r4,0(r12)
 120150c:	4a400404 	addi	r9,r9,16
 1201510:	42000404 	addi	r8,r8,16
 1201514:	593ffc15 	stw	r4,-16(r11)
 1201518:	51000017 	ldw	r4,0(r10)
 120151c:	63000404 	addi	r12,r12,16
 1201520:	52800404 	addi	r10,r10,16
 1201524:	493ffc15 	stw	r4,-16(r9)
 1201528:	1bbfef1e 	bne	r3,r14,12014e8 <__alt_mem_instruction_tcm+0xff2014e8>
 120152c:	79000044 	addi	r4,r15,1
 1201530:	2008913a 	slli	r4,r4,4
 1201534:	328003cc 	andi	r10,r6,15
 1201538:	02c000c4 	movi	r11,3
 120153c:	1107883a 	add	r3,r2,r4
 1201540:	290b883a 	add	r5,r5,r4
 1201544:	5a801e2e 	bgeu	r11,r10,12015c0 <memmove+0x154>
 1201548:	1813883a 	mov	r9,r3
 120154c:	2811883a 	mov	r8,r5
 1201550:	500f883a 	mov	r7,r10
 1201554:	41000017 	ldw	r4,0(r8)
 1201558:	4a400104 	addi	r9,r9,4
 120155c:	39ffff04 	addi	r7,r7,-4
 1201560:	493fff15 	stw	r4,-4(r9)
 1201564:	42000104 	addi	r8,r8,4
 1201568:	59fffa36 	bltu	r11,r7,1201554 <__alt_mem_instruction_tcm+0xff201554>
 120156c:	513fff04 	addi	r4,r10,-4
 1201570:	2008d0ba 	srli	r4,r4,2
 1201574:	318000cc 	andi	r6,r6,3
 1201578:	21000044 	addi	r4,r4,1
 120157c:	2109883a 	add	r4,r4,r4
 1201580:	2109883a 	add	r4,r4,r4
 1201584:	1907883a 	add	r3,r3,r4
 1201588:	290b883a 	add	r5,r5,r4
 120158c:	30000926 	beq	r6,zero,12015b4 <memmove+0x148>
 1201590:	198d883a 	add	r6,r3,r6
 1201594:	29c00003 	ldbu	r7,0(r5)
 1201598:	18c00044 	addi	r3,r3,1
 120159c:	29400044 	addi	r5,r5,1
 12015a0:	19ffffc5 	stb	r7,-1(r3)
 12015a4:	19bffb1e 	bne	r3,r6,1201594 <__alt_mem_instruction_tcm+0xff201594>
 12015a8:	f800283a 	ret
 12015ac:	1007883a 	mov	r3,r2
 12015b0:	003ff606 	br	120158c <__alt_mem_instruction_tcm+0xff20158c>
 12015b4:	f800283a 	ret
 12015b8:	1007883a 	mov	r3,r2
 12015bc:	003ff406 	br	1201590 <__alt_mem_instruction_tcm+0xff201590>
 12015c0:	500d883a 	mov	r6,r10
 12015c4:	003ff106 	br	120158c <__alt_mem_instruction_tcm+0xff20158c>

012015c8 <_realloc_r>:
 12015c8:	defff604 	addi	sp,sp,-40
 12015cc:	dcc00315 	stw	r19,12(sp)
 12015d0:	dc400115 	stw	r17,4(sp)
 12015d4:	dfc00915 	stw	ra,36(sp)
 12015d8:	df000815 	stw	fp,32(sp)
 12015dc:	ddc00715 	stw	r23,28(sp)
 12015e0:	dd800615 	stw	r22,24(sp)
 12015e4:	dd400515 	stw	r21,20(sp)
 12015e8:	dd000415 	stw	r20,16(sp)
 12015ec:	dc800215 	stw	r18,8(sp)
 12015f0:	dc000015 	stw	r16,0(sp)
 12015f4:	2827883a 	mov	r19,r5
 12015f8:	3023883a 	mov	r17,r6
 12015fc:	2800bf26 	beq	r5,zero,12018fc <_realloc_r+0x334>
 1201600:	2025883a 	mov	r18,r4
 1201604:	12037540 	call	1203754 <__malloc_lock>
 1201608:	98ffff17 	ldw	r3,-4(r19)
 120160c:	01bfff04 	movi	r6,-4
 1201610:	890002c4 	addi	r4,r17,11
 1201614:	01c00584 	movi	r7,22
 1201618:	9d7ffe04 	addi	r21,r19,-8
 120161c:	19a0703a 	and	r16,r3,r6
 1201620:	39003f2e 	bgeu	r7,r4,1201720 <_realloc_r+0x158>
 1201624:	053ffe04 	movi	r20,-8
 1201628:	2528703a 	and	r20,r4,r20
 120162c:	a00f883a 	mov	r7,r20
 1201630:	a0008216 	blt	r20,zero,120183c <_realloc_r+0x274>
 1201634:	a4408136 	bltu	r20,r17,120183c <_realloc_r+0x274>
 1201638:	81c03c0e 	bge	r16,r7,120172c <_realloc_r+0x164>
 120163c:	07004874 	movhi	fp,289
 1201640:	e7211304 	addi	fp,fp,-31668
 1201644:	e1000217 	ldw	r4,8(fp)
 1201648:	ac05883a 	add	r2,r21,r16
 120164c:	2080bf26 	beq	r4,r2,120194c <_realloc_r+0x384>
 1201650:	11000117 	ldw	r4,4(r2)
 1201654:	023fff84 	movi	r8,-2
 1201658:	2210703a 	and	r8,r4,r8
 120165c:	1211883a 	add	r8,r2,r8
 1201660:	41400117 	ldw	r5,4(r8)
 1201664:	2940004c 	andi	r5,r5,1
 1201668:	28004a1e 	bne	r5,zero,1201794 <_realloc_r+0x1cc>
 120166c:	017fff04 	movi	r5,-4
 1201670:	2148703a 	and	r4,r4,r5
 1201674:	2409883a 	add	r4,r4,r16
 1201678:	21c0ad0e 	bge	r4,r7,1201930 <_realloc_r+0x368>
 120167c:	18c0004c 	andi	r3,r3,1
 1201680:	18007f1e 	bne	r3,zero,1201880 <_realloc_r+0x2b8>
 1201684:	9dfffe17 	ldw	r23,-8(r19)
 1201688:	adefc83a 	sub	r23,r21,r23
 120168c:	bd800117 	ldw	r22,4(r23)
 1201690:	b14a703a 	and	r5,r22,r5
 1201694:	216d883a 	add	r22,r4,r5
 1201698:	b1c04516 	blt	r22,r7,12017b0 <_realloc_r+0x1e8>
 120169c:	10c00317 	ldw	r3,12(r2)
 12016a0:	10800217 	ldw	r2,8(r2)
 12016a4:	81bfff04 	addi	r6,r16,-4
 12016a8:	bc400204 	addi	r17,r23,8
 12016ac:	10c00315 	stw	r3,12(r2)
 12016b0:	18800215 	stw	r2,8(r3)
 12016b4:	b9400217 	ldw	r5,8(r23)
 12016b8:	b8c00317 	ldw	r3,12(r23)
 12016bc:	00800904 	movi	r2,36
 12016c0:	28c00315 	stw	r3,12(r5)
 12016c4:	19400215 	stw	r5,8(r3)
 12016c8:	1180ef36 	bltu	r2,r6,1201a88 <_realloc_r+0x4c0>
 12016cc:	008004c4 	movi	r2,19
 12016d0:	1180da2e 	bgeu	r2,r6,1201a3c <_realloc_r+0x474>
 12016d4:	98800017 	ldw	r2,0(r19)
 12016d8:	b8800215 	stw	r2,8(r23)
 12016dc:	98800117 	ldw	r2,4(r19)
 12016e0:	b8800315 	stw	r2,12(r23)
 12016e4:	008006c4 	movi	r2,27
 12016e8:	1180fc2e 	bgeu	r2,r6,1201adc <_realloc_r+0x514>
 12016ec:	98800217 	ldw	r2,8(r19)
 12016f0:	b8800415 	stw	r2,16(r23)
 12016f4:	98800317 	ldw	r2,12(r19)
 12016f8:	b8800515 	stw	r2,20(r23)
 12016fc:	00800904 	movi	r2,36
 1201700:	3080421e 	bne	r6,r2,120180c <_realloc_r+0x244>
 1201704:	98800417 	ldw	r2,16(r19)
 1201708:	9cc00604 	addi	r19,r19,24
 120170c:	b8c00804 	addi	r3,r23,32
 1201710:	b8800615 	stw	r2,24(r23)
 1201714:	98bfff17 	ldw	r2,-4(r19)
 1201718:	b8800715 	stw	r2,28(r23)
 120171c:	00003d06 	br	1201814 <_realloc_r+0x24c>
 1201720:	01c00404 	movi	r7,16
 1201724:	3829883a 	mov	r20,r7
 1201728:	003fc206 	br	1201634 <__alt_mem_instruction_tcm+0xff201634>
 120172c:	9823883a 	mov	r17,r19
 1201730:	850fc83a 	sub	r7,r16,r20
 1201734:	008003c4 	movi	r2,15
 1201738:	18c0004c 	andi	r3,r3,1
 120173c:	11c04336 	bltu	r2,r7,120184c <_realloc_r+0x284>
 1201740:	1c06b03a 	or	r3,r3,r16
 1201744:	a8c00115 	stw	r3,4(r21)
 1201748:	ac21883a 	add	r16,r21,r16
 120174c:	80c00117 	ldw	r3,4(r16)
 1201750:	18c00054 	ori	r3,r3,1
 1201754:	80c00115 	stw	r3,4(r16)
 1201758:	9009883a 	mov	r4,r18
 120175c:	12037740 	call	1203774 <__malloc_unlock>
 1201760:	8805883a 	mov	r2,r17
 1201764:	dfc00917 	ldw	ra,36(sp)
 1201768:	df000817 	ldw	fp,32(sp)
 120176c:	ddc00717 	ldw	r23,28(sp)
 1201770:	dd800617 	ldw	r22,24(sp)
 1201774:	dd400517 	ldw	r21,20(sp)
 1201778:	dd000417 	ldw	r20,16(sp)
 120177c:	dcc00317 	ldw	r19,12(sp)
 1201780:	dc800217 	ldw	r18,8(sp)
 1201784:	dc400117 	ldw	r17,4(sp)
 1201788:	dc000017 	ldw	r16,0(sp)
 120178c:	dec00a04 	addi	sp,sp,40
 1201790:	f800283a 	ret
 1201794:	18c0004c 	andi	r3,r3,1
 1201798:	1800391e 	bne	r3,zero,1201880 <_realloc_r+0x2b8>
 120179c:	9dfffe17 	ldw	r23,-8(r19)
 12017a0:	00bfff04 	movi	r2,-4
 12017a4:	adefc83a 	sub	r23,r21,r23
 12017a8:	b9400117 	ldw	r5,4(r23)
 12017ac:	288a703a 	and	r5,r5,r2
 12017b0:	2c2d883a 	add	r22,r5,r16
 12017b4:	b1c03216 	blt	r22,r7,1201880 <_realloc_r+0x2b8>
 12017b8:	b8800317 	ldw	r2,12(r23)
 12017bc:	b8c00217 	ldw	r3,8(r23)
 12017c0:	81bfff04 	addi	r6,r16,-4
 12017c4:	01000904 	movi	r4,36
 12017c8:	18800315 	stw	r2,12(r3)
 12017cc:	10c00215 	stw	r3,8(r2)
 12017d0:	bc400204 	addi	r17,r23,8
 12017d4:	2180ac36 	bltu	r4,r6,1201a88 <_realloc_r+0x4c0>
 12017d8:	008004c4 	movi	r2,19
 12017dc:	1180972e 	bgeu	r2,r6,1201a3c <_realloc_r+0x474>
 12017e0:	98800017 	ldw	r2,0(r19)
 12017e4:	b8800215 	stw	r2,8(r23)
 12017e8:	98800117 	ldw	r2,4(r19)
 12017ec:	b8800315 	stw	r2,12(r23)
 12017f0:	008006c4 	movi	r2,27
 12017f4:	1180b92e 	bgeu	r2,r6,1201adc <_realloc_r+0x514>
 12017f8:	98800217 	ldw	r2,8(r19)
 12017fc:	b8800415 	stw	r2,16(r23)
 1201800:	98800317 	ldw	r2,12(r19)
 1201804:	b8800515 	stw	r2,20(r23)
 1201808:	313fbe26 	beq	r6,r4,1201704 <__alt_mem_instruction_tcm+0xff201704>
 120180c:	b8c00604 	addi	r3,r23,24
 1201810:	9cc00404 	addi	r19,r19,16
 1201814:	98800017 	ldw	r2,0(r19)
 1201818:	b021883a 	mov	r16,r22
 120181c:	b82b883a 	mov	r21,r23
 1201820:	18800015 	stw	r2,0(r3)
 1201824:	98800117 	ldw	r2,4(r19)
 1201828:	18800115 	stw	r2,4(r3)
 120182c:	98800217 	ldw	r2,8(r19)
 1201830:	18800215 	stw	r2,8(r3)
 1201834:	b8c00117 	ldw	r3,4(r23)
 1201838:	003fbd06 	br	1201730 <__alt_mem_instruction_tcm+0xff201730>
 120183c:	00800304 	movi	r2,12
 1201840:	90800015 	stw	r2,0(r18)
 1201844:	0005883a 	mov	r2,zero
 1201848:	003fc606 	br	1201764 <__alt_mem_instruction_tcm+0xff201764>
 120184c:	1d06b03a 	or	r3,r3,r20
 1201850:	ad0b883a 	add	r5,r21,r20
 1201854:	a8c00115 	stw	r3,4(r21)
 1201858:	38800054 	ori	r2,r7,1
 120185c:	28800115 	stw	r2,4(r5)
 1201860:	29cf883a 	add	r7,r5,r7
 1201864:	38800117 	ldw	r2,4(r7)
 1201868:	9009883a 	mov	r4,r18
 120186c:	29400204 	addi	r5,r5,8
 1201870:	10800054 	ori	r2,r2,1
 1201874:	38800115 	stw	r2,4(r7)
 1201878:	12024080 	call	1202408 <_free_r>
 120187c:	003fb606 	br	1201758 <__alt_mem_instruction_tcm+0xff201758>
 1201880:	880b883a 	mov	r5,r17
 1201884:	9009883a 	mov	r4,r18
 1201888:	1200aa40 	call	1200aa4 <_malloc_r>
 120188c:	1023883a 	mov	r17,r2
 1201890:	1000aa26 	beq	r2,zero,1201b3c <_realloc_r+0x574>
 1201894:	98ffff17 	ldw	r3,-4(r19)
 1201898:	113ffe04 	addi	r4,r2,-8
 120189c:	00bfff84 	movi	r2,-2
 12018a0:	1884703a 	and	r2,r3,r2
 12018a4:	a885883a 	add	r2,r21,r2
 12018a8:	20808626 	beq	r4,r2,1201ac4 <_realloc_r+0x4fc>
 12018ac:	81bfff04 	addi	r6,r16,-4
 12018b0:	00800904 	movi	r2,36
 12018b4:	11807036 	bltu	r2,r6,1201a78 <_realloc_r+0x4b0>
 12018b8:	00c004c4 	movi	r3,19
 12018bc:	19805636 	bltu	r3,r6,1201a18 <_realloc_r+0x450>
 12018c0:	8805883a 	mov	r2,r17
 12018c4:	9807883a 	mov	r3,r19
 12018c8:	19000017 	ldw	r4,0(r3)
 12018cc:	11000015 	stw	r4,0(r2)
 12018d0:	19000117 	ldw	r4,4(r3)
 12018d4:	11000115 	stw	r4,4(r2)
 12018d8:	18c00217 	ldw	r3,8(r3)
 12018dc:	10c00215 	stw	r3,8(r2)
 12018e0:	980b883a 	mov	r5,r19
 12018e4:	9009883a 	mov	r4,r18
 12018e8:	12024080 	call	1202408 <_free_r>
 12018ec:	9009883a 	mov	r4,r18
 12018f0:	12037740 	call	1203774 <__malloc_unlock>
 12018f4:	8805883a 	mov	r2,r17
 12018f8:	003f9a06 	br	1201764 <__alt_mem_instruction_tcm+0xff201764>
 12018fc:	300b883a 	mov	r5,r6
 1201900:	dfc00917 	ldw	ra,36(sp)
 1201904:	df000817 	ldw	fp,32(sp)
 1201908:	ddc00717 	ldw	r23,28(sp)
 120190c:	dd800617 	ldw	r22,24(sp)
 1201910:	dd400517 	ldw	r21,20(sp)
 1201914:	dd000417 	ldw	r20,16(sp)
 1201918:	dcc00317 	ldw	r19,12(sp)
 120191c:	dc800217 	ldw	r18,8(sp)
 1201920:	dc400117 	ldw	r17,4(sp)
 1201924:	dc000017 	ldw	r16,0(sp)
 1201928:	dec00a04 	addi	sp,sp,40
 120192c:	1200aa41 	jmpi	1200aa4 <_malloc_r>
 1201930:	11400317 	ldw	r5,12(r2)
 1201934:	10800217 	ldw	r2,8(r2)
 1201938:	9823883a 	mov	r17,r19
 120193c:	2021883a 	mov	r16,r4
 1201940:	11400315 	stw	r5,12(r2)
 1201944:	28800215 	stw	r2,8(r5)
 1201948:	003f7906 	br	1201730 <__alt_mem_instruction_tcm+0xff201730>
 120194c:	21000117 	ldw	r4,4(r4)
 1201950:	00bfff04 	movi	r2,-4
 1201954:	a1800404 	addi	r6,r20,16
 1201958:	2088703a 	and	r4,r4,r2
 120195c:	2409883a 	add	r4,r4,r16
 1201960:	2180380e 	bge	r4,r6,1201a44 <_realloc_r+0x47c>
 1201964:	18c0004c 	andi	r3,r3,1
 1201968:	183fc51e 	bne	r3,zero,1201880 <__alt_mem_instruction_tcm+0xff201880>
 120196c:	9dfffe17 	ldw	r23,-8(r19)
 1201970:	adefc83a 	sub	r23,r21,r23
 1201974:	b9400117 	ldw	r5,4(r23)
 1201978:	288a703a 	and	r5,r5,r2
 120197c:	216d883a 	add	r22,r4,r5
 1201980:	b1bf8b16 	blt	r22,r6,12017b0 <__alt_mem_instruction_tcm+0xff2017b0>
 1201984:	b8800317 	ldw	r2,12(r23)
 1201988:	b8c00217 	ldw	r3,8(r23)
 120198c:	81bfff04 	addi	r6,r16,-4
 1201990:	01000904 	movi	r4,36
 1201994:	18800315 	stw	r2,12(r3)
 1201998:	10c00215 	stw	r3,8(r2)
 120199c:	bc400204 	addi	r17,r23,8
 12019a0:	21805a36 	bltu	r4,r6,1201b0c <_realloc_r+0x544>
 12019a4:	008004c4 	movi	r2,19
 12019a8:	1180562e 	bgeu	r2,r6,1201b04 <_realloc_r+0x53c>
 12019ac:	98800017 	ldw	r2,0(r19)
 12019b0:	b8800215 	stw	r2,8(r23)
 12019b4:	98800117 	ldw	r2,4(r19)
 12019b8:	b8800315 	stw	r2,12(r23)
 12019bc:	008006c4 	movi	r2,27
 12019c0:	11805636 	bltu	r2,r6,1201b1c <_realloc_r+0x554>
 12019c4:	b8800404 	addi	r2,r23,16
 12019c8:	9cc00204 	addi	r19,r19,8
 12019cc:	98c00017 	ldw	r3,0(r19)
 12019d0:	10c00015 	stw	r3,0(r2)
 12019d4:	98c00117 	ldw	r3,4(r19)
 12019d8:	10c00115 	stw	r3,4(r2)
 12019dc:	98c00217 	ldw	r3,8(r19)
 12019e0:	10c00215 	stw	r3,8(r2)
 12019e4:	bd07883a 	add	r3,r23,r20
 12019e8:	b505c83a 	sub	r2,r22,r20
 12019ec:	e0c00215 	stw	r3,8(fp)
 12019f0:	10800054 	ori	r2,r2,1
 12019f4:	18800115 	stw	r2,4(r3)
 12019f8:	b8800117 	ldw	r2,4(r23)
 12019fc:	9009883a 	mov	r4,r18
 1201a00:	1080004c 	andi	r2,r2,1
 1201a04:	a0a8b03a 	or	r20,r20,r2
 1201a08:	bd000115 	stw	r20,4(r23)
 1201a0c:	12037740 	call	1203774 <__malloc_unlock>
 1201a10:	8805883a 	mov	r2,r17
 1201a14:	003f5306 	br	1201764 <__alt_mem_instruction_tcm+0xff201764>
 1201a18:	98c00017 	ldw	r3,0(r19)
 1201a1c:	88c00015 	stw	r3,0(r17)
 1201a20:	98c00117 	ldw	r3,4(r19)
 1201a24:	88c00115 	stw	r3,4(r17)
 1201a28:	00c006c4 	movi	r3,27
 1201a2c:	19801d36 	bltu	r3,r6,1201aa4 <_realloc_r+0x4dc>
 1201a30:	88800204 	addi	r2,r17,8
 1201a34:	98c00204 	addi	r3,r19,8
 1201a38:	003fa306 	br	12018c8 <__alt_mem_instruction_tcm+0xff2018c8>
 1201a3c:	8807883a 	mov	r3,r17
 1201a40:	003f7406 	br	1201814 <__alt_mem_instruction_tcm+0xff201814>
 1201a44:	ad2b883a 	add	r21,r21,r20
 1201a48:	2505c83a 	sub	r2,r4,r20
 1201a4c:	e5400215 	stw	r21,8(fp)
 1201a50:	10800054 	ori	r2,r2,1
 1201a54:	a8800115 	stw	r2,4(r21)
 1201a58:	98bfff17 	ldw	r2,-4(r19)
 1201a5c:	9009883a 	mov	r4,r18
 1201a60:	1080004c 	andi	r2,r2,1
 1201a64:	a0a8b03a 	or	r20,r20,r2
 1201a68:	9d3fff15 	stw	r20,-4(r19)
 1201a6c:	12037740 	call	1203774 <__malloc_unlock>
 1201a70:	9805883a 	mov	r2,r19
 1201a74:	003f3b06 	br	1201764 <__alt_mem_instruction_tcm+0xff201764>
 1201a78:	8809883a 	mov	r4,r17
 1201a7c:	980b883a 	mov	r5,r19
 1201a80:	120146c0 	call	120146c <memmove>
 1201a84:	003f9606 	br	12018e0 <__alt_mem_instruction_tcm+0xff2018e0>
 1201a88:	8809883a 	mov	r4,r17
 1201a8c:	980b883a 	mov	r5,r19
 1201a90:	120146c0 	call	120146c <memmove>
 1201a94:	b8c00117 	ldw	r3,4(r23)
 1201a98:	b021883a 	mov	r16,r22
 1201a9c:	b82b883a 	mov	r21,r23
 1201aa0:	003f2306 	br	1201730 <__alt_mem_instruction_tcm+0xff201730>
 1201aa4:	98c00217 	ldw	r3,8(r19)
 1201aa8:	88c00215 	stw	r3,8(r17)
 1201aac:	98c00317 	ldw	r3,12(r19)
 1201ab0:	88c00315 	stw	r3,12(r17)
 1201ab4:	30800c26 	beq	r6,r2,1201ae8 <_realloc_r+0x520>
 1201ab8:	88800404 	addi	r2,r17,16
 1201abc:	98c00404 	addi	r3,r19,16
 1201ac0:	003f8106 	br	12018c8 <__alt_mem_instruction_tcm+0xff2018c8>
 1201ac4:	893fff17 	ldw	r4,-4(r17)
 1201ac8:	00bfff04 	movi	r2,-4
 1201acc:	9823883a 	mov	r17,r19
 1201ad0:	2084703a 	and	r2,r4,r2
 1201ad4:	80a1883a 	add	r16,r16,r2
 1201ad8:	003f1506 	br	1201730 <__alt_mem_instruction_tcm+0xff201730>
 1201adc:	b8c00404 	addi	r3,r23,16
 1201ae0:	9cc00204 	addi	r19,r19,8
 1201ae4:	003f4b06 	br	1201814 <__alt_mem_instruction_tcm+0xff201814>
 1201ae8:	99000417 	ldw	r4,16(r19)
 1201aec:	88800604 	addi	r2,r17,24
 1201af0:	98c00604 	addi	r3,r19,24
 1201af4:	89000415 	stw	r4,16(r17)
 1201af8:	99000517 	ldw	r4,20(r19)
 1201afc:	89000515 	stw	r4,20(r17)
 1201b00:	003f7106 	br	12018c8 <__alt_mem_instruction_tcm+0xff2018c8>
 1201b04:	8805883a 	mov	r2,r17
 1201b08:	003fb006 	br	12019cc <__alt_mem_instruction_tcm+0xff2019cc>
 1201b0c:	8809883a 	mov	r4,r17
 1201b10:	980b883a 	mov	r5,r19
 1201b14:	120146c0 	call	120146c <memmove>
 1201b18:	003fb206 	br	12019e4 <__alt_mem_instruction_tcm+0xff2019e4>
 1201b1c:	98800217 	ldw	r2,8(r19)
 1201b20:	b8800415 	stw	r2,16(r23)
 1201b24:	98800317 	ldw	r2,12(r19)
 1201b28:	b8800515 	stw	r2,20(r23)
 1201b2c:	31000726 	beq	r6,r4,1201b4c <_realloc_r+0x584>
 1201b30:	b8800604 	addi	r2,r23,24
 1201b34:	9cc00404 	addi	r19,r19,16
 1201b38:	003fa406 	br	12019cc <__alt_mem_instruction_tcm+0xff2019cc>
 1201b3c:	9009883a 	mov	r4,r18
 1201b40:	12037740 	call	1203774 <__malloc_unlock>
 1201b44:	0005883a 	mov	r2,zero
 1201b48:	003f0606 	br	1201764 <__alt_mem_instruction_tcm+0xff201764>
 1201b4c:	98c00417 	ldw	r3,16(r19)
 1201b50:	9cc00604 	addi	r19,r19,24
 1201b54:	b8800804 	addi	r2,r23,32
 1201b58:	b8c00615 	stw	r3,24(r23)
 1201b5c:	98ffff17 	ldw	r3,-4(r19)
 1201b60:	b8c00715 	stw	r3,28(r23)
 1201b64:	003f9906 	br	12019cc <__alt_mem_instruction_tcm+0xff2019cc>

01201b68 <_sbrk_r>:
 1201b68:	defffd04 	addi	sp,sp,-12
 1201b6c:	dc000015 	stw	r16,0(sp)
 1201b70:	04004874 	movhi	r16,289
 1201b74:	dc400115 	stw	r17,4(sp)
 1201b78:	8426e204 	addi	r16,r16,-25720
 1201b7c:	2023883a 	mov	r17,r4
 1201b80:	2809883a 	mov	r4,r5
 1201b84:	dfc00215 	stw	ra,8(sp)
 1201b88:	80000015 	stw	zero,0(r16)
 1201b8c:	12039400 	call	1203940 <sbrk>
 1201b90:	00ffffc4 	movi	r3,-1
 1201b94:	10c00526 	beq	r2,r3,1201bac <_sbrk_r+0x44>
 1201b98:	dfc00217 	ldw	ra,8(sp)
 1201b9c:	dc400117 	ldw	r17,4(sp)
 1201ba0:	dc000017 	ldw	r16,0(sp)
 1201ba4:	dec00304 	addi	sp,sp,12
 1201ba8:	f800283a 	ret
 1201bac:	80c00017 	ldw	r3,0(r16)
 1201bb0:	183ff926 	beq	r3,zero,1201b98 <__alt_mem_instruction_tcm+0xff201b98>
 1201bb4:	88c00015 	stw	r3,0(r17)
 1201bb8:	003ff706 	br	1201b98 <__alt_mem_instruction_tcm+0xff201b98>

01201bbc <__swsetup_r>:
 1201bbc:	00804874 	movhi	r2,289
 1201bc0:	defffd04 	addi	sp,sp,-12
 1201bc4:	10a6cf04 	addi	r2,r2,-25796
 1201bc8:	dc400115 	stw	r17,4(sp)
 1201bcc:	2023883a 	mov	r17,r4
 1201bd0:	11000017 	ldw	r4,0(r2)
 1201bd4:	dc000015 	stw	r16,0(sp)
 1201bd8:	dfc00215 	stw	ra,8(sp)
 1201bdc:	2821883a 	mov	r16,r5
 1201be0:	20000226 	beq	r4,zero,1201bec <__swsetup_r+0x30>
 1201be4:	20c00e17 	ldw	r3,56(r4)
 1201be8:	18002e26 	beq	r3,zero,1201ca4 <__swsetup_r+0xe8>
 1201bec:	8080030b 	ldhu	r2,12(r16)
 1201bf0:	10c0020c 	andi	r3,r2,8
 1201bf4:	100d883a 	mov	r6,r2
 1201bf8:	18000f26 	beq	r3,zero,1201c38 <__swsetup_r+0x7c>
 1201bfc:	80c00417 	ldw	r3,16(r16)
 1201c00:	18001526 	beq	r3,zero,1201c58 <__swsetup_r+0x9c>
 1201c04:	1100004c 	andi	r4,r2,1
 1201c08:	20001c1e 	bne	r4,zero,1201c7c <__swsetup_r+0xc0>
 1201c0c:	1080008c 	andi	r2,r2,2
 1201c10:	1000261e 	bne	r2,zero,1201cac <__swsetup_r+0xf0>
 1201c14:	80800517 	ldw	r2,20(r16)
 1201c18:	80800215 	stw	r2,8(r16)
 1201c1c:	18001c26 	beq	r3,zero,1201c90 <__swsetup_r+0xd4>
 1201c20:	0005883a 	mov	r2,zero
 1201c24:	dfc00217 	ldw	ra,8(sp)
 1201c28:	dc400117 	ldw	r17,4(sp)
 1201c2c:	dc000017 	ldw	r16,0(sp)
 1201c30:	dec00304 	addi	sp,sp,12
 1201c34:	f800283a 	ret
 1201c38:	3080040c 	andi	r2,r6,16
 1201c3c:	10001726 	beq	r2,zero,1201c9c <__swsetup_r+0xe0>
 1201c40:	3080010c 	andi	r2,r6,4
 1201c44:	10001b1e 	bne	r2,zero,1201cb4 <__swsetup_r+0xf8>
 1201c48:	80c00417 	ldw	r3,16(r16)
 1201c4c:	30800214 	ori	r2,r6,8
 1201c50:	8080030d 	sth	r2,12(r16)
 1201c54:	183feb1e 	bne	r3,zero,1201c04 <__alt_mem_instruction_tcm+0xff201c04>
 1201c58:	1140a00c 	andi	r5,r2,640
 1201c5c:	01008004 	movi	r4,512
 1201c60:	293fe826 	beq	r5,r4,1201c04 <__alt_mem_instruction_tcm+0xff201c04>
 1201c64:	8809883a 	mov	r4,r17
 1201c68:	800b883a 	mov	r5,r16
 1201c6c:	12028680 	call	1202868 <__smakebuf_r>
 1201c70:	8080030b 	ldhu	r2,12(r16)
 1201c74:	80c00417 	ldw	r3,16(r16)
 1201c78:	003fe206 	br	1201c04 <__alt_mem_instruction_tcm+0xff201c04>
 1201c7c:	80800517 	ldw	r2,20(r16)
 1201c80:	80000215 	stw	zero,8(r16)
 1201c84:	0085c83a 	sub	r2,zero,r2
 1201c88:	80800615 	stw	r2,24(r16)
 1201c8c:	183fe41e 	bne	r3,zero,1201c20 <__alt_mem_instruction_tcm+0xff201c20>
 1201c90:	8080030b 	ldhu	r2,12(r16)
 1201c94:	1080200c 	andi	r2,r2,128
 1201c98:	103fe226 	beq	r2,zero,1201c24 <__alt_mem_instruction_tcm+0xff201c24>
 1201c9c:	00bfffc4 	movi	r2,-1
 1201ca0:	003fe006 	br	1201c24 <__alt_mem_instruction_tcm+0xff201c24>
 1201ca4:	12022940 	call	1202294 <__sinit>
 1201ca8:	003fd006 	br	1201bec <__alt_mem_instruction_tcm+0xff201bec>
 1201cac:	0005883a 	mov	r2,zero
 1201cb0:	003fd906 	br	1201c18 <__alt_mem_instruction_tcm+0xff201c18>
 1201cb4:	81400c17 	ldw	r5,48(r16)
 1201cb8:	28000626 	beq	r5,zero,1201cd4 <__swsetup_r+0x118>
 1201cbc:	80801004 	addi	r2,r16,64
 1201cc0:	28800326 	beq	r5,r2,1201cd0 <__swsetup_r+0x114>
 1201cc4:	8809883a 	mov	r4,r17
 1201cc8:	12024080 	call	1202408 <_free_r>
 1201ccc:	8180030b 	ldhu	r6,12(r16)
 1201cd0:	80000c15 	stw	zero,48(r16)
 1201cd4:	80c00417 	ldw	r3,16(r16)
 1201cd8:	00bff6c4 	movi	r2,-37
 1201cdc:	118c703a 	and	r6,r2,r6
 1201ce0:	80000115 	stw	zero,4(r16)
 1201ce4:	80c00015 	stw	r3,0(r16)
 1201ce8:	003fd806 	br	1201c4c <__alt_mem_instruction_tcm+0xff201c4c>

01201cec <_fflush_r>:
 1201cec:	defffb04 	addi	sp,sp,-20
 1201cf0:	dcc00315 	stw	r19,12(sp)
 1201cf4:	dc000015 	stw	r16,0(sp)
 1201cf8:	dfc00415 	stw	ra,16(sp)
 1201cfc:	dc800215 	stw	r18,8(sp)
 1201d00:	dc400115 	stw	r17,4(sp)
 1201d04:	2027883a 	mov	r19,r4
 1201d08:	2821883a 	mov	r16,r5
 1201d0c:	20000226 	beq	r4,zero,1201d18 <_fflush_r+0x2c>
 1201d10:	20800e17 	ldw	r2,56(r4)
 1201d14:	10005326 	beq	r2,zero,1201e64 <_fflush_r+0x178>
 1201d18:	8080030b 	ldhu	r2,12(r16)
 1201d1c:	10ffffcc 	andi	r3,r2,65535
 1201d20:	18e0001c 	xori	r3,r3,32768
 1201d24:	18e00004 	addi	r3,r3,-32768
 1201d28:	18002c26 	beq	r3,zero,1201ddc <_fflush_r+0xf0>
 1201d2c:	10c0020c 	andi	r3,r2,8
 1201d30:	1800321e 	bne	r3,zero,1201dfc <_fflush_r+0x110>
 1201d34:	80c00117 	ldw	r3,4(r16)
 1201d38:	10820014 	ori	r2,r2,2048
 1201d3c:	8080030d 	sth	r2,12(r16)
 1201d40:	00c0570e 	bge	zero,r3,1201ea0 <_fflush_r+0x1b4>
 1201d44:	82000a17 	ldw	r8,40(r16)
 1201d48:	40002426 	beq	r8,zero,1201ddc <_fflush_r+0xf0>
 1201d4c:	9c400017 	ldw	r17,0(r19)
 1201d50:	10c4000c 	andi	r3,r2,4096
 1201d54:	98000015 	stw	zero,0(r19)
 1201d58:	18004626 	beq	r3,zero,1201e74 <_fflush_r+0x188>
 1201d5c:	81801417 	ldw	r6,80(r16)
 1201d60:	10c0010c 	andi	r3,r2,4
 1201d64:	18000626 	beq	r3,zero,1201d80 <_fflush_r+0x94>
 1201d68:	80c00117 	ldw	r3,4(r16)
 1201d6c:	80800c17 	ldw	r2,48(r16)
 1201d70:	30cdc83a 	sub	r6,r6,r3
 1201d74:	10000226 	beq	r2,zero,1201d80 <_fflush_r+0x94>
 1201d78:	80800f17 	ldw	r2,60(r16)
 1201d7c:	308dc83a 	sub	r6,r6,r2
 1201d80:	81400717 	ldw	r5,28(r16)
 1201d84:	9809883a 	mov	r4,r19
 1201d88:	000f883a 	mov	r7,zero
 1201d8c:	403ee83a 	callr	r8
 1201d90:	00ffffc4 	movi	r3,-1
 1201d94:	10c04526 	beq	r2,r3,1201eac <_fflush_r+0x1c0>
 1201d98:	80c0030b 	ldhu	r3,12(r16)
 1201d9c:	81000417 	ldw	r4,16(r16)
 1201da0:	80000115 	stw	zero,4(r16)
 1201da4:	197dffcc 	andi	r5,r3,63487
 1201da8:	8140030d 	sth	r5,12(r16)
 1201dac:	81000015 	stw	r4,0(r16)
 1201db0:	18c4000c 	andi	r3,r3,4096
 1201db4:	18000126 	beq	r3,zero,1201dbc <_fflush_r+0xd0>
 1201db8:	80801415 	stw	r2,80(r16)
 1201dbc:	81400c17 	ldw	r5,48(r16)
 1201dc0:	9c400015 	stw	r17,0(r19)
 1201dc4:	28000526 	beq	r5,zero,1201ddc <_fflush_r+0xf0>
 1201dc8:	80801004 	addi	r2,r16,64
 1201dcc:	28800226 	beq	r5,r2,1201dd8 <_fflush_r+0xec>
 1201dd0:	9809883a 	mov	r4,r19
 1201dd4:	12024080 	call	1202408 <_free_r>
 1201dd8:	80000c15 	stw	zero,48(r16)
 1201ddc:	0005883a 	mov	r2,zero
 1201de0:	dfc00417 	ldw	ra,16(sp)
 1201de4:	dcc00317 	ldw	r19,12(sp)
 1201de8:	dc800217 	ldw	r18,8(sp)
 1201dec:	dc400117 	ldw	r17,4(sp)
 1201df0:	dc000017 	ldw	r16,0(sp)
 1201df4:	dec00504 	addi	sp,sp,20
 1201df8:	f800283a 	ret
 1201dfc:	84800417 	ldw	r18,16(r16)
 1201e00:	903ff626 	beq	r18,zero,1201ddc <__alt_mem_instruction_tcm+0xff201ddc>
 1201e04:	84400017 	ldw	r17,0(r16)
 1201e08:	108000cc 	andi	r2,r2,3
 1201e0c:	84800015 	stw	r18,0(r16)
 1201e10:	8ca3c83a 	sub	r17,r17,r18
 1201e14:	10001526 	beq	r2,zero,1201e6c <_fflush_r+0x180>
 1201e18:	0005883a 	mov	r2,zero
 1201e1c:	80800215 	stw	r2,8(r16)
 1201e20:	04400316 	blt	zero,r17,1201e30 <_fflush_r+0x144>
 1201e24:	003fed06 	br	1201ddc <__alt_mem_instruction_tcm+0xff201ddc>
 1201e28:	90a5883a 	add	r18,r18,r2
 1201e2c:	047feb0e 	bge	zero,r17,1201ddc <__alt_mem_instruction_tcm+0xff201ddc>
 1201e30:	80800917 	ldw	r2,36(r16)
 1201e34:	81400717 	ldw	r5,28(r16)
 1201e38:	880f883a 	mov	r7,r17
 1201e3c:	900d883a 	mov	r6,r18
 1201e40:	9809883a 	mov	r4,r19
 1201e44:	103ee83a 	callr	r2
 1201e48:	88a3c83a 	sub	r17,r17,r2
 1201e4c:	00bff616 	blt	zero,r2,1201e28 <__alt_mem_instruction_tcm+0xff201e28>
 1201e50:	80c0030b 	ldhu	r3,12(r16)
 1201e54:	00bfffc4 	movi	r2,-1
 1201e58:	18c01014 	ori	r3,r3,64
 1201e5c:	80c0030d 	sth	r3,12(r16)
 1201e60:	003fdf06 	br	1201de0 <__alt_mem_instruction_tcm+0xff201de0>
 1201e64:	12022940 	call	1202294 <__sinit>
 1201e68:	003fab06 	br	1201d18 <__alt_mem_instruction_tcm+0xff201d18>
 1201e6c:	80800517 	ldw	r2,20(r16)
 1201e70:	003fea06 	br	1201e1c <__alt_mem_instruction_tcm+0xff201e1c>
 1201e74:	81400717 	ldw	r5,28(r16)
 1201e78:	000d883a 	mov	r6,zero
 1201e7c:	9809883a 	mov	r4,r19
 1201e80:	01c00044 	movi	r7,1
 1201e84:	403ee83a 	callr	r8
 1201e88:	100d883a 	mov	r6,r2
 1201e8c:	00bfffc4 	movi	r2,-1
 1201e90:	30801326 	beq	r6,r2,1201ee0 <_fflush_r+0x1f4>
 1201e94:	8080030b 	ldhu	r2,12(r16)
 1201e98:	82000a17 	ldw	r8,40(r16)
 1201e9c:	003fb006 	br	1201d60 <__alt_mem_instruction_tcm+0xff201d60>
 1201ea0:	80c00f17 	ldw	r3,60(r16)
 1201ea4:	00ffa716 	blt	zero,r3,1201d44 <__alt_mem_instruction_tcm+0xff201d44>
 1201ea8:	003fcc06 	br	1201ddc <__alt_mem_instruction_tcm+0xff201ddc>
 1201eac:	98c00017 	ldw	r3,0(r19)
 1201eb0:	183fb926 	beq	r3,zero,1201d98 <__alt_mem_instruction_tcm+0xff201d98>
 1201eb4:	01000744 	movi	r4,29
 1201eb8:	19000226 	beq	r3,r4,1201ec4 <_fflush_r+0x1d8>
 1201ebc:	01000584 	movi	r4,22
 1201ec0:	1900101e 	bne	r3,r4,1201f04 <_fflush_r+0x218>
 1201ec4:	8080030b 	ldhu	r2,12(r16)
 1201ec8:	80c00417 	ldw	r3,16(r16)
 1201ecc:	80000115 	stw	zero,4(r16)
 1201ed0:	10bdffcc 	andi	r2,r2,63487
 1201ed4:	8080030d 	sth	r2,12(r16)
 1201ed8:	80c00015 	stw	r3,0(r16)
 1201edc:	003fb706 	br	1201dbc <__alt_mem_instruction_tcm+0xff201dbc>
 1201ee0:	98800017 	ldw	r2,0(r19)
 1201ee4:	103feb26 	beq	r2,zero,1201e94 <__alt_mem_instruction_tcm+0xff201e94>
 1201ee8:	00c00744 	movi	r3,29
 1201eec:	10c00226 	beq	r2,r3,1201ef8 <_fflush_r+0x20c>
 1201ef0:	00c00584 	movi	r3,22
 1201ef4:	10ffd61e 	bne	r2,r3,1201e50 <__alt_mem_instruction_tcm+0xff201e50>
 1201ef8:	9c400015 	stw	r17,0(r19)
 1201efc:	0005883a 	mov	r2,zero
 1201f00:	003fb706 	br	1201de0 <__alt_mem_instruction_tcm+0xff201de0>
 1201f04:	80c0030b 	ldhu	r3,12(r16)
 1201f08:	18c01014 	ori	r3,r3,64
 1201f0c:	80c0030d 	sth	r3,12(r16)
 1201f10:	003fb306 	br	1201de0 <__alt_mem_instruction_tcm+0xff201de0>

01201f14 <fflush>:
 1201f14:	20000526 	beq	r4,zero,1201f2c <fflush+0x18>
 1201f18:	00804874 	movhi	r2,289
 1201f1c:	10a6cf04 	addi	r2,r2,-25796
 1201f20:	200b883a 	mov	r5,r4
 1201f24:	11000017 	ldw	r4,0(r2)
 1201f28:	1201cec1 	jmpi	1201cec <_fflush_r>
 1201f2c:	00804874 	movhi	r2,289
 1201f30:	10a6ce04 	addi	r2,r2,-25800
 1201f34:	11000017 	ldw	r4,0(r2)
 1201f38:	01404834 	movhi	r5,288
 1201f3c:	29473b04 	addi	r5,r5,7404
 1201f40:	12027b01 	jmpi	12027b0 <_fwalk_reent>

01201f44 <__fp_lock>:
 1201f44:	0005883a 	mov	r2,zero
 1201f48:	f800283a 	ret

01201f4c <__fp_unlock>:
 1201f4c:	0005883a 	mov	r2,zero
 1201f50:	f800283a 	ret

01201f54 <_cleanup_r>:
 1201f54:	01404834 	movhi	r5,288
 1201f58:	294b8c04 	addi	r5,r5,11824
 1201f5c:	12026f81 	jmpi	12026f8 <_fwalk>

01201f60 <__sinit.part.1>:
 1201f60:	defff604 	addi	sp,sp,-40
 1201f64:	00c04834 	movhi	r3,288
 1201f68:	dfc00915 	stw	ra,36(sp)
 1201f6c:	df000815 	stw	fp,32(sp)
 1201f70:	ddc00715 	stw	r23,28(sp)
 1201f74:	dd800615 	stw	r22,24(sp)
 1201f78:	dd400515 	stw	r21,20(sp)
 1201f7c:	dd000415 	stw	r20,16(sp)
 1201f80:	dcc00315 	stw	r19,12(sp)
 1201f84:	dc800215 	stw	r18,8(sp)
 1201f88:	dc400115 	stw	r17,4(sp)
 1201f8c:	dc000015 	stw	r16,0(sp)
 1201f90:	18c7d504 	addi	r3,r3,8020
 1201f94:	24000117 	ldw	r16,4(r4)
 1201f98:	20c00f15 	stw	r3,60(r4)
 1201f9c:	07000044 	movi	fp,1
 1201fa0:	00c000c4 	movi	r3,3
 1201fa4:	2080bb04 	addi	r2,r4,748
 1201fa8:	20c0b915 	stw	r3,740(r4)
 1201fac:	27000e15 	stw	fp,56(r4)
 1201fb0:	2080ba15 	stw	r2,744(r4)
 1201fb4:	2000b815 	stw	zero,736(r4)
 1201fb8:	05c00204 	movi	r23,8
 1201fbc:	00800104 	movi	r2,4
 1201fc0:	2025883a 	mov	r18,r4
 1201fc4:	b80d883a 	mov	r6,r23
 1201fc8:	81001704 	addi	r4,r16,92
 1201fcc:	000b883a 	mov	r5,zero
 1201fd0:	80000015 	stw	zero,0(r16)
 1201fd4:	80000115 	stw	zero,4(r16)
 1201fd8:	80000215 	stw	zero,8(r16)
 1201fdc:	8080030d 	sth	r2,12(r16)
 1201fe0:	80001915 	stw	zero,100(r16)
 1201fe4:	8000038d 	sth	zero,14(r16)
 1201fe8:	80000415 	stw	zero,16(r16)
 1201fec:	80000515 	stw	zero,20(r16)
 1201ff0:	80000615 	stw	zero,24(r16)
 1201ff4:	1202a200 	call	1202a20 <memset>
 1201ff8:	05804834 	movhi	r22,288
 1201ffc:	94400217 	ldw	r17,8(r18)
 1202000:	05404834 	movhi	r21,288
 1202004:	05004834 	movhi	r20,288
 1202008:	04c04834 	movhi	r19,288
 120200c:	b58ad104 	addi	r22,r22,11076
 1202010:	ad4ae804 	addi	r21,r21,11168
 1202014:	a50b0704 	addi	r20,r20,11292
 1202018:	9ccb1e04 	addi	r19,r19,11384
 120201c:	85800815 	stw	r22,32(r16)
 1202020:	85400915 	stw	r21,36(r16)
 1202024:	85000a15 	stw	r20,40(r16)
 1202028:	84c00b15 	stw	r19,44(r16)
 120202c:	84000715 	stw	r16,28(r16)
 1202030:	00800284 	movi	r2,10
 1202034:	89001704 	addi	r4,r17,92
 1202038:	b80d883a 	mov	r6,r23
 120203c:	000b883a 	mov	r5,zero
 1202040:	88000015 	stw	zero,0(r17)
 1202044:	88000115 	stw	zero,4(r17)
 1202048:	88000215 	stw	zero,8(r17)
 120204c:	8880030d 	sth	r2,12(r17)
 1202050:	88001915 	stw	zero,100(r17)
 1202054:	8f00038d 	sth	fp,14(r17)
 1202058:	88000415 	stw	zero,16(r17)
 120205c:	88000515 	stw	zero,20(r17)
 1202060:	88000615 	stw	zero,24(r17)
 1202064:	1202a200 	call	1202a20 <memset>
 1202068:	94000317 	ldw	r16,12(r18)
 120206c:	00800484 	movi	r2,18
 1202070:	8c400715 	stw	r17,28(r17)
 1202074:	8d800815 	stw	r22,32(r17)
 1202078:	8d400915 	stw	r21,36(r17)
 120207c:	8d000a15 	stw	r20,40(r17)
 1202080:	8cc00b15 	stw	r19,44(r17)
 1202084:	8080030d 	sth	r2,12(r16)
 1202088:	00800084 	movi	r2,2
 120208c:	80000015 	stw	zero,0(r16)
 1202090:	80000115 	stw	zero,4(r16)
 1202094:	80000215 	stw	zero,8(r16)
 1202098:	80001915 	stw	zero,100(r16)
 120209c:	8080038d 	sth	r2,14(r16)
 12020a0:	80000415 	stw	zero,16(r16)
 12020a4:	80000515 	stw	zero,20(r16)
 12020a8:	80000615 	stw	zero,24(r16)
 12020ac:	81001704 	addi	r4,r16,92
 12020b0:	000b883a 	mov	r5,zero
 12020b4:	b80d883a 	mov	r6,r23
 12020b8:	1202a200 	call	1202a20 <memset>
 12020bc:	84000715 	stw	r16,28(r16)
 12020c0:	85800815 	stw	r22,32(r16)
 12020c4:	85400915 	stw	r21,36(r16)
 12020c8:	85000a15 	stw	r20,40(r16)
 12020cc:	84c00b15 	stw	r19,44(r16)
 12020d0:	dfc00917 	ldw	ra,36(sp)
 12020d4:	df000817 	ldw	fp,32(sp)
 12020d8:	ddc00717 	ldw	r23,28(sp)
 12020dc:	dd800617 	ldw	r22,24(sp)
 12020e0:	dd400517 	ldw	r21,20(sp)
 12020e4:	dd000417 	ldw	r20,16(sp)
 12020e8:	dcc00317 	ldw	r19,12(sp)
 12020ec:	dc800217 	ldw	r18,8(sp)
 12020f0:	dc400117 	ldw	r17,4(sp)
 12020f4:	dc000017 	ldw	r16,0(sp)
 12020f8:	dec00a04 	addi	sp,sp,40
 12020fc:	f800283a 	ret

01202100 <__sfmoreglue>:
 1202100:	defffc04 	addi	sp,sp,-16
 1202104:	dc400115 	stw	r17,4(sp)
 1202108:	2c401a24 	muli	r17,r5,104
 120210c:	dc800215 	stw	r18,8(sp)
 1202110:	2825883a 	mov	r18,r5
 1202114:	89400304 	addi	r5,r17,12
 1202118:	dc000015 	stw	r16,0(sp)
 120211c:	dfc00315 	stw	ra,12(sp)
 1202120:	1200aa40 	call	1200aa4 <_malloc_r>
 1202124:	1021883a 	mov	r16,r2
 1202128:	10000726 	beq	r2,zero,1202148 <__sfmoreglue+0x48>
 120212c:	11000304 	addi	r4,r2,12
 1202130:	10000015 	stw	zero,0(r2)
 1202134:	14800115 	stw	r18,4(r2)
 1202138:	11000215 	stw	r4,8(r2)
 120213c:	000b883a 	mov	r5,zero
 1202140:	880d883a 	mov	r6,r17
 1202144:	1202a200 	call	1202a20 <memset>
 1202148:	8005883a 	mov	r2,r16
 120214c:	dfc00317 	ldw	ra,12(sp)
 1202150:	dc800217 	ldw	r18,8(sp)
 1202154:	dc400117 	ldw	r17,4(sp)
 1202158:	dc000017 	ldw	r16,0(sp)
 120215c:	dec00404 	addi	sp,sp,16
 1202160:	f800283a 	ret

01202164 <__sfp>:
 1202164:	00804874 	movhi	r2,289
 1202168:	defffb04 	addi	sp,sp,-20
 120216c:	10a6ce04 	addi	r2,r2,-25800
 1202170:	dc800215 	stw	r18,8(sp)
 1202174:	14800017 	ldw	r18,0(r2)
 1202178:	dcc00315 	stw	r19,12(sp)
 120217c:	dfc00415 	stw	ra,16(sp)
 1202180:	90800e17 	ldw	r2,56(r18)
 1202184:	dc400115 	stw	r17,4(sp)
 1202188:	dc000015 	stw	r16,0(sp)
 120218c:	2027883a 	mov	r19,r4
 1202190:	1000021e 	bne	r2,zero,120219c <__sfp+0x38>
 1202194:	9009883a 	mov	r4,r18
 1202198:	1201f600 	call	1201f60 <__sinit.part.1>
 120219c:	9480b804 	addi	r18,r18,736
 12021a0:	047fffc4 	movi	r17,-1
 12021a4:	91400117 	ldw	r5,4(r18)
 12021a8:	94000217 	ldw	r16,8(r18)
 12021ac:	297fffc4 	addi	r5,r5,-1
 12021b0:	28000a16 	blt	r5,zero,12021dc <__sfp+0x78>
 12021b4:	8080030f 	ldh	r2,12(r16)
 12021b8:	10000c26 	beq	r2,zero,12021ec <__sfp+0x88>
 12021bc:	80c01d04 	addi	r3,r16,116
 12021c0:	00000206 	br	12021cc <__sfp+0x68>
 12021c4:	18bfe60f 	ldh	r2,-104(r3)
 12021c8:	10000826 	beq	r2,zero,12021ec <__sfp+0x88>
 12021cc:	297fffc4 	addi	r5,r5,-1
 12021d0:	1c3ffd04 	addi	r16,r3,-12
 12021d4:	18c01a04 	addi	r3,r3,104
 12021d8:	2c7ffa1e 	bne	r5,r17,12021c4 <__alt_mem_instruction_tcm+0xff2021c4>
 12021dc:	90800017 	ldw	r2,0(r18)
 12021e0:	10001d26 	beq	r2,zero,1202258 <__sfp+0xf4>
 12021e4:	1025883a 	mov	r18,r2
 12021e8:	003fee06 	br	12021a4 <__alt_mem_instruction_tcm+0xff2021a4>
 12021ec:	00bfffc4 	movi	r2,-1
 12021f0:	8080038d 	sth	r2,14(r16)
 12021f4:	00800044 	movi	r2,1
 12021f8:	8080030d 	sth	r2,12(r16)
 12021fc:	80001915 	stw	zero,100(r16)
 1202200:	80000015 	stw	zero,0(r16)
 1202204:	80000215 	stw	zero,8(r16)
 1202208:	80000115 	stw	zero,4(r16)
 120220c:	80000415 	stw	zero,16(r16)
 1202210:	80000515 	stw	zero,20(r16)
 1202214:	80000615 	stw	zero,24(r16)
 1202218:	81001704 	addi	r4,r16,92
 120221c:	000b883a 	mov	r5,zero
 1202220:	01800204 	movi	r6,8
 1202224:	1202a200 	call	1202a20 <memset>
 1202228:	8005883a 	mov	r2,r16
 120222c:	80000c15 	stw	zero,48(r16)
 1202230:	80000d15 	stw	zero,52(r16)
 1202234:	80001115 	stw	zero,68(r16)
 1202238:	80001215 	stw	zero,72(r16)
 120223c:	dfc00417 	ldw	ra,16(sp)
 1202240:	dcc00317 	ldw	r19,12(sp)
 1202244:	dc800217 	ldw	r18,8(sp)
 1202248:	dc400117 	ldw	r17,4(sp)
 120224c:	dc000017 	ldw	r16,0(sp)
 1202250:	dec00504 	addi	sp,sp,20
 1202254:	f800283a 	ret
 1202258:	9809883a 	mov	r4,r19
 120225c:	01400104 	movi	r5,4
 1202260:	12021000 	call	1202100 <__sfmoreglue>
 1202264:	90800015 	stw	r2,0(r18)
 1202268:	103fde1e 	bne	r2,zero,12021e4 <__alt_mem_instruction_tcm+0xff2021e4>
 120226c:	00800304 	movi	r2,12
 1202270:	98800015 	stw	r2,0(r19)
 1202274:	0005883a 	mov	r2,zero
 1202278:	003ff006 	br	120223c <__alt_mem_instruction_tcm+0xff20223c>

0120227c <_cleanup>:
 120227c:	00804874 	movhi	r2,289
 1202280:	10a6ce04 	addi	r2,r2,-25800
 1202284:	11000017 	ldw	r4,0(r2)
 1202288:	01404834 	movhi	r5,288
 120228c:	294b8c04 	addi	r5,r5,11824
 1202290:	12026f81 	jmpi	12026f8 <_fwalk>

01202294 <__sinit>:
 1202294:	20800e17 	ldw	r2,56(r4)
 1202298:	10000126 	beq	r2,zero,12022a0 <__sinit+0xc>
 120229c:	f800283a 	ret
 12022a0:	1201f601 	jmpi	1201f60 <__sinit.part.1>

012022a4 <__sfp_lock_acquire>:
 12022a4:	f800283a 	ret

012022a8 <__sfp_lock_release>:
 12022a8:	f800283a 	ret

012022ac <__sinit_lock_acquire>:
 12022ac:	f800283a 	ret

012022b0 <__sinit_lock_release>:
 12022b0:	f800283a 	ret

012022b4 <__fp_lock_all>:
 12022b4:	00804874 	movhi	r2,289
 12022b8:	10a6cf04 	addi	r2,r2,-25796
 12022bc:	11000017 	ldw	r4,0(r2)
 12022c0:	01404834 	movhi	r5,288
 12022c4:	2947d104 	addi	r5,r5,8004
 12022c8:	12026f81 	jmpi	12026f8 <_fwalk>

012022cc <__fp_unlock_all>:
 12022cc:	00804874 	movhi	r2,289
 12022d0:	10a6cf04 	addi	r2,r2,-25796
 12022d4:	11000017 	ldw	r4,0(r2)
 12022d8:	01404834 	movhi	r5,288
 12022dc:	2947d304 	addi	r5,r5,8012
 12022e0:	12026f81 	jmpi	12026f8 <_fwalk>

012022e4 <_malloc_trim_r>:
 12022e4:	defffb04 	addi	sp,sp,-20
 12022e8:	dcc00315 	stw	r19,12(sp)
 12022ec:	04c04874 	movhi	r19,289
 12022f0:	dc800215 	stw	r18,8(sp)
 12022f4:	dc400115 	stw	r17,4(sp)
 12022f8:	dc000015 	stw	r16,0(sp)
 12022fc:	dfc00415 	stw	ra,16(sp)
 1202300:	2821883a 	mov	r16,r5
 1202304:	9ce11304 	addi	r19,r19,-31668
 1202308:	2025883a 	mov	r18,r4
 120230c:	12037540 	call	1203754 <__malloc_lock>
 1202310:	98800217 	ldw	r2,8(r19)
 1202314:	14400117 	ldw	r17,4(r2)
 1202318:	00bfff04 	movi	r2,-4
 120231c:	88a2703a 	and	r17,r17,r2
 1202320:	8c21c83a 	sub	r16,r17,r16
 1202324:	8403fbc4 	addi	r16,r16,4079
 1202328:	8020d33a 	srli	r16,r16,12
 120232c:	0083ffc4 	movi	r2,4095
 1202330:	843fffc4 	addi	r16,r16,-1
 1202334:	8020933a 	slli	r16,r16,12
 1202338:	1400060e 	bge	r2,r16,1202354 <_malloc_trim_r+0x70>
 120233c:	9009883a 	mov	r4,r18
 1202340:	000b883a 	mov	r5,zero
 1202344:	1201b680 	call	1201b68 <_sbrk_r>
 1202348:	98c00217 	ldw	r3,8(r19)
 120234c:	1c47883a 	add	r3,r3,r17
 1202350:	10c00a26 	beq	r2,r3,120237c <_malloc_trim_r+0x98>
 1202354:	9009883a 	mov	r4,r18
 1202358:	12037740 	call	1203774 <__malloc_unlock>
 120235c:	0005883a 	mov	r2,zero
 1202360:	dfc00417 	ldw	ra,16(sp)
 1202364:	dcc00317 	ldw	r19,12(sp)
 1202368:	dc800217 	ldw	r18,8(sp)
 120236c:	dc400117 	ldw	r17,4(sp)
 1202370:	dc000017 	ldw	r16,0(sp)
 1202374:	dec00504 	addi	sp,sp,20
 1202378:	f800283a 	ret
 120237c:	9009883a 	mov	r4,r18
 1202380:	040bc83a 	sub	r5,zero,r16
 1202384:	1201b680 	call	1201b68 <_sbrk_r>
 1202388:	00ffffc4 	movi	r3,-1
 120238c:	10c00d26 	beq	r2,r3,12023c4 <_malloc_trim_r+0xe0>
 1202390:	00c04874 	movhi	r3,289
 1202394:	18e6ea04 	addi	r3,r3,-25688
 1202398:	18800017 	ldw	r2,0(r3)
 120239c:	99000217 	ldw	r4,8(r19)
 12023a0:	8c23c83a 	sub	r17,r17,r16
 12023a4:	8c400054 	ori	r17,r17,1
 12023a8:	1421c83a 	sub	r16,r2,r16
 12023ac:	24400115 	stw	r17,4(r4)
 12023b0:	9009883a 	mov	r4,r18
 12023b4:	1c000015 	stw	r16,0(r3)
 12023b8:	12037740 	call	1203774 <__malloc_unlock>
 12023bc:	00800044 	movi	r2,1
 12023c0:	003fe706 	br	1202360 <__alt_mem_instruction_tcm+0xff202360>
 12023c4:	9009883a 	mov	r4,r18
 12023c8:	000b883a 	mov	r5,zero
 12023cc:	1201b680 	call	1201b68 <_sbrk_r>
 12023d0:	99000217 	ldw	r4,8(r19)
 12023d4:	014003c4 	movi	r5,15
 12023d8:	1107c83a 	sub	r3,r2,r4
 12023dc:	28ffdd0e 	bge	r5,r3,1202354 <__alt_mem_instruction_tcm+0xff202354>
 12023e0:	01404874 	movhi	r5,289
 12023e4:	2966d004 	addi	r5,r5,-25792
 12023e8:	29400017 	ldw	r5,0(r5)
 12023ec:	18c00054 	ori	r3,r3,1
 12023f0:	20c00115 	stw	r3,4(r4)
 12023f4:	00c04874 	movhi	r3,289
 12023f8:	1145c83a 	sub	r2,r2,r5
 12023fc:	18e6ea04 	addi	r3,r3,-25688
 1202400:	18800015 	stw	r2,0(r3)
 1202404:	003fd306 	br	1202354 <__alt_mem_instruction_tcm+0xff202354>

01202408 <_free_r>:
 1202408:	28004c26 	beq	r5,zero,120253c <_free_r+0x134>
 120240c:	defffd04 	addi	sp,sp,-12
 1202410:	dc400115 	stw	r17,4(sp)
 1202414:	dc000015 	stw	r16,0(sp)
 1202418:	2023883a 	mov	r17,r4
 120241c:	2821883a 	mov	r16,r5
 1202420:	dfc00215 	stw	ra,8(sp)
 1202424:	12037540 	call	1203754 <__malloc_lock>
 1202428:	813fff17 	ldw	r4,-4(r16)
 120242c:	00bfff84 	movi	r2,-2
 1202430:	02404874 	movhi	r9,289
 1202434:	81bffe04 	addi	r6,r16,-8
 1202438:	2084703a 	and	r2,r4,r2
 120243c:	4a611304 	addi	r9,r9,-31668
 1202440:	308b883a 	add	r5,r6,r2
 1202444:	2a000117 	ldw	r8,4(r5)
 1202448:	49c00217 	ldw	r7,8(r9)
 120244c:	00ffff04 	movi	r3,-4
 1202450:	40c6703a 	and	r3,r8,r3
 1202454:	39405326 	beq	r7,r5,12025a4 <_free_r+0x19c>
 1202458:	28c00115 	stw	r3,4(r5)
 120245c:	2100004c 	andi	r4,r4,1
 1202460:	2000091e 	bne	r4,zero,1202488 <_free_r+0x80>
 1202464:	81fffe17 	ldw	r7,-8(r16)
 1202468:	4a000204 	addi	r8,r9,8
 120246c:	31cdc83a 	sub	r6,r6,r7
 1202470:	31000217 	ldw	r4,8(r6)
 1202474:	11c5883a 	add	r2,r2,r7
 1202478:	22006126 	beq	r4,r8,1202600 <_free_r+0x1f8>
 120247c:	31c00317 	ldw	r7,12(r6)
 1202480:	21c00315 	stw	r7,12(r4)
 1202484:	39000215 	stw	r4,8(r7)
 1202488:	28c9883a 	add	r4,r5,r3
 120248c:	21c00117 	ldw	r7,4(r4)
 1202490:	39c0004c 	andi	r7,r7,1
 1202494:	38000d1e 	bne	r7,zero,12024cc <_free_r+0xc4>
 1202498:	29000217 	ldw	r4,8(r5)
 120249c:	10c5883a 	add	r2,r2,r3
 12024a0:	00c04874 	movhi	r3,289
 12024a4:	18e11504 	addi	r3,r3,-31660
 12024a8:	20c07526 	beq	r4,r3,1202680 <_free_r+0x278>
 12024ac:	29c00317 	ldw	r7,12(r5)
 12024b0:	11400054 	ori	r5,r2,1
 12024b4:	3087883a 	add	r3,r6,r2
 12024b8:	21c00315 	stw	r7,12(r4)
 12024bc:	39000215 	stw	r4,8(r7)
 12024c0:	31400115 	stw	r5,4(r6)
 12024c4:	18800015 	stw	r2,0(r3)
 12024c8:	00000406 	br	12024dc <_free_r+0xd4>
 12024cc:	10c00054 	ori	r3,r2,1
 12024d0:	30c00115 	stw	r3,4(r6)
 12024d4:	3087883a 	add	r3,r6,r2
 12024d8:	18800015 	stw	r2,0(r3)
 12024dc:	00c07fc4 	movi	r3,511
 12024e0:	18801736 	bltu	r3,r2,1202540 <_free_r+0x138>
 12024e4:	1004d0fa 	srli	r2,r2,3
 12024e8:	01400044 	movi	r5,1
 12024ec:	49000117 	ldw	r4,4(r9)
 12024f0:	1087883a 	add	r3,r2,r2
 12024f4:	18c7883a 	add	r3,r3,r3
 12024f8:	1005d0ba 	srai	r2,r2,2
 12024fc:	18c7883a 	add	r3,r3,r3
 1202500:	1a47883a 	add	r3,r3,r9
 1202504:	19c00217 	ldw	r7,8(r3)
 1202508:	2884983a 	sll	r2,r5,r2
 120250c:	30c00315 	stw	r3,12(r6)
 1202510:	31c00215 	stw	r7,8(r6)
 1202514:	1104b03a 	or	r2,r2,r4
 1202518:	19800215 	stw	r6,8(r3)
 120251c:	48800115 	stw	r2,4(r9)
 1202520:	39800315 	stw	r6,12(r7)
 1202524:	8809883a 	mov	r4,r17
 1202528:	dfc00217 	ldw	ra,8(sp)
 120252c:	dc400117 	ldw	r17,4(sp)
 1202530:	dc000017 	ldw	r16,0(sp)
 1202534:	dec00304 	addi	sp,sp,12
 1202538:	12037741 	jmpi	1203774 <__malloc_unlock>
 120253c:	f800283a 	ret
 1202540:	1006d27a 	srli	r3,r2,9
 1202544:	01000104 	movi	r4,4
 1202548:	20c04036 	bltu	r4,r3,120264c <_free_r+0x244>
 120254c:	1006d1ba 	srli	r3,r2,6
 1202550:	19400e04 	addi	r5,r3,56
 1202554:	2947883a 	add	r3,r5,r5
 1202558:	18c7883a 	add	r3,r3,r3
 120255c:	18c7883a 	add	r3,r3,r3
 1202560:	1a49883a 	add	r4,r3,r9
 1202564:	20c00217 	ldw	r3,8(r4)
 1202568:	01c04874 	movhi	r7,289
 120256c:	39e11304 	addi	r7,r7,-31668
 1202570:	19003b26 	beq	r3,r4,1202660 <_free_r+0x258>
 1202574:	01ffff04 	movi	r7,-4
 1202578:	19400117 	ldw	r5,4(r3)
 120257c:	29ca703a 	and	r5,r5,r7
 1202580:	1140022e 	bgeu	r2,r5,120258c <_free_r+0x184>
 1202584:	18c00217 	ldw	r3,8(r3)
 1202588:	20fffb1e 	bne	r4,r3,1202578 <__alt_mem_instruction_tcm+0xff202578>
 120258c:	18800317 	ldw	r2,12(r3)
 1202590:	30800315 	stw	r2,12(r6)
 1202594:	30c00215 	stw	r3,8(r6)
 1202598:	11800215 	stw	r6,8(r2)
 120259c:	19800315 	stw	r6,12(r3)
 12025a0:	003fe006 	br	1202524 <__alt_mem_instruction_tcm+0xff202524>
 12025a4:	2100004c 	andi	r4,r4,1
 12025a8:	1885883a 	add	r2,r3,r2
 12025ac:	2000071e 	bne	r4,zero,12025cc <_free_r+0x1c4>
 12025b0:	817ffe17 	ldw	r5,-8(r16)
 12025b4:	314dc83a 	sub	r6,r6,r5
 12025b8:	30c00317 	ldw	r3,12(r6)
 12025bc:	31000217 	ldw	r4,8(r6)
 12025c0:	1145883a 	add	r2,r2,r5
 12025c4:	20c00315 	stw	r3,12(r4)
 12025c8:	19000215 	stw	r4,8(r3)
 12025cc:	10c00054 	ori	r3,r2,1
 12025d0:	30c00115 	stw	r3,4(r6)
 12025d4:	00c04874 	movhi	r3,289
 12025d8:	18e6d104 	addi	r3,r3,-25788
 12025dc:	18c00017 	ldw	r3,0(r3)
 12025e0:	49800215 	stw	r6,8(r9)
 12025e4:	10ffcf36 	bltu	r2,r3,1202524 <__alt_mem_instruction_tcm+0xff202524>
 12025e8:	00804874 	movhi	r2,289
 12025ec:	10a6e104 	addi	r2,r2,-25724
 12025f0:	11400017 	ldw	r5,0(r2)
 12025f4:	8809883a 	mov	r4,r17
 12025f8:	12022e40 	call	12022e4 <_malloc_trim_r>
 12025fc:	003fc906 	br	1202524 <__alt_mem_instruction_tcm+0xff202524>
 1202600:	28c9883a 	add	r4,r5,r3
 1202604:	21000117 	ldw	r4,4(r4)
 1202608:	2100004c 	andi	r4,r4,1
 120260c:	20000a1e 	bne	r4,zero,1202638 <_free_r+0x230>
 1202610:	29000317 	ldw	r4,12(r5)
 1202614:	29400217 	ldw	r5,8(r5)
 1202618:	10c5883a 	add	r2,r2,r3
 120261c:	10c00054 	ori	r3,r2,1
 1202620:	29000315 	stw	r4,12(r5)
 1202624:	21400215 	stw	r5,8(r4)
 1202628:	30c00115 	stw	r3,4(r6)
 120262c:	308d883a 	add	r6,r6,r2
 1202630:	30800015 	stw	r2,0(r6)
 1202634:	003fbb06 	br	1202524 <__alt_mem_instruction_tcm+0xff202524>
 1202638:	10c00054 	ori	r3,r2,1
 120263c:	30c00115 	stw	r3,4(r6)
 1202640:	308d883a 	add	r6,r6,r2
 1202644:	30800015 	stw	r2,0(r6)
 1202648:	003fb606 	br	1202524 <__alt_mem_instruction_tcm+0xff202524>
 120264c:	01000504 	movi	r4,20
 1202650:	20c01436 	bltu	r4,r3,12026a4 <_free_r+0x29c>
 1202654:	194016c4 	addi	r5,r3,91
 1202658:	2947883a 	add	r3,r5,r5
 120265c:	003fbe06 	br	1202558 <__alt_mem_instruction_tcm+0xff202558>
 1202660:	280bd0ba 	srai	r5,r5,2
 1202664:	00800044 	movi	r2,1
 1202668:	39000117 	ldw	r4,4(r7)
 120266c:	114a983a 	sll	r5,r2,r5
 1202670:	1805883a 	mov	r2,r3
 1202674:	2908b03a 	or	r4,r5,r4
 1202678:	39000115 	stw	r4,4(r7)
 120267c:	003fc406 	br	1202590 <__alt_mem_instruction_tcm+0xff202590>
 1202680:	49800515 	stw	r6,20(r9)
 1202684:	49800415 	stw	r6,16(r9)
 1202688:	10c00054 	ori	r3,r2,1
 120268c:	31000315 	stw	r4,12(r6)
 1202690:	31000215 	stw	r4,8(r6)
 1202694:	30c00115 	stw	r3,4(r6)
 1202698:	308d883a 	add	r6,r6,r2
 120269c:	30800015 	stw	r2,0(r6)
 12026a0:	003fa006 	br	1202524 <__alt_mem_instruction_tcm+0xff202524>
 12026a4:	01001504 	movi	r4,84
 12026a8:	20c00436 	bltu	r4,r3,12026bc <_free_r+0x2b4>
 12026ac:	1006d33a 	srli	r3,r2,12
 12026b0:	19401b84 	addi	r5,r3,110
 12026b4:	2947883a 	add	r3,r5,r5
 12026b8:	003fa706 	br	1202558 <__alt_mem_instruction_tcm+0xff202558>
 12026bc:	01005504 	movi	r4,340
 12026c0:	20c00436 	bltu	r4,r3,12026d4 <_free_r+0x2cc>
 12026c4:	1006d3fa 	srli	r3,r2,15
 12026c8:	19401dc4 	addi	r5,r3,119
 12026cc:	2947883a 	add	r3,r5,r5
 12026d0:	003fa106 	br	1202558 <__alt_mem_instruction_tcm+0xff202558>
 12026d4:	01015504 	movi	r4,1364
 12026d8:	20c00436 	bltu	r4,r3,12026ec <_free_r+0x2e4>
 12026dc:	1006d4ba 	srli	r3,r2,18
 12026e0:	19401f04 	addi	r5,r3,124
 12026e4:	2947883a 	add	r3,r5,r5
 12026e8:	003f9b06 	br	1202558 <__alt_mem_instruction_tcm+0xff202558>
 12026ec:	00c03f04 	movi	r3,252
 12026f0:	01401f84 	movi	r5,126
 12026f4:	003f9806 	br	1202558 <__alt_mem_instruction_tcm+0xff202558>

012026f8 <_fwalk>:
 12026f8:	defff804 	addi	sp,sp,-32
 12026fc:	dd400515 	stw	r21,20(sp)
 1202700:	2540b804 	addi	r21,r4,736
 1202704:	dd800615 	stw	r22,24(sp)
 1202708:	dd000415 	stw	r20,16(sp)
 120270c:	dfc00715 	stw	ra,28(sp)
 1202710:	dcc00315 	stw	r19,12(sp)
 1202714:	dc800215 	stw	r18,8(sp)
 1202718:	dc400115 	stw	r17,4(sp)
 120271c:	dc000015 	stw	r16,0(sp)
 1202720:	2829883a 	mov	r20,r5
 1202724:	002d883a 	mov	r22,zero
 1202728:	12022a40 	call	12022a4 <__sfp_lock_acquire>
 120272c:	a8001426 	beq	r21,zero,1202780 <_fwalk+0x88>
 1202730:	04ffffc4 	movi	r19,-1
 1202734:	ac400117 	ldw	r17,4(r21)
 1202738:	ac800217 	ldw	r18,8(r21)
 120273c:	8c7fffc4 	addi	r17,r17,-1
 1202740:	88000d16 	blt	r17,zero,1202778 <_fwalk+0x80>
 1202744:	94000304 	addi	r16,r18,12
 1202748:	94800384 	addi	r18,r18,14
 120274c:	80c0000f 	ldh	r3,0(r16)
 1202750:	8c7fffc4 	addi	r17,r17,-1
 1202754:	813ffd04 	addi	r4,r16,-12
 1202758:	18000426 	beq	r3,zero,120276c <_fwalk+0x74>
 120275c:	90c0000f 	ldh	r3,0(r18)
 1202760:	1cc00226 	beq	r3,r19,120276c <_fwalk+0x74>
 1202764:	a03ee83a 	callr	r20
 1202768:	b0acb03a 	or	r22,r22,r2
 120276c:	84001a04 	addi	r16,r16,104
 1202770:	94801a04 	addi	r18,r18,104
 1202774:	8cfff51e 	bne	r17,r19,120274c <__alt_mem_instruction_tcm+0xff20274c>
 1202778:	ad400017 	ldw	r21,0(r21)
 120277c:	a83fed1e 	bne	r21,zero,1202734 <__alt_mem_instruction_tcm+0xff202734>
 1202780:	12022a80 	call	12022a8 <__sfp_lock_release>
 1202784:	b005883a 	mov	r2,r22
 1202788:	dfc00717 	ldw	ra,28(sp)
 120278c:	dd800617 	ldw	r22,24(sp)
 1202790:	dd400517 	ldw	r21,20(sp)
 1202794:	dd000417 	ldw	r20,16(sp)
 1202798:	dcc00317 	ldw	r19,12(sp)
 120279c:	dc800217 	ldw	r18,8(sp)
 12027a0:	dc400117 	ldw	r17,4(sp)
 12027a4:	dc000017 	ldw	r16,0(sp)
 12027a8:	dec00804 	addi	sp,sp,32
 12027ac:	f800283a 	ret

012027b0 <_fwalk_reent>:
 12027b0:	defff804 	addi	sp,sp,-32
 12027b4:	dd400515 	stw	r21,20(sp)
 12027b8:	2540b804 	addi	r21,r4,736
 12027bc:	dd800615 	stw	r22,24(sp)
 12027c0:	dd000415 	stw	r20,16(sp)
 12027c4:	dcc00315 	stw	r19,12(sp)
 12027c8:	dfc00715 	stw	ra,28(sp)
 12027cc:	dc800215 	stw	r18,8(sp)
 12027d0:	dc400115 	stw	r17,4(sp)
 12027d4:	dc000015 	stw	r16,0(sp)
 12027d8:	2027883a 	mov	r19,r4
 12027dc:	2829883a 	mov	r20,r5
 12027e0:	002d883a 	mov	r22,zero
 12027e4:	12022a40 	call	12022a4 <__sfp_lock_acquire>
 12027e8:	a8001326 	beq	r21,zero,1202838 <_fwalk_reent+0x88>
 12027ec:	04bfffc4 	movi	r18,-1
 12027f0:	ac400117 	ldw	r17,4(r21)
 12027f4:	ac000217 	ldw	r16,8(r21)
 12027f8:	8c7fffc4 	addi	r17,r17,-1
 12027fc:	88000c16 	blt	r17,zero,1202830 <_fwalk_reent+0x80>
 1202800:	84000304 	addi	r16,r16,12
 1202804:	80c0000f 	ldh	r3,0(r16)
 1202808:	8c7fffc4 	addi	r17,r17,-1
 120280c:	817ffd04 	addi	r5,r16,-12
 1202810:	18000526 	beq	r3,zero,1202828 <_fwalk_reent+0x78>
 1202814:	80c0008f 	ldh	r3,2(r16)
 1202818:	9809883a 	mov	r4,r19
 120281c:	1c800226 	beq	r3,r18,1202828 <_fwalk_reent+0x78>
 1202820:	a03ee83a 	callr	r20
 1202824:	b0acb03a 	or	r22,r22,r2
 1202828:	84001a04 	addi	r16,r16,104
 120282c:	8cbff51e 	bne	r17,r18,1202804 <__alt_mem_instruction_tcm+0xff202804>
 1202830:	ad400017 	ldw	r21,0(r21)
 1202834:	a83fee1e 	bne	r21,zero,12027f0 <__alt_mem_instruction_tcm+0xff2027f0>
 1202838:	12022a80 	call	12022a8 <__sfp_lock_release>
 120283c:	b005883a 	mov	r2,r22
 1202840:	dfc00717 	ldw	ra,28(sp)
 1202844:	dd800617 	ldw	r22,24(sp)
 1202848:	dd400517 	ldw	r21,20(sp)
 120284c:	dd000417 	ldw	r20,16(sp)
 1202850:	dcc00317 	ldw	r19,12(sp)
 1202854:	dc800217 	ldw	r18,8(sp)
 1202858:	dc400117 	ldw	r17,4(sp)
 120285c:	dc000017 	ldw	r16,0(sp)
 1202860:	dec00804 	addi	sp,sp,32
 1202864:	f800283a 	ret

01202868 <__smakebuf_r>:
 1202868:	2880030b 	ldhu	r2,12(r5)
 120286c:	10c0008c 	andi	r3,r2,2
 1202870:	1800401e 	bne	r3,zero,1202974 <__smakebuf_r+0x10c>
 1202874:	deffec04 	addi	sp,sp,-80
 1202878:	dc000f15 	stw	r16,60(sp)
 120287c:	2821883a 	mov	r16,r5
 1202880:	2940038f 	ldh	r5,14(r5)
 1202884:	dc401015 	stw	r17,64(sp)
 1202888:	dfc01315 	stw	ra,76(sp)
 120288c:	dcc01215 	stw	r19,72(sp)
 1202890:	dc801115 	stw	r18,68(sp)
 1202894:	2023883a 	mov	r17,r4
 1202898:	28001b16 	blt	r5,zero,1202908 <__smakebuf_r+0xa0>
 120289c:	d80d883a 	mov	r6,sp
 12028a0:	1202e440 	call	1202e44 <_fstat_r>
 12028a4:	10001716 	blt	r2,zero,1202904 <__smakebuf_r+0x9c>
 12028a8:	d8800117 	ldw	r2,4(sp)
 12028ac:	00e00014 	movui	r3,32768
 12028b0:	10bc000c 	andi	r2,r2,61440
 12028b4:	10c03726 	beq	r2,r3,1202994 <__smakebuf_r+0x12c>
 12028b8:	80c0030b 	ldhu	r3,12(r16)
 12028bc:	18c20014 	ori	r3,r3,2048
 12028c0:	80c0030d 	sth	r3,12(r16)
 12028c4:	00c80004 	movi	r3,8192
 12028c8:	10c03c1e 	bne	r2,r3,12029bc <__smakebuf_r+0x154>
 12028cc:	8140038f 	ldh	r5,14(r16)
 12028d0:	8809883a 	mov	r4,r17
 12028d4:	1202e9c0 	call	1202e9c <_isatty_r>
 12028d8:	10004e26 	beq	r2,zero,1202a14 <__smakebuf_r+0x1ac>
 12028dc:	8080030b 	ldhu	r2,12(r16)
 12028e0:	04c00044 	movi	r19,1
 12028e4:	80c010c4 	addi	r3,r16,67
 12028e8:	14c4b03a 	or	r2,r2,r19
 12028ec:	8080030d 	sth	r2,12(r16)
 12028f0:	80c00015 	stw	r3,0(r16)
 12028f4:	80c00415 	stw	r3,16(r16)
 12028f8:	84c00515 	stw	r19,20(r16)
 12028fc:	04810004 	movi	r18,1024
 1202900:	00000706 	br	1202920 <__smakebuf_r+0xb8>
 1202904:	8080030b 	ldhu	r2,12(r16)
 1202908:	10c0200c 	andi	r3,r2,128
 120290c:	18001f1e 	bne	r3,zero,120298c <__smakebuf_r+0x124>
 1202910:	04810004 	movi	r18,1024
 1202914:	10820014 	ori	r2,r2,2048
 1202918:	8080030d 	sth	r2,12(r16)
 120291c:	0027883a 	mov	r19,zero
 1202920:	8809883a 	mov	r4,r17
 1202924:	900b883a 	mov	r5,r18
 1202928:	1200aa40 	call	1200aa4 <_malloc_r>
 120292c:	10002e26 	beq	r2,zero,12029e8 <__smakebuf_r+0x180>
 1202930:	80c0030b 	ldhu	r3,12(r16)
 1202934:	01004834 	movhi	r4,288
 1202938:	2107d504 	addi	r4,r4,8020
 120293c:	89000f15 	stw	r4,60(r17)
 1202940:	18c02014 	ori	r3,r3,128
 1202944:	80c0030d 	sth	r3,12(r16)
 1202948:	80800015 	stw	r2,0(r16)
 120294c:	80800415 	stw	r2,16(r16)
 1202950:	84800515 	stw	r18,20(r16)
 1202954:	98001c1e 	bne	r19,zero,12029c8 <__smakebuf_r+0x160>
 1202958:	dfc01317 	ldw	ra,76(sp)
 120295c:	dcc01217 	ldw	r19,72(sp)
 1202960:	dc801117 	ldw	r18,68(sp)
 1202964:	dc401017 	ldw	r17,64(sp)
 1202968:	dc000f17 	ldw	r16,60(sp)
 120296c:	dec01404 	addi	sp,sp,80
 1202970:	f800283a 	ret
 1202974:	288010c4 	addi	r2,r5,67
 1202978:	28800015 	stw	r2,0(r5)
 120297c:	28800415 	stw	r2,16(r5)
 1202980:	00800044 	movi	r2,1
 1202984:	28800515 	stw	r2,20(r5)
 1202988:	f800283a 	ret
 120298c:	04801004 	movi	r18,64
 1202990:	003fe006 	br	1202914 <__alt_mem_instruction_tcm+0xff202914>
 1202994:	81000a17 	ldw	r4,40(r16)
 1202998:	00c04834 	movhi	r3,288
 120299c:	18cb0704 	addi	r3,r3,11292
 12029a0:	20ffc51e 	bne	r4,r3,12028b8 <__alt_mem_instruction_tcm+0xff2028b8>
 12029a4:	80c0030b 	ldhu	r3,12(r16)
 12029a8:	01010004 	movi	r4,1024
 12029ac:	81001315 	stw	r4,76(r16)
 12029b0:	1906b03a 	or	r3,r3,r4
 12029b4:	80c0030d 	sth	r3,12(r16)
 12029b8:	003fc206 	br	12028c4 <__alt_mem_instruction_tcm+0xff2028c4>
 12029bc:	0027883a 	mov	r19,zero
 12029c0:	04810004 	movi	r18,1024
 12029c4:	003fd606 	br	1202920 <__alt_mem_instruction_tcm+0xff202920>
 12029c8:	8140038f 	ldh	r5,14(r16)
 12029cc:	8809883a 	mov	r4,r17
 12029d0:	1202e9c0 	call	1202e9c <_isatty_r>
 12029d4:	103fe026 	beq	r2,zero,1202958 <__alt_mem_instruction_tcm+0xff202958>
 12029d8:	8080030b 	ldhu	r2,12(r16)
 12029dc:	10800054 	ori	r2,r2,1
 12029e0:	8080030d 	sth	r2,12(r16)
 12029e4:	003fdc06 	br	1202958 <__alt_mem_instruction_tcm+0xff202958>
 12029e8:	8080030b 	ldhu	r2,12(r16)
 12029ec:	10c0800c 	andi	r3,r2,512
 12029f0:	183fd91e 	bne	r3,zero,1202958 <__alt_mem_instruction_tcm+0xff202958>
 12029f4:	10800094 	ori	r2,r2,2
 12029f8:	80c010c4 	addi	r3,r16,67
 12029fc:	8080030d 	sth	r2,12(r16)
 1202a00:	00800044 	movi	r2,1
 1202a04:	80c00015 	stw	r3,0(r16)
 1202a08:	80c00415 	stw	r3,16(r16)
 1202a0c:	80800515 	stw	r2,20(r16)
 1202a10:	003fd106 	br	1202958 <__alt_mem_instruction_tcm+0xff202958>
 1202a14:	04c00044 	movi	r19,1
 1202a18:	04810004 	movi	r18,1024
 1202a1c:	003fc006 	br	1202920 <__alt_mem_instruction_tcm+0xff202920>

01202a20 <memset>:
 1202a20:	20c000cc 	andi	r3,r4,3
 1202a24:	2005883a 	mov	r2,r4
 1202a28:	18004326 	beq	r3,zero,1202b38 <memset+0x118>
 1202a2c:	31ffffc4 	addi	r7,r6,-1
 1202a30:	30004026 	beq	r6,zero,1202b34 <memset+0x114>
 1202a34:	2813883a 	mov	r9,r5
 1202a38:	200d883a 	mov	r6,r4
 1202a3c:	2007883a 	mov	r3,r4
 1202a40:	00000406 	br	1202a54 <memset+0x34>
 1202a44:	3a3fffc4 	addi	r8,r7,-1
 1202a48:	31800044 	addi	r6,r6,1
 1202a4c:	38003926 	beq	r7,zero,1202b34 <memset+0x114>
 1202a50:	400f883a 	mov	r7,r8
 1202a54:	18c00044 	addi	r3,r3,1
 1202a58:	32400005 	stb	r9,0(r6)
 1202a5c:	1a0000cc 	andi	r8,r3,3
 1202a60:	403ff81e 	bne	r8,zero,1202a44 <__alt_mem_instruction_tcm+0xff202a44>
 1202a64:	010000c4 	movi	r4,3
 1202a68:	21c02d2e 	bgeu	r4,r7,1202b20 <memset+0x100>
 1202a6c:	29803fcc 	andi	r6,r5,255
 1202a70:	3008923a 	slli	r4,r6,8
 1202a74:	218cb03a 	or	r6,r4,r6
 1202a78:	3008943a 	slli	r4,r6,16
 1202a7c:	218cb03a 	or	r6,r4,r6
 1202a80:	010003c4 	movi	r4,15
 1202a84:	21c0182e 	bgeu	r4,r7,1202ae8 <memset+0xc8>
 1202a88:	3b3ffc04 	addi	r12,r7,-16
 1202a8c:	6018d13a 	srli	r12,r12,4
 1202a90:	1a000104 	addi	r8,r3,4
 1202a94:	1ac00204 	addi	r11,r3,8
 1202a98:	6008913a 	slli	r4,r12,4
 1202a9c:	1a800304 	addi	r10,r3,12
 1202aa0:	1813883a 	mov	r9,r3
 1202aa4:	21000504 	addi	r4,r4,20
 1202aa8:	1909883a 	add	r4,r3,r4
 1202aac:	49800015 	stw	r6,0(r9)
 1202ab0:	41800015 	stw	r6,0(r8)
 1202ab4:	59800015 	stw	r6,0(r11)
 1202ab8:	51800015 	stw	r6,0(r10)
 1202abc:	42000404 	addi	r8,r8,16
 1202ac0:	4a400404 	addi	r9,r9,16
 1202ac4:	5ac00404 	addi	r11,r11,16
 1202ac8:	52800404 	addi	r10,r10,16
 1202acc:	413ff71e 	bne	r8,r4,1202aac <__alt_mem_instruction_tcm+0xff202aac>
 1202ad0:	63000044 	addi	r12,r12,1
 1202ad4:	6018913a 	slli	r12,r12,4
 1202ad8:	39c003cc 	andi	r7,r7,15
 1202adc:	010000c4 	movi	r4,3
 1202ae0:	1b07883a 	add	r3,r3,r12
 1202ae4:	21c00e2e 	bgeu	r4,r7,1202b20 <memset+0x100>
 1202ae8:	1813883a 	mov	r9,r3
 1202aec:	3811883a 	mov	r8,r7
 1202af0:	010000c4 	movi	r4,3
 1202af4:	49800015 	stw	r6,0(r9)
 1202af8:	423fff04 	addi	r8,r8,-4
 1202afc:	4a400104 	addi	r9,r9,4
 1202b00:	223ffc36 	bltu	r4,r8,1202af4 <__alt_mem_instruction_tcm+0xff202af4>
 1202b04:	393fff04 	addi	r4,r7,-4
 1202b08:	2008d0ba 	srli	r4,r4,2
 1202b0c:	39c000cc 	andi	r7,r7,3
 1202b10:	21000044 	addi	r4,r4,1
 1202b14:	2109883a 	add	r4,r4,r4
 1202b18:	2109883a 	add	r4,r4,r4
 1202b1c:	1907883a 	add	r3,r3,r4
 1202b20:	38000426 	beq	r7,zero,1202b34 <memset+0x114>
 1202b24:	19cf883a 	add	r7,r3,r7
 1202b28:	19400005 	stb	r5,0(r3)
 1202b2c:	18c00044 	addi	r3,r3,1
 1202b30:	19fffd1e 	bne	r3,r7,1202b28 <__alt_mem_instruction_tcm+0xff202b28>
 1202b34:	f800283a 	ret
 1202b38:	2007883a 	mov	r3,r4
 1202b3c:	300f883a 	mov	r7,r6
 1202b40:	003fc806 	br	1202a64 <__alt_mem_instruction_tcm+0xff202a64>

01202b44 <__sread>:
 1202b44:	defffe04 	addi	sp,sp,-8
 1202b48:	dc000015 	stw	r16,0(sp)
 1202b4c:	2821883a 	mov	r16,r5
 1202b50:	2940038f 	ldh	r5,14(r5)
 1202b54:	dfc00115 	stw	ra,4(sp)
 1202b58:	1202f4c0 	call	1202f4c <_read_r>
 1202b5c:	10000716 	blt	r2,zero,1202b7c <__sread+0x38>
 1202b60:	80c01417 	ldw	r3,80(r16)
 1202b64:	1887883a 	add	r3,r3,r2
 1202b68:	80c01415 	stw	r3,80(r16)
 1202b6c:	dfc00117 	ldw	ra,4(sp)
 1202b70:	dc000017 	ldw	r16,0(sp)
 1202b74:	dec00204 	addi	sp,sp,8
 1202b78:	f800283a 	ret
 1202b7c:	80c0030b 	ldhu	r3,12(r16)
 1202b80:	18fbffcc 	andi	r3,r3,61439
 1202b84:	80c0030d 	sth	r3,12(r16)
 1202b88:	dfc00117 	ldw	ra,4(sp)
 1202b8c:	dc000017 	ldw	r16,0(sp)
 1202b90:	dec00204 	addi	sp,sp,8
 1202b94:	f800283a 	ret

01202b98 <__seofread>:
 1202b98:	0005883a 	mov	r2,zero
 1202b9c:	f800283a 	ret

01202ba0 <__swrite>:
 1202ba0:	2880030b 	ldhu	r2,12(r5)
 1202ba4:	defffb04 	addi	sp,sp,-20
 1202ba8:	dcc00315 	stw	r19,12(sp)
 1202bac:	dc800215 	stw	r18,8(sp)
 1202bb0:	dc400115 	stw	r17,4(sp)
 1202bb4:	dc000015 	stw	r16,0(sp)
 1202bb8:	dfc00415 	stw	ra,16(sp)
 1202bbc:	10c0400c 	andi	r3,r2,256
 1202bc0:	2821883a 	mov	r16,r5
 1202bc4:	2027883a 	mov	r19,r4
 1202bc8:	3025883a 	mov	r18,r6
 1202bcc:	3823883a 	mov	r17,r7
 1202bd0:	18000526 	beq	r3,zero,1202be8 <__swrite+0x48>
 1202bd4:	2940038f 	ldh	r5,14(r5)
 1202bd8:	000d883a 	mov	r6,zero
 1202bdc:	01c00084 	movi	r7,2
 1202be0:	1202ef00 	call	1202ef0 <_lseek_r>
 1202be4:	8080030b 	ldhu	r2,12(r16)
 1202be8:	8140038f 	ldh	r5,14(r16)
 1202bec:	10bbffcc 	andi	r2,r2,61439
 1202bf0:	9809883a 	mov	r4,r19
 1202bf4:	900d883a 	mov	r6,r18
 1202bf8:	880f883a 	mov	r7,r17
 1202bfc:	8080030d 	sth	r2,12(r16)
 1202c00:	dfc00417 	ldw	ra,16(sp)
 1202c04:	dcc00317 	ldw	r19,12(sp)
 1202c08:	dc800217 	ldw	r18,8(sp)
 1202c0c:	dc400117 	ldw	r17,4(sp)
 1202c10:	dc000017 	ldw	r16,0(sp)
 1202c14:	dec00504 	addi	sp,sp,20
 1202c18:	1202c801 	jmpi	1202c80 <_write_r>

01202c1c <__sseek>:
 1202c1c:	defffe04 	addi	sp,sp,-8
 1202c20:	dc000015 	stw	r16,0(sp)
 1202c24:	2821883a 	mov	r16,r5
 1202c28:	2940038f 	ldh	r5,14(r5)
 1202c2c:	dfc00115 	stw	ra,4(sp)
 1202c30:	1202ef00 	call	1202ef0 <_lseek_r>
 1202c34:	00ffffc4 	movi	r3,-1
 1202c38:	10c00826 	beq	r2,r3,1202c5c <__sseek+0x40>
 1202c3c:	80c0030b 	ldhu	r3,12(r16)
 1202c40:	80801415 	stw	r2,80(r16)
 1202c44:	18c40014 	ori	r3,r3,4096
 1202c48:	80c0030d 	sth	r3,12(r16)
 1202c4c:	dfc00117 	ldw	ra,4(sp)
 1202c50:	dc000017 	ldw	r16,0(sp)
 1202c54:	dec00204 	addi	sp,sp,8
 1202c58:	f800283a 	ret
 1202c5c:	80c0030b 	ldhu	r3,12(r16)
 1202c60:	18fbffcc 	andi	r3,r3,61439
 1202c64:	80c0030d 	sth	r3,12(r16)
 1202c68:	dfc00117 	ldw	ra,4(sp)
 1202c6c:	dc000017 	ldw	r16,0(sp)
 1202c70:	dec00204 	addi	sp,sp,8
 1202c74:	f800283a 	ret

01202c78 <__sclose>:
 1202c78:	2940038f 	ldh	r5,14(r5)
 1202c7c:	1202cdc1 	jmpi	1202cdc <_close_r>

01202c80 <_write_r>:
 1202c80:	defffd04 	addi	sp,sp,-12
 1202c84:	dc000015 	stw	r16,0(sp)
 1202c88:	04004874 	movhi	r16,289
 1202c8c:	dc400115 	stw	r17,4(sp)
 1202c90:	8426e204 	addi	r16,r16,-25720
 1202c94:	2023883a 	mov	r17,r4
 1202c98:	2809883a 	mov	r4,r5
 1202c9c:	300b883a 	mov	r5,r6
 1202ca0:	380d883a 	mov	r6,r7
 1202ca4:	dfc00215 	stw	ra,8(sp)
 1202ca8:	80000015 	stw	zero,0(r16)
 1202cac:	1203a700 	call	1203a70 <write>
 1202cb0:	00ffffc4 	movi	r3,-1
 1202cb4:	10c00526 	beq	r2,r3,1202ccc <_write_r+0x4c>
 1202cb8:	dfc00217 	ldw	ra,8(sp)
 1202cbc:	dc400117 	ldw	r17,4(sp)
 1202cc0:	dc000017 	ldw	r16,0(sp)
 1202cc4:	dec00304 	addi	sp,sp,12
 1202cc8:	f800283a 	ret
 1202ccc:	80c00017 	ldw	r3,0(r16)
 1202cd0:	183ff926 	beq	r3,zero,1202cb8 <__alt_mem_instruction_tcm+0xff202cb8>
 1202cd4:	88c00015 	stw	r3,0(r17)
 1202cd8:	003ff706 	br	1202cb8 <__alt_mem_instruction_tcm+0xff202cb8>

01202cdc <_close_r>:
 1202cdc:	defffd04 	addi	sp,sp,-12
 1202ce0:	dc000015 	stw	r16,0(sp)
 1202ce4:	04004874 	movhi	r16,289
 1202ce8:	dc400115 	stw	r17,4(sp)
 1202cec:	8426e204 	addi	r16,r16,-25720
 1202cf0:	2023883a 	mov	r17,r4
 1202cf4:	2809883a 	mov	r4,r5
 1202cf8:	dfc00215 	stw	ra,8(sp)
 1202cfc:	80000015 	stw	zero,0(r16)
 1202d00:	1202ff80 	call	1202ff8 <close>
 1202d04:	00ffffc4 	movi	r3,-1
 1202d08:	10c00526 	beq	r2,r3,1202d20 <_close_r+0x44>
 1202d0c:	dfc00217 	ldw	ra,8(sp)
 1202d10:	dc400117 	ldw	r17,4(sp)
 1202d14:	dc000017 	ldw	r16,0(sp)
 1202d18:	dec00304 	addi	sp,sp,12
 1202d1c:	f800283a 	ret
 1202d20:	80c00017 	ldw	r3,0(r16)
 1202d24:	183ff926 	beq	r3,zero,1202d0c <__alt_mem_instruction_tcm+0xff202d0c>
 1202d28:	88c00015 	stw	r3,0(r17)
 1202d2c:	003ff706 	br	1202d0c <__alt_mem_instruction_tcm+0xff202d0c>

01202d30 <_fclose_r>:
 1202d30:	28003226 	beq	r5,zero,1202dfc <_fclose_r+0xcc>
 1202d34:	defffc04 	addi	sp,sp,-16
 1202d38:	dc400115 	stw	r17,4(sp)
 1202d3c:	2023883a 	mov	r17,r4
 1202d40:	dc000015 	stw	r16,0(sp)
 1202d44:	dfc00315 	stw	ra,12(sp)
 1202d48:	dc800215 	stw	r18,8(sp)
 1202d4c:	2821883a 	mov	r16,r5
 1202d50:	12022a40 	call	12022a4 <__sfp_lock_acquire>
 1202d54:	88000226 	beq	r17,zero,1202d60 <_fclose_r+0x30>
 1202d58:	88800e17 	ldw	r2,56(r17)
 1202d5c:	10002926 	beq	r2,zero,1202e04 <_fclose_r+0xd4>
 1202d60:	8080030f 	ldh	r2,12(r16)
 1202d64:	10002226 	beq	r2,zero,1202df0 <_fclose_r+0xc0>
 1202d68:	8809883a 	mov	r4,r17
 1202d6c:	800b883a 	mov	r5,r16
 1202d70:	1201cec0 	call	1201cec <_fflush_r>
 1202d74:	1025883a 	mov	r18,r2
 1202d78:	80800b17 	ldw	r2,44(r16)
 1202d7c:	10000426 	beq	r2,zero,1202d90 <_fclose_r+0x60>
 1202d80:	81400717 	ldw	r5,28(r16)
 1202d84:	8809883a 	mov	r4,r17
 1202d88:	103ee83a 	callr	r2
 1202d8c:	10002616 	blt	r2,zero,1202e28 <_fclose_r+0xf8>
 1202d90:	8080030b 	ldhu	r2,12(r16)
 1202d94:	1080200c 	andi	r2,r2,128
 1202d98:	10001f1e 	bne	r2,zero,1202e18 <_fclose_r+0xe8>
 1202d9c:	81400c17 	ldw	r5,48(r16)
 1202da0:	28000526 	beq	r5,zero,1202db8 <_fclose_r+0x88>
 1202da4:	80801004 	addi	r2,r16,64
 1202da8:	28800226 	beq	r5,r2,1202db4 <_fclose_r+0x84>
 1202dac:	8809883a 	mov	r4,r17
 1202db0:	12024080 	call	1202408 <_free_r>
 1202db4:	80000c15 	stw	zero,48(r16)
 1202db8:	81401117 	ldw	r5,68(r16)
 1202dbc:	28000326 	beq	r5,zero,1202dcc <_fclose_r+0x9c>
 1202dc0:	8809883a 	mov	r4,r17
 1202dc4:	12024080 	call	1202408 <_free_r>
 1202dc8:	80001115 	stw	zero,68(r16)
 1202dcc:	8000030d 	sth	zero,12(r16)
 1202dd0:	12022a80 	call	12022a8 <__sfp_lock_release>
 1202dd4:	9005883a 	mov	r2,r18
 1202dd8:	dfc00317 	ldw	ra,12(sp)
 1202ddc:	dc800217 	ldw	r18,8(sp)
 1202de0:	dc400117 	ldw	r17,4(sp)
 1202de4:	dc000017 	ldw	r16,0(sp)
 1202de8:	dec00404 	addi	sp,sp,16
 1202dec:	f800283a 	ret
 1202df0:	12022a80 	call	12022a8 <__sfp_lock_release>
 1202df4:	0005883a 	mov	r2,zero
 1202df8:	003ff706 	br	1202dd8 <__alt_mem_instruction_tcm+0xff202dd8>
 1202dfc:	0005883a 	mov	r2,zero
 1202e00:	f800283a 	ret
 1202e04:	8809883a 	mov	r4,r17
 1202e08:	12022940 	call	1202294 <__sinit>
 1202e0c:	8080030f 	ldh	r2,12(r16)
 1202e10:	103fd51e 	bne	r2,zero,1202d68 <__alt_mem_instruction_tcm+0xff202d68>
 1202e14:	003ff606 	br	1202df0 <__alt_mem_instruction_tcm+0xff202df0>
 1202e18:	81400417 	ldw	r5,16(r16)
 1202e1c:	8809883a 	mov	r4,r17
 1202e20:	12024080 	call	1202408 <_free_r>
 1202e24:	003fdd06 	br	1202d9c <__alt_mem_instruction_tcm+0xff202d9c>
 1202e28:	04bfffc4 	movi	r18,-1
 1202e2c:	003fd806 	br	1202d90 <__alt_mem_instruction_tcm+0xff202d90>

01202e30 <fclose>:
 1202e30:	00804874 	movhi	r2,289
 1202e34:	10a6cf04 	addi	r2,r2,-25796
 1202e38:	200b883a 	mov	r5,r4
 1202e3c:	11000017 	ldw	r4,0(r2)
 1202e40:	1202d301 	jmpi	1202d30 <_fclose_r>

01202e44 <_fstat_r>:
 1202e44:	defffd04 	addi	sp,sp,-12
 1202e48:	dc000015 	stw	r16,0(sp)
 1202e4c:	04004874 	movhi	r16,289
 1202e50:	dc400115 	stw	r17,4(sp)
 1202e54:	8426e204 	addi	r16,r16,-25720
 1202e58:	2023883a 	mov	r17,r4
 1202e5c:	2809883a 	mov	r4,r5
 1202e60:	300b883a 	mov	r5,r6
 1202e64:	dfc00215 	stw	ra,8(sp)
 1202e68:	80000015 	stw	zero,0(r16)
 1202e6c:	12031440 	call	1203144 <fstat>
 1202e70:	00ffffc4 	movi	r3,-1
 1202e74:	10c00526 	beq	r2,r3,1202e8c <_fstat_r+0x48>
 1202e78:	dfc00217 	ldw	ra,8(sp)
 1202e7c:	dc400117 	ldw	r17,4(sp)
 1202e80:	dc000017 	ldw	r16,0(sp)
 1202e84:	dec00304 	addi	sp,sp,12
 1202e88:	f800283a 	ret
 1202e8c:	80c00017 	ldw	r3,0(r16)
 1202e90:	183ff926 	beq	r3,zero,1202e78 <__alt_mem_instruction_tcm+0xff202e78>
 1202e94:	88c00015 	stw	r3,0(r17)
 1202e98:	003ff706 	br	1202e78 <__alt_mem_instruction_tcm+0xff202e78>

01202e9c <_isatty_r>:
 1202e9c:	defffd04 	addi	sp,sp,-12
 1202ea0:	dc000015 	stw	r16,0(sp)
 1202ea4:	04004874 	movhi	r16,289
 1202ea8:	dc400115 	stw	r17,4(sp)
 1202eac:	8426e204 	addi	r16,r16,-25720
 1202eb0:	2023883a 	mov	r17,r4
 1202eb4:	2809883a 	mov	r4,r5
 1202eb8:	dfc00215 	stw	ra,8(sp)
 1202ebc:	80000015 	stw	zero,0(r16)
 1202ec0:	12035140 	call	1203514 <isatty>
 1202ec4:	00ffffc4 	movi	r3,-1
 1202ec8:	10c00526 	beq	r2,r3,1202ee0 <_isatty_r+0x44>
 1202ecc:	dfc00217 	ldw	ra,8(sp)
 1202ed0:	dc400117 	ldw	r17,4(sp)
 1202ed4:	dc000017 	ldw	r16,0(sp)
 1202ed8:	dec00304 	addi	sp,sp,12
 1202edc:	f800283a 	ret
 1202ee0:	80c00017 	ldw	r3,0(r16)
 1202ee4:	183ff926 	beq	r3,zero,1202ecc <__alt_mem_instruction_tcm+0xff202ecc>
 1202ee8:	88c00015 	stw	r3,0(r17)
 1202eec:	003ff706 	br	1202ecc <__alt_mem_instruction_tcm+0xff202ecc>

01202ef0 <_lseek_r>:
 1202ef0:	defffd04 	addi	sp,sp,-12
 1202ef4:	dc000015 	stw	r16,0(sp)
 1202ef8:	04004874 	movhi	r16,289
 1202efc:	dc400115 	stw	r17,4(sp)
 1202f00:	8426e204 	addi	r16,r16,-25720
 1202f04:	2023883a 	mov	r17,r4
 1202f08:	2809883a 	mov	r4,r5
 1202f0c:	300b883a 	mov	r5,r6
 1202f10:	380d883a 	mov	r6,r7
 1202f14:	dfc00215 	stw	ra,8(sp)
 1202f18:	80000015 	stw	zero,0(r16)
 1202f1c:	12036080 	call	1203608 <lseek>
 1202f20:	00ffffc4 	movi	r3,-1
 1202f24:	10c00526 	beq	r2,r3,1202f3c <_lseek_r+0x4c>
 1202f28:	dfc00217 	ldw	ra,8(sp)
 1202f2c:	dc400117 	ldw	r17,4(sp)
 1202f30:	dc000017 	ldw	r16,0(sp)
 1202f34:	dec00304 	addi	sp,sp,12
 1202f38:	f800283a 	ret
 1202f3c:	80c00017 	ldw	r3,0(r16)
 1202f40:	183ff926 	beq	r3,zero,1202f28 <__alt_mem_instruction_tcm+0xff202f28>
 1202f44:	88c00015 	stw	r3,0(r17)
 1202f48:	003ff706 	br	1202f28 <__alt_mem_instruction_tcm+0xff202f28>

01202f4c <_read_r>:
 1202f4c:	defffd04 	addi	sp,sp,-12
 1202f50:	dc000015 	stw	r16,0(sp)
 1202f54:	04004874 	movhi	r16,289
 1202f58:	dc400115 	stw	r17,4(sp)
 1202f5c:	8426e204 	addi	r16,r16,-25720
 1202f60:	2023883a 	mov	r17,r4
 1202f64:	2809883a 	mov	r4,r5
 1202f68:	300b883a 	mov	r5,r6
 1202f6c:	380d883a 	mov	r6,r7
 1202f70:	dfc00215 	stw	ra,8(sp)
 1202f74:	80000015 	stw	zero,0(r16)
 1202f78:	12037e40 	call	12037e4 <read>
 1202f7c:	00ffffc4 	movi	r3,-1
 1202f80:	10c00526 	beq	r2,r3,1202f98 <_read_r+0x4c>
 1202f84:	dfc00217 	ldw	ra,8(sp)
 1202f88:	dc400117 	ldw	r17,4(sp)
 1202f8c:	dc000017 	ldw	r16,0(sp)
 1202f90:	dec00304 	addi	sp,sp,12
 1202f94:	f800283a 	ret
 1202f98:	80c00017 	ldw	r3,0(r16)
 1202f9c:	183ff926 	beq	r3,zero,1202f84 <__alt_mem_instruction_tcm+0xff202f84>
 1202fa0:	88c00015 	stw	r3,0(r17)
 1202fa4:	003ff706 	br	1202f84 <__alt_mem_instruction_tcm+0xff202f84>

01202fa8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1202fa8:	defffe04 	addi	sp,sp,-8
 1202fac:	dfc00115 	stw	ra,4(sp)
 1202fb0:	df000015 	stw	fp,0(sp)
 1202fb4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1202fb8:	00804874 	movhi	r2,289
 1202fbc:	10a6d704 	addi	r2,r2,-25764
 1202fc0:	10800017 	ldw	r2,0(r2)
 1202fc4:	10000526 	beq	r2,zero,1202fdc <alt_get_errno+0x34>
 1202fc8:	00804874 	movhi	r2,289
 1202fcc:	10a6d704 	addi	r2,r2,-25764
 1202fd0:	10800017 	ldw	r2,0(r2)
 1202fd4:	103ee83a 	callr	r2
 1202fd8:	00000206 	br	1202fe4 <alt_get_errno+0x3c>
 1202fdc:	00804874 	movhi	r2,289
 1202fe0:	10a6e204 	addi	r2,r2,-25720
}
 1202fe4:	e037883a 	mov	sp,fp
 1202fe8:	dfc00117 	ldw	ra,4(sp)
 1202fec:	df000017 	ldw	fp,0(sp)
 1202ff0:	dec00204 	addi	sp,sp,8
 1202ff4:	f800283a 	ret

01202ff8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 1202ff8:	defffb04 	addi	sp,sp,-20
 1202ffc:	dfc00415 	stw	ra,16(sp)
 1203000:	df000315 	stw	fp,12(sp)
 1203004:	df000304 	addi	fp,sp,12
 1203008:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 120300c:	e0bfff17 	ldw	r2,-4(fp)
 1203010:	10000616 	blt	r2,zero,120302c <close+0x34>
 1203014:	e0bfff17 	ldw	r2,-4(fp)
 1203018:	10c00324 	muli	r3,r2,12
 120301c:	00804874 	movhi	r2,289
 1203020:	10a21f04 	addi	r2,r2,-30596
 1203024:	1885883a 	add	r2,r3,r2
 1203028:	00000106 	br	1203030 <close+0x38>
 120302c:	0005883a 	mov	r2,zero
 1203030:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 1203034:	e0bffd17 	ldw	r2,-12(fp)
 1203038:	10001926 	beq	r2,zero,12030a0 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 120303c:	e0bffd17 	ldw	r2,-12(fp)
 1203040:	10800017 	ldw	r2,0(r2)
 1203044:	10800417 	ldw	r2,16(r2)
 1203048:	10000626 	beq	r2,zero,1203064 <close+0x6c>
 120304c:	e0bffd17 	ldw	r2,-12(fp)
 1203050:	10800017 	ldw	r2,0(r2)
 1203054:	10800417 	ldw	r2,16(r2)
 1203058:	e13ffd17 	ldw	r4,-12(fp)
 120305c:	103ee83a 	callr	r2
 1203060:	00000106 	br	1203068 <close+0x70>
 1203064:	0005883a 	mov	r2,zero
 1203068:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 120306c:	e13fff17 	ldw	r4,-4(fp)
 1203070:	12038e00 	call	12038e0 <alt_release_fd>
    if (rval < 0)
 1203074:	e0bffe17 	ldw	r2,-8(fp)
 1203078:	1000070e 	bge	r2,zero,1203098 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 120307c:	1202fa80 	call	1202fa8 <alt_get_errno>
 1203080:	1007883a 	mov	r3,r2
 1203084:	e0bffe17 	ldw	r2,-8(fp)
 1203088:	0085c83a 	sub	r2,zero,r2
 120308c:	18800015 	stw	r2,0(r3)
      return -1;
 1203090:	00bfffc4 	movi	r2,-1
 1203094:	00000706 	br	12030b4 <close+0xbc>
    }
    return 0;
 1203098:	0005883a 	mov	r2,zero
 120309c:	00000506 	br	12030b4 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 12030a0:	1202fa80 	call	1202fa8 <alt_get_errno>
 12030a4:	1007883a 	mov	r3,r2
 12030a8:	00801444 	movi	r2,81
 12030ac:	18800015 	stw	r2,0(r3)
    return -1;
 12030b0:	00bfffc4 	movi	r2,-1
  }
}
 12030b4:	e037883a 	mov	sp,fp
 12030b8:	dfc00117 	ldw	ra,4(sp)
 12030bc:	df000017 	ldw	fp,0(sp)
 12030c0:	dec00204 	addi	sp,sp,8
 12030c4:	f800283a 	ret

012030c8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 12030c8:	defffc04 	addi	sp,sp,-16
 12030cc:	df000315 	stw	fp,12(sp)
 12030d0:	df000304 	addi	fp,sp,12
 12030d4:	e13ffd15 	stw	r4,-12(fp)
 12030d8:	e17ffe15 	stw	r5,-8(fp)
 12030dc:	e1bfff15 	stw	r6,-4(fp)
  return len;
 12030e0:	e0bfff17 	ldw	r2,-4(fp)
}
 12030e4:	e037883a 	mov	sp,fp
 12030e8:	df000017 	ldw	fp,0(sp)
 12030ec:	dec00104 	addi	sp,sp,4
 12030f0:	f800283a 	ret

012030f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 12030f4:	defffe04 	addi	sp,sp,-8
 12030f8:	dfc00115 	stw	ra,4(sp)
 12030fc:	df000015 	stw	fp,0(sp)
 1203100:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1203104:	00804874 	movhi	r2,289
 1203108:	10a6d704 	addi	r2,r2,-25764
 120310c:	10800017 	ldw	r2,0(r2)
 1203110:	10000526 	beq	r2,zero,1203128 <alt_get_errno+0x34>
 1203114:	00804874 	movhi	r2,289
 1203118:	10a6d704 	addi	r2,r2,-25764
 120311c:	10800017 	ldw	r2,0(r2)
 1203120:	103ee83a 	callr	r2
 1203124:	00000206 	br	1203130 <alt_get_errno+0x3c>
 1203128:	00804874 	movhi	r2,289
 120312c:	10a6e204 	addi	r2,r2,-25720
}
 1203130:	e037883a 	mov	sp,fp
 1203134:	dfc00117 	ldw	ra,4(sp)
 1203138:	df000017 	ldw	fp,0(sp)
 120313c:	dec00204 	addi	sp,sp,8
 1203140:	f800283a 	ret

01203144 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 1203144:	defffb04 	addi	sp,sp,-20
 1203148:	dfc00415 	stw	ra,16(sp)
 120314c:	df000315 	stw	fp,12(sp)
 1203150:	df000304 	addi	fp,sp,12
 1203154:	e13ffe15 	stw	r4,-8(fp)
 1203158:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 120315c:	e0bffe17 	ldw	r2,-8(fp)
 1203160:	10000616 	blt	r2,zero,120317c <fstat+0x38>
 1203164:	e0bffe17 	ldw	r2,-8(fp)
 1203168:	10c00324 	muli	r3,r2,12
 120316c:	00804874 	movhi	r2,289
 1203170:	10a21f04 	addi	r2,r2,-30596
 1203174:	1885883a 	add	r2,r3,r2
 1203178:	00000106 	br	1203180 <fstat+0x3c>
 120317c:	0005883a 	mov	r2,zero
 1203180:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 1203184:	e0bffd17 	ldw	r2,-12(fp)
 1203188:	10001026 	beq	r2,zero,12031cc <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 120318c:	e0bffd17 	ldw	r2,-12(fp)
 1203190:	10800017 	ldw	r2,0(r2)
 1203194:	10800817 	ldw	r2,32(r2)
 1203198:	10000726 	beq	r2,zero,12031b8 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 120319c:	e0bffd17 	ldw	r2,-12(fp)
 12031a0:	10800017 	ldw	r2,0(r2)
 12031a4:	10800817 	ldw	r2,32(r2)
 12031a8:	e13ffd17 	ldw	r4,-12(fp)
 12031ac:	e17fff17 	ldw	r5,-4(fp)
 12031b0:	103ee83a 	callr	r2
 12031b4:	00000a06 	br	12031e0 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 12031b8:	e0bfff17 	ldw	r2,-4(fp)
 12031bc:	00c80004 	movi	r3,8192
 12031c0:	10c00115 	stw	r3,4(r2)
      return 0;
 12031c4:	0005883a 	mov	r2,zero
 12031c8:	00000506 	br	12031e0 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 12031cc:	12030f40 	call	12030f4 <alt_get_errno>
 12031d0:	1007883a 	mov	r3,r2
 12031d4:	00801444 	movi	r2,81
 12031d8:	18800015 	stw	r2,0(r3)
    return -1;
 12031dc:	00bfffc4 	movi	r2,-1
  }
}
 12031e0:	e037883a 	mov	sp,fp
 12031e4:	dfc00117 	ldw	ra,4(sp)
 12031e8:	df000017 	ldw	fp,0(sp)
 12031ec:	dec00204 	addi	sp,sp,8
 12031f0:	f800283a 	ret

012031f4 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 12031f4:	defff904 	addi	sp,sp,-28
 12031f8:	dfc00615 	stw	ra,24(sp)
 12031fc:	df000515 	stw	fp,20(sp)
 1203200:	df000504 	addi	fp,sp,20
 1203204:	e13ffc15 	stw	r4,-16(fp)
 1203208:	e17ffd15 	stw	r5,-12(fp)
 120320c:	e1bffe15 	stw	r6,-8(fp)
 1203210:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 1203214:	e0800217 	ldw	r2,8(fp)
 1203218:	d8800015 	stw	r2,0(sp)
 120321c:	e13ffc17 	ldw	r4,-16(fp)
 1203220:	e17ffd17 	ldw	r5,-12(fp)
 1203224:	e1bffe17 	ldw	r6,-8(fp)
 1203228:	e1ffff17 	ldw	r7,-4(fp)
 120322c:	12033d40 	call	12033d4 <alt_iic_isr_register>
}  
 1203230:	e037883a 	mov	sp,fp
 1203234:	dfc00117 	ldw	ra,4(sp)
 1203238:	df000017 	ldw	fp,0(sp)
 120323c:	dec00204 	addi	sp,sp,8
 1203240:	f800283a 	ret

01203244 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 1203244:	defff904 	addi	sp,sp,-28
 1203248:	df000615 	stw	fp,24(sp)
 120324c:	df000604 	addi	fp,sp,24
 1203250:	e13ffe15 	stw	r4,-8(fp)
 1203254:	e17fff15 	stw	r5,-4(fp)
 1203258:	e0bfff17 	ldw	r2,-4(fp)
 120325c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1203260:	0005303a 	rdctl	r2,status
 1203264:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1203268:	e0fffb17 	ldw	r3,-20(fp)
 120326c:	00bfff84 	movi	r2,-2
 1203270:	1884703a 	and	r2,r3,r2
 1203274:	1001703a 	wrctl	status,r2
  
  return context;
 1203278:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 120327c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 1203280:	e0bffa17 	ldw	r2,-24(fp)
 1203284:	00c00044 	movi	r3,1
 1203288:	1884983a 	sll	r2,r3,r2
 120328c:	1007883a 	mov	r3,r2
 1203290:	00804874 	movhi	r2,289
 1203294:	10a6e304 	addi	r2,r2,-25716
 1203298:	10800017 	ldw	r2,0(r2)
 120329c:	1886b03a 	or	r3,r3,r2
 12032a0:	00804874 	movhi	r2,289
 12032a4:	10a6e304 	addi	r2,r2,-25716
 12032a8:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 12032ac:	00804874 	movhi	r2,289
 12032b0:	10a6e304 	addi	r2,r2,-25716
 12032b4:	10800017 	ldw	r2,0(r2)
 12032b8:	100170fa 	wrctl	ienable,r2
 12032bc:	e0bffc17 	ldw	r2,-16(fp)
 12032c0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 12032c4:	e0bffd17 	ldw	r2,-12(fp)
 12032c8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 12032cc:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 12032d0:	0001883a 	nop
}
 12032d4:	e037883a 	mov	sp,fp
 12032d8:	df000017 	ldw	fp,0(sp)
 12032dc:	dec00104 	addi	sp,sp,4
 12032e0:	f800283a 	ret

012032e4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 12032e4:	defff904 	addi	sp,sp,-28
 12032e8:	df000615 	stw	fp,24(sp)
 12032ec:	df000604 	addi	fp,sp,24
 12032f0:	e13ffe15 	stw	r4,-8(fp)
 12032f4:	e17fff15 	stw	r5,-4(fp)
 12032f8:	e0bfff17 	ldw	r2,-4(fp)
 12032fc:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1203300:	0005303a 	rdctl	r2,status
 1203304:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1203308:	e0fffb17 	ldw	r3,-20(fp)
 120330c:	00bfff84 	movi	r2,-2
 1203310:	1884703a 	and	r2,r3,r2
 1203314:	1001703a 	wrctl	status,r2
  
  return context;
 1203318:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 120331c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 1203320:	e0bffa17 	ldw	r2,-24(fp)
 1203324:	00c00044 	movi	r3,1
 1203328:	1884983a 	sll	r2,r3,r2
 120332c:	0084303a 	nor	r2,zero,r2
 1203330:	1007883a 	mov	r3,r2
 1203334:	00804874 	movhi	r2,289
 1203338:	10a6e304 	addi	r2,r2,-25716
 120333c:	10800017 	ldw	r2,0(r2)
 1203340:	1886703a 	and	r3,r3,r2
 1203344:	00804874 	movhi	r2,289
 1203348:	10a6e304 	addi	r2,r2,-25716
 120334c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1203350:	00804874 	movhi	r2,289
 1203354:	10a6e304 	addi	r2,r2,-25716
 1203358:	10800017 	ldw	r2,0(r2)
 120335c:	100170fa 	wrctl	ienable,r2
 1203360:	e0bffc17 	ldw	r2,-16(fp)
 1203364:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1203368:	e0bffd17 	ldw	r2,-12(fp)
 120336c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1203370:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 1203374:	0001883a 	nop
}
 1203378:	e037883a 	mov	sp,fp
 120337c:	df000017 	ldw	fp,0(sp)
 1203380:	dec00104 	addi	sp,sp,4
 1203384:	f800283a 	ret

01203388 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 1203388:	defffc04 	addi	sp,sp,-16
 120338c:	df000315 	stw	fp,12(sp)
 1203390:	df000304 	addi	fp,sp,12
 1203394:	e13ffe15 	stw	r4,-8(fp)
 1203398:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 120339c:	000530fa 	rdctl	r2,ienable
 12033a0:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 12033a4:	e0bfff17 	ldw	r2,-4(fp)
 12033a8:	00c00044 	movi	r3,1
 12033ac:	1884983a 	sll	r2,r3,r2
 12033b0:	1007883a 	mov	r3,r2
 12033b4:	e0bffd17 	ldw	r2,-12(fp)
 12033b8:	1884703a 	and	r2,r3,r2
 12033bc:	1004c03a 	cmpne	r2,r2,zero
 12033c0:	10803fcc 	andi	r2,r2,255
}
 12033c4:	e037883a 	mov	sp,fp
 12033c8:	df000017 	ldw	fp,0(sp)
 12033cc:	dec00104 	addi	sp,sp,4
 12033d0:	f800283a 	ret

012033d4 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 12033d4:	defff504 	addi	sp,sp,-44
 12033d8:	dfc00a15 	stw	ra,40(sp)
 12033dc:	df000915 	stw	fp,36(sp)
 12033e0:	df000904 	addi	fp,sp,36
 12033e4:	e13ffc15 	stw	r4,-16(fp)
 12033e8:	e17ffd15 	stw	r5,-12(fp)
 12033ec:	e1bffe15 	stw	r6,-8(fp)
 12033f0:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 12033f4:	00bffa84 	movi	r2,-22
 12033f8:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 12033fc:	e0bffd17 	ldw	r2,-12(fp)
 1203400:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 1203404:	e0bff817 	ldw	r2,-32(fp)
 1203408:	10800808 	cmpgei	r2,r2,32
 120340c:	1000271e 	bne	r2,zero,12034ac <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1203410:	0005303a 	rdctl	r2,status
 1203414:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1203418:	e0fffa17 	ldw	r3,-24(fp)
 120341c:	00bfff84 	movi	r2,-2
 1203420:	1884703a 	and	r2,r3,r2
 1203424:	1001703a 	wrctl	status,r2
  
  return context;
 1203428:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 120342c:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
 1203430:	00804874 	movhi	r2,289
 1203434:	10a6f404 	addi	r2,r2,-25648
 1203438:	e0fff817 	ldw	r3,-32(fp)
 120343c:	180690fa 	slli	r3,r3,3
 1203440:	10c5883a 	add	r2,r2,r3
 1203444:	e0fffe17 	ldw	r3,-8(fp)
 1203448:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 120344c:	00804874 	movhi	r2,289
 1203450:	10a6f404 	addi	r2,r2,-25648
 1203454:	e0fff817 	ldw	r3,-32(fp)
 1203458:	180690fa 	slli	r3,r3,3
 120345c:	10c5883a 	add	r2,r2,r3
 1203460:	10800104 	addi	r2,r2,4
 1203464:	e0ffff17 	ldw	r3,-4(fp)
 1203468:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 120346c:	e0bffe17 	ldw	r2,-8(fp)
 1203470:	10000526 	beq	r2,zero,1203488 <alt_iic_isr_register+0xb4>
 1203474:	e0bff817 	ldw	r2,-32(fp)
 1203478:	e13ffc17 	ldw	r4,-16(fp)
 120347c:	100b883a 	mov	r5,r2
 1203480:	12032440 	call	1203244 <alt_ic_irq_enable>
 1203484:	00000406 	br	1203498 <alt_iic_isr_register+0xc4>
 1203488:	e0bff817 	ldw	r2,-32(fp)
 120348c:	e13ffc17 	ldw	r4,-16(fp)
 1203490:	100b883a 	mov	r5,r2
 1203494:	12032e40 	call	12032e4 <alt_ic_irq_disable>
 1203498:	e0bff715 	stw	r2,-36(fp)
 120349c:	e0bff917 	ldw	r2,-28(fp)
 12034a0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 12034a4:	e0bffb17 	ldw	r2,-20(fp)
 12034a8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 12034ac:	e0bff717 	ldw	r2,-36(fp)
}
 12034b0:	e037883a 	mov	sp,fp
 12034b4:	dfc00117 	ldw	ra,4(sp)
 12034b8:	df000017 	ldw	fp,0(sp)
 12034bc:	dec00204 	addi	sp,sp,8
 12034c0:	f800283a 	ret

012034c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 12034c4:	defffe04 	addi	sp,sp,-8
 12034c8:	dfc00115 	stw	ra,4(sp)
 12034cc:	df000015 	stw	fp,0(sp)
 12034d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 12034d4:	00804874 	movhi	r2,289
 12034d8:	10a6d704 	addi	r2,r2,-25764
 12034dc:	10800017 	ldw	r2,0(r2)
 12034e0:	10000526 	beq	r2,zero,12034f8 <alt_get_errno+0x34>
 12034e4:	00804874 	movhi	r2,289
 12034e8:	10a6d704 	addi	r2,r2,-25764
 12034ec:	10800017 	ldw	r2,0(r2)
 12034f0:	103ee83a 	callr	r2
 12034f4:	00000206 	br	1203500 <alt_get_errno+0x3c>
 12034f8:	00804874 	movhi	r2,289
 12034fc:	10a6e204 	addi	r2,r2,-25720
}
 1203500:	e037883a 	mov	sp,fp
 1203504:	dfc00117 	ldw	ra,4(sp)
 1203508:	df000017 	ldw	fp,0(sp)
 120350c:	dec00204 	addi	sp,sp,8
 1203510:	f800283a 	ret

01203514 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 1203514:	deffed04 	addi	sp,sp,-76
 1203518:	dfc01215 	stw	ra,72(sp)
 120351c:	df001115 	stw	fp,68(sp)
 1203520:	df001104 	addi	fp,sp,68
 1203524:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1203528:	e0bfff17 	ldw	r2,-4(fp)
 120352c:	10000616 	blt	r2,zero,1203548 <isatty+0x34>
 1203530:	e0bfff17 	ldw	r2,-4(fp)
 1203534:	10c00324 	muli	r3,r2,12
 1203538:	00804874 	movhi	r2,289
 120353c:	10a21f04 	addi	r2,r2,-30596
 1203540:	1885883a 	add	r2,r3,r2
 1203544:	00000106 	br	120354c <isatty+0x38>
 1203548:	0005883a 	mov	r2,zero
 120354c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 1203550:	e0bfef17 	ldw	r2,-68(fp)
 1203554:	10000e26 	beq	r2,zero,1203590 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 1203558:	e0bfef17 	ldw	r2,-68(fp)
 120355c:	10800017 	ldw	r2,0(r2)
 1203560:	10800817 	ldw	r2,32(r2)
 1203564:	1000021e 	bne	r2,zero,1203570 <isatty+0x5c>
    {
      return 1;
 1203568:	00800044 	movi	r2,1
 120356c:	00000d06 	br	12035a4 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 1203570:	e0bff004 	addi	r2,fp,-64
 1203574:	e13fff17 	ldw	r4,-4(fp)
 1203578:	100b883a 	mov	r5,r2
 120357c:	12031440 	call	1203144 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 1203580:	e0bff117 	ldw	r2,-60(fp)
 1203584:	10880020 	cmpeqi	r2,r2,8192
 1203588:	10803fcc 	andi	r2,r2,255
 120358c:	00000506 	br	12035a4 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1203590:	12034c40 	call	12034c4 <alt_get_errno>
 1203594:	1007883a 	mov	r3,r2
 1203598:	00801444 	movi	r2,81
 120359c:	18800015 	stw	r2,0(r3)
    return 0;
 12035a0:	0005883a 	mov	r2,zero
  }
}
 12035a4:	e037883a 	mov	sp,fp
 12035a8:	dfc00117 	ldw	ra,4(sp)
 12035ac:	df000017 	ldw	fp,0(sp)
 12035b0:	dec00204 	addi	sp,sp,8
 12035b4:	f800283a 	ret

012035b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 12035b8:	defffe04 	addi	sp,sp,-8
 12035bc:	dfc00115 	stw	ra,4(sp)
 12035c0:	df000015 	stw	fp,0(sp)
 12035c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 12035c8:	00804874 	movhi	r2,289
 12035cc:	10a6d704 	addi	r2,r2,-25764
 12035d0:	10800017 	ldw	r2,0(r2)
 12035d4:	10000526 	beq	r2,zero,12035ec <alt_get_errno+0x34>
 12035d8:	00804874 	movhi	r2,289
 12035dc:	10a6d704 	addi	r2,r2,-25764
 12035e0:	10800017 	ldw	r2,0(r2)
 12035e4:	103ee83a 	callr	r2
 12035e8:	00000206 	br	12035f4 <alt_get_errno+0x3c>
 12035ec:	00804874 	movhi	r2,289
 12035f0:	10a6e204 	addi	r2,r2,-25720
}
 12035f4:	e037883a 	mov	sp,fp
 12035f8:	dfc00117 	ldw	ra,4(sp)
 12035fc:	df000017 	ldw	fp,0(sp)
 1203600:	dec00204 	addi	sp,sp,8
 1203604:	f800283a 	ret

01203608 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 1203608:	defff904 	addi	sp,sp,-28
 120360c:	dfc00615 	stw	ra,24(sp)
 1203610:	df000515 	stw	fp,20(sp)
 1203614:	df000504 	addi	fp,sp,20
 1203618:	e13ffd15 	stw	r4,-12(fp)
 120361c:	e17ffe15 	stw	r5,-8(fp)
 1203620:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 1203624:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1203628:	e0bffd17 	ldw	r2,-12(fp)
 120362c:	10000616 	blt	r2,zero,1203648 <lseek+0x40>
 1203630:	e0bffd17 	ldw	r2,-12(fp)
 1203634:	10c00324 	muli	r3,r2,12
 1203638:	00804874 	movhi	r2,289
 120363c:	10a21f04 	addi	r2,r2,-30596
 1203640:	1885883a 	add	r2,r3,r2
 1203644:	00000106 	br	120364c <lseek+0x44>
 1203648:	0005883a 	mov	r2,zero
 120364c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 1203650:	e0bffc17 	ldw	r2,-16(fp)
 1203654:	10001026 	beq	r2,zero,1203698 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 1203658:	e0bffc17 	ldw	r2,-16(fp)
 120365c:	10800017 	ldw	r2,0(r2)
 1203660:	10800717 	ldw	r2,28(r2)
 1203664:	10000926 	beq	r2,zero,120368c <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 1203668:	e0bffc17 	ldw	r2,-16(fp)
 120366c:	10800017 	ldw	r2,0(r2)
 1203670:	10800717 	ldw	r2,28(r2)
 1203674:	e13ffc17 	ldw	r4,-16(fp)
 1203678:	e17ffe17 	ldw	r5,-8(fp)
 120367c:	e1bfff17 	ldw	r6,-4(fp)
 1203680:	103ee83a 	callr	r2
 1203684:	e0bffb15 	stw	r2,-20(fp)
 1203688:	00000506 	br	12036a0 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 120368c:	00bfde84 	movi	r2,-134
 1203690:	e0bffb15 	stw	r2,-20(fp)
 1203694:	00000206 	br	12036a0 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 1203698:	00bfebc4 	movi	r2,-81
 120369c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 12036a0:	e0bffb17 	ldw	r2,-20(fp)
 12036a4:	1000070e 	bge	r2,zero,12036c4 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 12036a8:	12035b80 	call	12035b8 <alt_get_errno>
 12036ac:	1007883a 	mov	r3,r2
 12036b0:	e0bffb17 	ldw	r2,-20(fp)
 12036b4:	0085c83a 	sub	r2,zero,r2
 12036b8:	18800015 	stw	r2,0(r3)
    rc = -1;
 12036bc:	00bfffc4 	movi	r2,-1
 12036c0:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 12036c4:	e0bffb17 	ldw	r2,-20(fp)
}
 12036c8:	e037883a 	mov	sp,fp
 12036cc:	dfc00117 	ldw	ra,4(sp)
 12036d0:	df000017 	ldw	fp,0(sp)
 12036d4:	dec00204 	addi	sp,sp,8
 12036d8:	f800283a 	ret

012036dc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 12036dc:	defffd04 	addi	sp,sp,-12
 12036e0:	dfc00215 	stw	ra,8(sp)
 12036e4:	df000115 	stw	fp,4(sp)
 12036e8:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 12036ec:	0009883a 	mov	r4,zero
 12036f0:	1203ba00 	call	1203ba0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 12036f4:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 12036f8:	1203bd40 	call	1203bd4 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 12036fc:	01004834 	movhi	r4,288
 1203700:	211ffd04 	addi	r4,r4,32756
 1203704:	01404834 	movhi	r5,288
 1203708:	295ffd04 	addi	r5,r5,32756
 120370c:	01804834 	movhi	r6,288
 1203710:	319ffd04 	addi	r6,r6,32756
 1203714:	1206b340 	call	1206b34 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 1203718:	12068680 	call	1206868 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 120371c:	01004834 	movhi	r4,288
 1203720:	211a3104 	addi	r4,r4,26820
 1203724:	1207ae80 	call	1207ae8 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 1203728:	d1201617 	ldw	r4,-32680(gp)
 120372c:	d0e01717 	ldw	r3,-32676(gp)
 1203730:	d0a01817 	ldw	r2,-32672(gp)
 1203734:	180b883a 	mov	r5,r3
 1203738:	100d883a 	mov	r6,r2
 120373c:	12003680 	call	1200368 <main>
 1203740:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 1203744:	01000044 	movi	r4,1
 1203748:	1202ff80 	call	1202ff8 <close>
  exit (result);
 120374c:	e13fff17 	ldw	r4,-4(fp)
 1203750:	1207afc0 	call	1207afc <exit>

01203754 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 1203754:	defffe04 	addi	sp,sp,-8
 1203758:	df000115 	stw	fp,4(sp)
 120375c:	df000104 	addi	fp,sp,4
 1203760:	e13fff15 	stw	r4,-4(fp)
}
 1203764:	e037883a 	mov	sp,fp
 1203768:	df000017 	ldw	fp,0(sp)
 120376c:	dec00104 	addi	sp,sp,4
 1203770:	f800283a 	ret

01203774 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 1203774:	defffe04 	addi	sp,sp,-8
 1203778:	df000115 	stw	fp,4(sp)
 120377c:	df000104 	addi	fp,sp,4
 1203780:	e13fff15 	stw	r4,-4(fp)
}
 1203784:	e037883a 	mov	sp,fp
 1203788:	df000017 	ldw	fp,0(sp)
 120378c:	dec00104 	addi	sp,sp,4
 1203790:	f800283a 	ret

01203794 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1203794:	defffe04 	addi	sp,sp,-8
 1203798:	dfc00115 	stw	ra,4(sp)
 120379c:	df000015 	stw	fp,0(sp)
 12037a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 12037a4:	00804874 	movhi	r2,289
 12037a8:	10a6d704 	addi	r2,r2,-25764
 12037ac:	10800017 	ldw	r2,0(r2)
 12037b0:	10000526 	beq	r2,zero,12037c8 <alt_get_errno+0x34>
 12037b4:	00804874 	movhi	r2,289
 12037b8:	10a6d704 	addi	r2,r2,-25764
 12037bc:	10800017 	ldw	r2,0(r2)
 12037c0:	103ee83a 	callr	r2
 12037c4:	00000206 	br	12037d0 <alt_get_errno+0x3c>
 12037c8:	00804874 	movhi	r2,289
 12037cc:	10a6e204 	addi	r2,r2,-25720
}
 12037d0:	e037883a 	mov	sp,fp
 12037d4:	dfc00117 	ldw	ra,4(sp)
 12037d8:	df000017 	ldw	fp,0(sp)
 12037dc:	dec00204 	addi	sp,sp,8
 12037e0:	f800283a 	ret

012037e4 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 12037e4:	defff904 	addi	sp,sp,-28
 12037e8:	dfc00615 	stw	ra,24(sp)
 12037ec:	df000515 	stw	fp,20(sp)
 12037f0:	df000504 	addi	fp,sp,20
 12037f4:	e13ffd15 	stw	r4,-12(fp)
 12037f8:	e17ffe15 	stw	r5,-8(fp)
 12037fc:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1203800:	e0bffd17 	ldw	r2,-12(fp)
 1203804:	10000616 	blt	r2,zero,1203820 <read+0x3c>
 1203808:	e0bffd17 	ldw	r2,-12(fp)
 120380c:	10c00324 	muli	r3,r2,12
 1203810:	00804874 	movhi	r2,289
 1203814:	10a21f04 	addi	r2,r2,-30596
 1203818:	1885883a 	add	r2,r3,r2
 120381c:	00000106 	br	1203824 <read+0x40>
 1203820:	0005883a 	mov	r2,zero
 1203824:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1203828:	e0bffb17 	ldw	r2,-20(fp)
 120382c:	10002226 	beq	r2,zero,12038b8 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1203830:	e0bffb17 	ldw	r2,-20(fp)
 1203834:	10800217 	ldw	r2,8(r2)
 1203838:	108000cc 	andi	r2,r2,3
 120383c:	10800060 	cmpeqi	r2,r2,1
 1203840:	1000181e 	bne	r2,zero,12038a4 <read+0xc0>
        (fd->dev->read))
 1203844:	e0bffb17 	ldw	r2,-20(fp)
 1203848:	10800017 	ldw	r2,0(r2)
 120384c:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1203850:	10001426 	beq	r2,zero,12038a4 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 1203854:	e0bffb17 	ldw	r2,-20(fp)
 1203858:	10800017 	ldw	r2,0(r2)
 120385c:	10800517 	ldw	r2,20(r2)
 1203860:	e0ffff17 	ldw	r3,-4(fp)
 1203864:	e13ffb17 	ldw	r4,-20(fp)
 1203868:	e17ffe17 	ldw	r5,-8(fp)
 120386c:	180d883a 	mov	r6,r3
 1203870:	103ee83a 	callr	r2
 1203874:	e0bffc15 	stw	r2,-16(fp)
 1203878:	e0bffc17 	ldw	r2,-16(fp)
 120387c:	1000070e 	bge	r2,zero,120389c <read+0xb8>
        {
          ALT_ERRNO = -rval;
 1203880:	12037940 	call	1203794 <alt_get_errno>
 1203884:	1007883a 	mov	r3,r2
 1203888:	e0bffc17 	ldw	r2,-16(fp)
 120388c:	0085c83a 	sub	r2,zero,r2
 1203890:	18800015 	stw	r2,0(r3)
          return -1;
 1203894:	00bfffc4 	movi	r2,-1
 1203898:	00000c06 	br	12038cc <read+0xe8>
        }
        return rval;
 120389c:	e0bffc17 	ldw	r2,-16(fp)
 12038a0:	00000a06 	br	12038cc <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 12038a4:	12037940 	call	1203794 <alt_get_errno>
 12038a8:	1007883a 	mov	r3,r2
 12038ac:	00800344 	movi	r2,13
 12038b0:	18800015 	stw	r2,0(r3)
 12038b4:	00000406 	br	12038c8 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 12038b8:	12037940 	call	1203794 <alt_get_errno>
 12038bc:	1007883a 	mov	r3,r2
 12038c0:	00801444 	movi	r2,81
 12038c4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 12038c8:	00bfffc4 	movi	r2,-1
}
 12038cc:	e037883a 	mov	sp,fp
 12038d0:	dfc00117 	ldw	ra,4(sp)
 12038d4:	df000017 	ldw	fp,0(sp)
 12038d8:	dec00204 	addi	sp,sp,8
 12038dc:	f800283a 	ret

012038e0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 12038e0:	defffe04 	addi	sp,sp,-8
 12038e4:	df000115 	stw	fp,4(sp)
 12038e8:	df000104 	addi	fp,sp,4
 12038ec:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 12038f0:	e0bfff17 	ldw	r2,-4(fp)
 12038f4:	108000d0 	cmplti	r2,r2,3
 12038f8:	10000d1e 	bne	r2,zero,1203930 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 12038fc:	00804874 	movhi	r2,289
 1203900:	10a21f04 	addi	r2,r2,-30596
 1203904:	e0ffff17 	ldw	r3,-4(fp)
 1203908:	18c00324 	muli	r3,r3,12
 120390c:	10c5883a 	add	r2,r2,r3
 1203910:	10800204 	addi	r2,r2,8
 1203914:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 1203918:	00804874 	movhi	r2,289
 120391c:	10a21f04 	addi	r2,r2,-30596
 1203920:	e0ffff17 	ldw	r3,-4(fp)
 1203924:	18c00324 	muli	r3,r3,12
 1203928:	10c5883a 	add	r2,r2,r3
 120392c:	10000015 	stw	zero,0(r2)
  }
}
 1203930:	e037883a 	mov	sp,fp
 1203934:	df000017 	ldw	fp,0(sp)
 1203938:	dec00104 	addi	sp,sp,4
 120393c:	f800283a 	ret

01203940 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 1203940:	defff904 	addi	sp,sp,-28
 1203944:	df000615 	stw	fp,24(sp)
 1203948:	df000604 	addi	fp,sp,24
 120394c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1203950:	0005303a 	rdctl	r2,status
 1203954:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1203958:	e0fffc17 	ldw	r3,-16(fp)
 120395c:	00bfff84 	movi	r2,-2
 1203960:	1884703a 	and	r2,r3,r2
 1203964:	1001703a 	wrctl	status,r2
  
  return context;
 1203968:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 120396c:	e0bffa15 	stw	r2,-24(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 1203970:	d0a00b17 	ldw	r2,-32724(gp)
 1203974:	10c000c4 	addi	r3,r2,3
 1203978:	00bfff04 	movi	r2,-4
 120397c:	1884703a 	and	r2,r3,r2
 1203980:	d0a00b15 	stw	r2,-32724(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 1203984:	d0e00b17 	ldw	r3,-32724(gp)
 1203988:	e0bfff17 	ldw	r2,-4(fp)
 120398c:	1887883a 	add	r3,r3,r2
 1203990:	00805034 	movhi	r2,320
 1203994:	10800004 	addi	r2,r2,0
 1203998:	10c0062e 	bgeu	r2,r3,12039b4 <sbrk+0x74>
 120399c:	e0bffa17 	ldw	r2,-24(fp)
 12039a0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 12039a4:	e0bffd17 	ldw	r2,-12(fp)
 12039a8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 12039ac:	00bfffc4 	movi	r2,-1
 12039b0:	00000b06 	br	12039e0 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 12039b4:	d0a00b17 	ldw	r2,-32724(gp)
 12039b8:	e0bffb15 	stw	r2,-20(fp)
  heap_end += incr; 
 12039bc:	d0e00b17 	ldw	r3,-32724(gp)
 12039c0:	e0bfff17 	ldw	r2,-4(fp)
 12039c4:	1885883a 	add	r2,r3,r2
 12039c8:	d0a00b15 	stw	r2,-32724(gp)
 12039cc:	e0bffa17 	ldw	r2,-24(fp)
 12039d0:	e0bffe15 	stw	r2,-8(fp)
 12039d4:	e0bffe17 	ldw	r2,-8(fp)
 12039d8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 12039dc:	e0bffb17 	ldw	r2,-20(fp)
} 
 12039e0:	e037883a 	mov	sp,fp
 12039e4:	df000017 	ldw	fp,0(sp)
 12039e8:	dec00104 	addi	sp,sp,4
 12039ec:	f800283a 	ret

012039f0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 12039f0:	defffd04 	addi	sp,sp,-12
 12039f4:	dfc00215 	stw	ra,8(sp)
 12039f8:	df000115 	stw	fp,4(sp)
 12039fc:	df000104 	addi	fp,sp,4
 1203a00:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 1203a04:	e13fff17 	ldw	r4,-4(fp)
 1203a08:	12065a80 	call	12065a8 <alt_busy_sleep>
}
 1203a0c:	e037883a 	mov	sp,fp
 1203a10:	dfc00117 	ldw	ra,4(sp)
 1203a14:	df000017 	ldw	fp,0(sp)
 1203a18:	dec00204 	addi	sp,sp,8
 1203a1c:	f800283a 	ret

01203a20 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1203a20:	defffe04 	addi	sp,sp,-8
 1203a24:	dfc00115 	stw	ra,4(sp)
 1203a28:	df000015 	stw	fp,0(sp)
 1203a2c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1203a30:	00804874 	movhi	r2,289
 1203a34:	10a6d704 	addi	r2,r2,-25764
 1203a38:	10800017 	ldw	r2,0(r2)
 1203a3c:	10000526 	beq	r2,zero,1203a54 <alt_get_errno+0x34>
 1203a40:	00804874 	movhi	r2,289
 1203a44:	10a6d704 	addi	r2,r2,-25764
 1203a48:	10800017 	ldw	r2,0(r2)
 1203a4c:	103ee83a 	callr	r2
 1203a50:	00000206 	br	1203a5c <alt_get_errno+0x3c>
 1203a54:	00804874 	movhi	r2,289
 1203a58:	10a6e204 	addi	r2,r2,-25720
}
 1203a5c:	e037883a 	mov	sp,fp
 1203a60:	dfc00117 	ldw	ra,4(sp)
 1203a64:	df000017 	ldw	fp,0(sp)
 1203a68:	dec00204 	addi	sp,sp,8
 1203a6c:	f800283a 	ret

01203a70 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 1203a70:	defff904 	addi	sp,sp,-28
 1203a74:	dfc00615 	stw	ra,24(sp)
 1203a78:	df000515 	stw	fp,20(sp)
 1203a7c:	df000504 	addi	fp,sp,20
 1203a80:	e13ffd15 	stw	r4,-12(fp)
 1203a84:	e17ffe15 	stw	r5,-8(fp)
 1203a88:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1203a8c:	e0bffd17 	ldw	r2,-12(fp)
 1203a90:	10000616 	blt	r2,zero,1203aac <write+0x3c>
 1203a94:	e0bffd17 	ldw	r2,-12(fp)
 1203a98:	10c00324 	muli	r3,r2,12
 1203a9c:	00804874 	movhi	r2,289
 1203aa0:	10a21f04 	addi	r2,r2,-30596
 1203aa4:	1885883a 	add	r2,r3,r2
 1203aa8:	00000106 	br	1203ab0 <write+0x40>
 1203aac:	0005883a 	mov	r2,zero
 1203ab0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1203ab4:	e0bffb17 	ldw	r2,-20(fp)
 1203ab8:	10002126 	beq	r2,zero,1203b40 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 1203abc:	e0bffb17 	ldw	r2,-20(fp)
 1203ac0:	10800217 	ldw	r2,8(r2)
 1203ac4:	108000cc 	andi	r2,r2,3
 1203ac8:	10001826 	beq	r2,zero,1203b2c <write+0xbc>
 1203acc:	e0bffb17 	ldw	r2,-20(fp)
 1203ad0:	10800017 	ldw	r2,0(r2)
 1203ad4:	10800617 	ldw	r2,24(r2)
 1203ad8:	10001426 	beq	r2,zero,1203b2c <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 1203adc:	e0bffb17 	ldw	r2,-20(fp)
 1203ae0:	10800017 	ldw	r2,0(r2)
 1203ae4:	10800617 	ldw	r2,24(r2)
 1203ae8:	e0ffff17 	ldw	r3,-4(fp)
 1203aec:	e13ffb17 	ldw	r4,-20(fp)
 1203af0:	e17ffe17 	ldw	r5,-8(fp)
 1203af4:	180d883a 	mov	r6,r3
 1203af8:	103ee83a 	callr	r2
 1203afc:	e0bffc15 	stw	r2,-16(fp)
 1203b00:	e0bffc17 	ldw	r2,-16(fp)
 1203b04:	1000070e 	bge	r2,zero,1203b24 <write+0xb4>
      {
        ALT_ERRNO = -rval;
 1203b08:	1203a200 	call	1203a20 <alt_get_errno>
 1203b0c:	1007883a 	mov	r3,r2
 1203b10:	e0bffc17 	ldw	r2,-16(fp)
 1203b14:	0085c83a 	sub	r2,zero,r2
 1203b18:	18800015 	stw	r2,0(r3)
        return -1;
 1203b1c:	00bfffc4 	movi	r2,-1
 1203b20:	00000c06 	br	1203b54 <write+0xe4>
      }
      return rval;
 1203b24:	e0bffc17 	ldw	r2,-16(fp)
 1203b28:	00000a06 	br	1203b54 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 1203b2c:	1203a200 	call	1203a20 <alt_get_errno>
 1203b30:	1007883a 	mov	r3,r2
 1203b34:	00800344 	movi	r2,13
 1203b38:	18800015 	stw	r2,0(r3)
 1203b3c:	00000406 	br	1203b50 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 1203b40:	1203a200 	call	1203a20 <alt_get_errno>
 1203b44:	1007883a 	mov	r3,r2
 1203b48:	00801444 	movi	r2,81
 1203b4c:	18800015 	stw	r2,0(r3)
  }
  return -1;
 1203b50:	00bfffc4 	movi	r2,-1
}
 1203b54:	e037883a 	mov	sp,fp
 1203b58:	dfc00117 	ldw	ra,4(sp)
 1203b5c:	df000017 	ldw	fp,0(sp)
 1203b60:	dec00204 	addi	sp,sp,8
 1203b64:	f800283a 	ret

01203b68 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 1203b68:	defffd04 	addi	sp,sp,-12
 1203b6c:	dfc00215 	stw	ra,8(sp)
 1203b70:	df000115 	stw	fp,4(sp)
 1203b74:	df000104 	addi	fp,sp,4
 1203b78:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 1203b7c:	e13fff17 	ldw	r4,-4(fp)
 1203b80:	01404874 	movhi	r5,289
 1203b84:	2966d404 	addi	r5,r5,-25776
 1203b88:	12067c40 	call	12067c4 <alt_dev_llist_insert>
}
 1203b8c:	e037883a 	mov	sp,fp
 1203b90:	dfc00117 	ldw	ra,4(sp)
 1203b94:	df000017 	ldw	fp,0(sp)
 1203b98:	dec00204 	addi	sp,sp,8
 1203b9c:	f800283a 	ret

01203ba0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 1203ba0:	defffd04 	addi	sp,sp,-12
 1203ba4:	dfc00215 	stw	ra,8(sp)
 1203ba8:	df000115 	stw	fp,4(sp)
 1203bac:	df000104 	addi	fp,sp,4
 1203bb0:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, cpu);
 1203bb4:	1206fbc0 	call	1206fbc <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 1203bb8:	00800044 	movi	r2,1
 1203bbc:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 1203bc0:	e037883a 	mov	sp,fp
 1203bc4:	dfc00117 	ldw	ra,4(sp)
 1203bc8:	df000017 	ldw	fp,0(sp)
 1203bcc:	dec00204 	addi	sp,sp,8
 1203bd0:	f800283a 	ret

01203bd4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 1203bd4:	defffe04 	addi	sp,sp,-8
 1203bd8:	dfc00115 	stw	ra,4(sp)
 1203bdc:	df000015 	stw	fp,0(sp)
 1203be0:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 1203be4:	01005034 	movhi	r4,320
 1203be8:	21040804 	addi	r4,r4,4128
 1203bec:	000b883a 	mov	r5,zero
 1203bf0:	000d883a 	mov	r6,zero
 1203bf4:	01c0fa04 	movi	r7,1000
 1203bf8:	12063e00 	call	12063e0 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH_CTL, ext_flash_ctl);
 1203bfc:	01004874 	movhi	r4,289
 1203c00:	21227f04 	addi	r4,r4,-30212
 1203c04:	1203c780 	call	1203c78 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 1203c08:	01004874 	movhi	r4,289
 1203c0c:	2122c004 	addi	r4,r4,-29952
 1203c10:	000b883a 	mov	r5,zero
 1203c14:	01800044 	movi	r6,1
 1203c18:	1205a840 	call	1205a84 <altera_avalon_jtag_uart_init>
 1203c1c:	01004874 	movhi	r4,289
 1203c20:	2122b604 	addi	r4,r4,-29992
 1203c24:	1203b680 	call	1203b68 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
 1203c28:	0001883a 	nop
}
 1203c2c:	e037883a 	mov	sp,fp
 1203c30:	dfc00117 	ldw	ra,4(sp)
 1203c34:	df000017 	ldw	fp,0(sp)
 1203c38:	dec00204 	addi	sp,sp,8
 1203c3c:	f800283a 	ret

01203c40 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 1203c40:	defffd04 	addi	sp,sp,-12
 1203c44:	dfc00215 	stw	ra,8(sp)
 1203c48:	df000115 	stw	fp,4(sp)
 1203c4c:	df000104 	addi	fp,sp,4
 1203c50:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 1203c54:	e13fff17 	ldw	r4,-4(fp)
 1203c58:	01404874 	movhi	r5,289
 1203c5c:	2966da04 	addi	r5,r5,-25752
 1203c60:	12067c40 	call	12067c4 <alt_dev_llist_insert>
}
 1203c64:	e037883a 	mov	sp,fp
 1203c68:	dfc00117 	ldw	ra,4(sp)
 1203c6c:	df000017 	ldw	fp,0(sp)
 1203c70:	dec00204 	addi	sp,sp,8
 1203c74:	f800283a 	ret

01203c78 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 1203c78:	defffc04 	addi	sp,sp,-16
 1203c7c:	dfc00315 	stw	ra,12(sp)
 1203c80:	df000215 	stw	fp,8(sp)
 1203c84:	df000204 	addi	fp,sp,8
 1203c88:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 1203c8c:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 1203c90:	e13fff17 	ldw	r4,-4(fp)
 1203c94:	12050c40 	call	12050c4 <alt_read_cfi_width>
 1203c98:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 1203c9c:	e0bffe17 	ldw	r2,-8(fp)
 1203ca0:	1000031e 	bne	r2,zero,1203cb0 <alt_flash_cfi_init+0x38>
    ret_code = alt_set_flash_width_func( flash );
 1203ca4:	e13fff17 	ldw	r4,-4(fp)
 1203ca8:	12048240 	call	1204824 <alt_set_flash_width_func>
 1203cac:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 1203cb0:	e0bffe17 	ldw	r2,-8(fp)
 1203cb4:	1000031e 	bne	r2,zero,1203cc4 <alt_flash_cfi_init+0x4c>
    ret_code = alt_read_cfi_table( flash );
 1203cb8:	e13fff17 	ldw	r4,-4(fp)
 1203cbc:	1204afc0 	call	1204afc <alt_read_cfi_table>
 1203cc0:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 1203cc4:	e0bffe17 	ldw	r2,-8(fp)
 1203cc8:	1000031e 	bne	r2,zero,1203cd8 <alt_flash_cfi_init+0x60>
    ret_code = alt_set_flash_algorithm_func( flash);
 1203ccc:	e13fff17 	ldw	r4,-4(fp)
 1203cd0:	12049e00 	call	12049e0 <alt_set_flash_algorithm_func>
 1203cd4:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 1203cd8:	e0bffe17 	ldw	r2,-8(fp)
 1203cdc:	1000041e 	bne	r2,zero,1203cf0 <alt_flash_cfi_init+0x78>
    ret_code = alt_flash_device_register(&(flash->dev));
 1203ce0:	e0bfff17 	ldw	r2,-4(fp)
 1203ce4:	1009883a 	mov	r4,r2
 1203ce8:	1203c400 	call	1203c40 <alt_flash_device_register>
 1203cec:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 1203cf0:	e0bffe17 	ldw	r2,-8(fp)
}
 1203cf4:	e037883a 	mov	sp,fp
 1203cf8:	dfc00117 	ldw	ra,4(sp)
 1203cfc:	df000017 	ldw	fp,0(sp)
 1203d00:	dec00204 	addi	sp,sp,8
 1203d04:	f800283a 	ret

01203d08 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 1203d08:	defff104 	addi	sp,sp,-60
 1203d0c:	dfc00e15 	stw	ra,56(sp)
 1203d10:	df000d15 	stw	fp,52(sp)
 1203d14:	df000d04 	addi	fp,sp,52
 1203d18:	e13ffc15 	stw	r4,-16(fp)
 1203d1c:	e17ffd15 	stw	r5,-12(fp)
 1203d20:	e1bffe15 	stw	r6,-8(fp)
 1203d24:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
 1203d28:	e03ff415 	stw	zero,-48(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 1203d2c:	e0bfff17 	ldw	r2,-4(fp)
 1203d30:	e0bff815 	stw	r2,-32(fp)
  int         current_offset;
  int         start_offset = offset;
 1203d34:	e0bffd17 	ldw	r2,-12(fp)
 1203d38:	e0bff915 	stw	r2,-28(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 1203d3c:	e0bffc17 	ldw	r2,-16(fp)
 1203d40:	e0bffa15 	stw	r2,-24(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 1203d44:	e03ff515 	stw	zero,-44(fp)
 1203d48:	00008706 	br	1203f68 <alt_flash_cfi_write+0x260>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 1203d4c:	e0fffa17 	ldw	r3,-24(fp)
 1203d50:	e0bff517 	ldw	r2,-44(fp)
 1203d54:	1004913a 	slli	r2,r2,4
 1203d58:	1885883a 	add	r2,r3,r2
 1203d5c:	10800d04 	addi	r2,r2,52
 1203d60:	10800017 	ldw	r2,0(r2)
 1203d64:	e0fffd17 	ldw	r3,-12(fp)
 1203d68:	18807c16 	blt	r3,r2,1203f5c <alt_flash_cfi_write+0x254>
      (offset < (flash->dev.region_info[i].offset + 
 1203d6c:	e0fffa17 	ldw	r3,-24(fp)
 1203d70:	e0bff517 	ldw	r2,-44(fp)
 1203d74:	1004913a 	slli	r2,r2,4
 1203d78:	1885883a 	add	r2,r3,r2
 1203d7c:	10800d04 	addi	r2,r2,52
 1203d80:	10c00017 	ldw	r3,0(r2)
      flash->dev.region_info[i].region_size)))
 1203d84:	e13ffa17 	ldw	r4,-24(fp)
 1203d88:	e0bff517 	ldw	r2,-44(fp)
 1203d8c:	1004913a 	slli	r2,r2,4
 1203d90:	2085883a 	add	r2,r4,r2
 1203d94:	10800e04 	addi	r2,r2,56
 1203d98:	10800017 	ldw	r2,0(r2)
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
      (offset < (flash->dev.region_info[i].offset + 
 1203d9c:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 1203da0:	e0fffd17 	ldw	r3,-12(fp)
 1203da4:	18806d0e 	bge	r3,r2,1203f5c <alt_flash_cfi_write+0x254>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 1203da8:	e0fffa17 	ldw	r3,-24(fp)
 1203dac:	e0bff517 	ldw	r2,-44(fp)
 1203db0:	1004913a 	slli	r2,r2,4
 1203db4:	1885883a 	add	r2,r3,r2
 1203db8:	10800d04 	addi	r2,r2,52
 1203dbc:	10800017 	ldw	r2,0(r2)
 1203dc0:	e0bff715 	stw	r2,-36(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 1203dc4:	e03ff615 	stw	zero,-40(fp)
 1203dc8:	00005c06 	br	1203f3c <alt_flash_cfi_write+0x234>
      {
        if ((offset >= current_offset ) && 
 1203dcc:	e0fffd17 	ldw	r3,-12(fp)
 1203dd0:	e0bff717 	ldw	r2,-36(fp)
 1203dd4:	18804d16 	blt	r3,r2,1203f0c <alt_flash_cfi_write+0x204>
            (offset < (current_offset + 
            flash->dev.region_info[i].block_size)))
 1203dd8:	e0fffa17 	ldw	r3,-24(fp)
 1203ddc:	e0bff517 	ldw	r2,-44(fp)
 1203de0:	10800104 	addi	r2,r2,4
 1203de4:	1004913a 	slli	r2,r2,4
 1203de8:	1885883a 	add	r2,r3,r2
 1203dec:	10c00017 	ldw	r3,0(r2)
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) && 
            (offset < (current_offset + 
 1203df0:	e0bff717 	ldw	r2,-36(fp)
 1203df4:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) && 
 1203df8:	e0fffd17 	ldw	r3,-12(fp)
 1203dfc:	1880430e 	bge	r3,r2,1203f0c <alt_flash_cfi_write+0x204>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 1203e00:	e0fffa17 	ldw	r3,-24(fp)
 1203e04:	e0bff517 	ldw	r2,-44(fp)
 1203e08:	10800104 	addi	r2,r2,4
 1203e0c:	1004913a 	slli	r2,r2,4
 1203e10:	1885883a 	add	r2,r3,r2
 1203e14:	10c00017 	ldw	r3,0(r2)
 1203e18:	e0bff717 	ldw	r2,-36(fp)
 1203e1c:	1887883a 	add	r3,r3,r2
 1203e20:	e0bffd17 	ldw	r2,-12(fp)
 1203e24:	1885c83a 	sub	r2,r3,r2
 1203e28:	e0bffb15 	stw	r2,-20(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 1203e2c:	e0fffb17 	ldw	r3,-20(fp)
 1203e30:	e0bfff17 	ldw	r2,-4(fp)
 1203e34:	1880010e 	bge	r3,r2,1203e3c <alt_flash_cfi_write+0x134>
 1203e38:	1805883a 	mov	r2,r3
 1203e3c:	e0bffb15 	stw	r2,-20(fp)
          if(memcmp(src_addr, 
                    (alt_u8*)flash->dev.base_addr+offset,
 1203e40:	e0bffa17 	ldw	r2,-24(fp)
 1203e44:	10c00a17 	ldw	r3,40(r2)
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
                            - offset); 
          data_to_write = MIN(data_to_write, length);
          if(memcmp(src_addr, 
 1203e48:	e0bffd17 	ldw	r2,-12(fp)
 1203e4c:	1887883a 	add	r3,r3,r2
 1203e50:	e0bffb17 	ldw	r2,-20(fp)
 1203e54:	e13ffe17 	ldw	r4,-8(fp)
 1203e58:	180b883a 	mov	r5,r3
 1203e5c:	100d883a 	mov	r6,r2
 1203e60:	1207b340 	call	1207b34 <memcmp>
 1203e64:	10001326 	beq	r2,zero,1203eb4 <alt_flash_cfi_write+0x1ac>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 1203e68:	e0bffa17 	ldw	r2,-24(fp)
 1203e6c:	10800817 	ldw	r2,32(r2)
 1203e70:	e0fffa17 	ldw	r3,-24(fp)
 1203e74:	1809883a 	mov	r4,r3
 1203e78:	e17ff717 	ldw	r5,-36(fp)
 1203e7c:	103ee83a 	callr	r2
 1203e80:	e0bff415 	stw	r2,-48(fp)

            if (!ret_code)
 1203e84:	e0bff417 	ldw	r2,-48(fp)
 1203e88:	10000a1e 	bne	r2,zero,1203eb4 <alt_flash_cfi_write+0x1ac>
            {
              ret_code = (*flash->dev.write_block)( 
 1203e8c:	e0bffa17 	ldw	r2,-24(fp)
 1203e90:	10800917 	ldw	r2,36(r2)
 1203e94:	e13ffa17 	ldw	r4,-24(fp)
 1203e98:	e0fffb17 	ldw	r3,-20(fp)
 1203e9c:	d8c00015 	stw	r3,0(sp)
 1203ea0:	e17ff717 	ldw	r5,-36(fp)
 1203ea4:	e1bffd17 	ldw	r6,-12(fp)
 1203ea8:	e1fffe17 	ldw	r7,-8(fp)
 1203eac:	103ee83a 	callr	r2
 1203eb0:	e0bff415 	stw	r2,-48(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 1203eb4:	e0ffff17 	ldw	r3,-4(fp)
 1203eb8:	e0bffb17 	ldw	r2,-20(fp)
 1203ebc:	18802e26 	beq	r3,r2,1203f78 <alt_flash_cfi_write+0x270>
 1203ec0:	e0bff417 	ldw	r2,-48(fp)
 1203ec4:	10002c1e 	bne	r2,zero,1203f78 <alt_flash_cfi_write+0x270>
          {
            goto finished;
          }
          
          length -= data_to_write;
 1203ec8:	e0ffff17 	ldw	r3,-4(fp)
 1203ecc:	e0bffb17 	ldw	r2,-20(fp)
 1203ed0:	1885c83a 	sub	r2,r3,r2
 1203ed4:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 1203ed8:	e0fffa17 	ldw	r3,-24(fp)
 1203edc:	e0bff517 	ldw	r2,-44(fp)
 1203ee0:	10800104 	addi	r2,r2,4
 1203ee4:	1004913a 	slli	r2,r2,4
 1203ee8:	1885883a 	add	r2,r3,r2
 1203eec:	10c00017 	ldw	r3,0(r2)
 1203ef0:	e0bff717 	ldw	r2,-36(fp)
 1203ef4:	1885883a 	add	r2,r3,r2
 1203ef8:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 1203efc:	e0bffb17 	ldw	r2,-20(fp)
 1203f00:	e0fffe17 	ldw	r3,-8(fp)
 1203f04:	1885883a 	add	r2,r3,r2
 1203f08:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 1203f0c:	e0fffa17 	ldw	r3,-24(fp)
 1203f10:	e0bff517 	ldw	r2,-44(fp)
 1203f14:	10800104 	addi	r2,r2,4
 1203f18:	1004913a 	slli	r2,r2,4
 1203f1c:	1885883a 	add	r2,r3,r2
 1203f20:	10800017 	ldw	r2,0(r2)
 1203f24:	e0fff717 	ldw	r3,-36(fp)
 1203f28:	1885883a 	add	r2,r3,r2
 1203f2c:	e0bff715 	stw	r2,-36(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 1203f30:	e0bff617 	ldw	r2,-40(fp)
 1203f34:	10800044 	addi	r2,r2,1
 1203f38:	e0bff615 	stw	r2,-40(fp)
 1203f3c:	e0fffa17 	ldw	r3,-24(fp)
 1203f40:	e0bff517 	ldw	r2,-44(fp)
 1203f44:	1004913a 	slli	r2,r2,4
 1203f48:	1885883a 	add	r2,r3,r2
 1203f4c:	10800f04 	addi	r2,r2,60
 1203f50:	10800017 	ldw	r2,0(r2)
 1203f54:	e0fff617 	ldw	r3,-40(fp)
 1203f58:	18bf9c16 	blt	r3,r2,1203dcc <__alt_mem_instruction_tcm+0xff203dcc>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 1203f5c:	e0bff517 	ldw	r2,-44(fp)
 1203f60:	10800044 	addi	r2,r2,1
 1203f64:	e0bff515 	stw	r2,-44(fp)
 1203f68:	e0bffa17 	ldw	r2,-24(fp)
 1203f6c:	10800c17 	ldw	r2,48(r2)
 1203f70:	e0fff517 	ldw	r3,-44(fp)
 1203f74:	18bf7516 	blt	r3,r2,1203d4c <__alt_mem_instruction_tcm+0xff203d4c>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 1203f78:	e0bffa17 	ldw	r2,-24(fp)
 1203f7c:	10c00a17 	ldw	r3,40(r2)
 1203f80:	e0bff917 	ldw	r2,-28(fp)
 1203f84:	1887883a 	add	r3,r3,r2
 1203f88:	e0bff817 	ldw	r2,-32(fp)
 1203f8c:	1809883a 	mov	r4,r3
 1203f90:	100b883a 	mov	r5,r2
 1203f94:	12067000 	call	1206700 <alt_dcache_flush>
  return ret_code;
 1203f98:	e0bff417 	ldw	r2,-48(fp)
}
 1203f9c:	e037883a 	mov	sp,fp
 1203fa0:	dfc00117 	ldw	ra,4(sp)
 1203fa4:	df000017 	ldw	fp,0(sp)
 1203fa8:	dec00204 	addi	sp,sp,8
 1203fac:	f800283a 	ret

01203fb0 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 1203fb0:	defffa04 	addi	sp,sp,-24
 1203fb4:	df000515 	stw	fp,20(sp)
 1203fb8:	df000504 	addi	fp,sp,20
 1203fbc:	e13ffd15 	stw	r4,-12(fp)
 1203fc0:	e17ffe15 	stw	r5,-8(fp)
 1203fc4:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 1203fc8:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 1203fcc:	e0bffd17 	ldw	r2,-12(fp)
 1203fd0:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
 1203fd4:	e0bffc17 	ldw	r2,-16(fp)
 1203fd8:	10c00c17 	ldw	r3,48(r2)
 1203fdc:	e0bfff17 	ldw	r2,-4(fp)
 1203fe0:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 1203fe4:	e0bffc17 	ldw	r2,-16(fp)
 1203fe8:	10800c17 	ldw	r2,48(r2)
 1203fec:	1000031e 	bne	r2,zero,1203ffc <alt_flash_cfi_get_info+0x4c>
  {
    ret_code = -EIO;
 1203ff0:	00bffec4 	movi	r2,-5
 1203ff4:	e0bffb15 	stw	r2,-20(fp)
 1203ff8:	00000b06 	br	1204028 <alt_flash_cfi_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 1203ffc:	e0bffc17 	ldw	r2,-16(fp)
 1204000:	10800c17 	ldw	r2,48(r2)
 1204004:	10800250 	cmplti	r2,r2,9
 1204008:	1000031e 	bne	r2,zero,1204018 <alt_flash_cfi_get_info+0x68>
  {
    ret_code = -ENOMEM;
 120400c:	00bffd04 	movi	r2,-12
 1204010:	e0bffb15 	stw	r2,-20(fp)
 1204014:	00000406 	br	1204028 <alt_flash_cfi_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
 1204018:	e0bffc17 	ldw	r2,-16(fp)
 120401c:	10c00d04 	addi	r3,r2,52
 1204020:	e0bffe17 	ldw	r2,-8(fp)
 1204024:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 1204028:	e0bffb17 	ldw	r2,-20(fp)
}
 120402c:	e037883a 	mov	sp,fp
 1204030:	df000017 	ldw	fp,0(sp)
 1204034:	dec00104 	addi	sp,sp,4
 1204038:	f800283a 	ret

0120403c <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 120403c:	defff904 	addi	sp,sp,-28
 1204040:	dfc00615 	stw	ra,24(sp)
 1204044:	df000515 	stw	fp,20(sp)
 1204048:	df000504 	addi	fp,sp,20
 120404c:	e13ffc15 	stw	r4,-16(fp)
 1204050:	e17ffd15 	stw	r5,-12(fp)
 1204054:	e1bffe15 	stw	r6,-8(fp)
 1204058:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 120405c:	e0bffc17 	ldw	r2,-16(fp)
 1204060:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 1204064:	e0bffb17 	ldw	r2,-20(fp)
 1204068:	10c00a17 	ldw	r3,40(r2)
 120406c:	e0bffd17 	ldw	r2,-12(fp)
 1204070:	1887883a 	add	r3,r3,r2
 1204074:	e0bfff17 	ldw	r2,-4(fp)
 1204078:	e13ffe17 	ldw	r4,-8(fp)
 120407c:	180b883a 	mov	r5,r3
 1204080:	100d883a 	mov	r6,r2
 1204084:	12013340 	call	1201334 <memcpy>
  return 0;
 1204088:	0005883a 	mov	r2,zero
}
 120408c:	e037883a 	mov	sp,fp
 1204090:	dfc00117 	ldw	ra,4(sp)
 1204094:	df000017 	ldw	fp,0(sp)
 1204098:	dec00204 	addi	sp,sp,8
 120409c:	f800283a 	ret

012040a0 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 12040a0:	defffa04 	addi	sp,sp,-24
 12040a4:	df000515 	stw	fp,20(sp)
 12040a8:	df000504 	addi	fp,sp,20
 12040ac:	e13ffd15 	stw	r4,-12(fp)
 12040b0:	e17ffe15 	stw	r5,-8(fp)
 12040b4:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 12040b8:	e0bffd17 	ldw	r2,-12(fp)
 12040bc:	10802f17 	ldw	r2,188(r2)
 12040c0:	10800058 	cmpnei	r2,r2,1
 12040c4:	1000091e 	bne	r2,zero,12040ec <alt_write_value_to_flash+0x4c>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 12040c8:	e0bffd17 	ldw	r2,-12(fp)
 12040cc:	10c00a17 	ldw	r3,40(r2)
 12040d0:	e0bffe17 	ldw	r2,-8(fp)
 12040d4:	1885883a 	add	r2,r3,r2
 12040d8:	e0ffff17 	ldw	r3,-4(fp)
 12040dc:	18c00003 	ldbu	r3,0(r3)
 12040e0:	18c03fcc 	andi	r3,r3,255
 12040e4:	10c00025 	stbio	r3,0(r2)
 12040e8:	00003e06 	br	12041e4 <alt_write_value_to_flash+0x144>
  }
  else if (flash->mode_width == 2)
 12040ec:	e0bffd17 	ldw	r2,-12(fp)
 12040f0:	10802f17 	ldw	r2,188(r2)
 12040f4:	10800098 	cmpnei	r2,r2,2
 12040f8:	1000141e 	bne	r2,zero,120414c <alt_write_value_to_flash+0xac>
  {
    half_word_value = (alt_u16)(*src_addr);
 12040fc:	e0bfff17 	ldw	r2,-4(fp)
 1204100:	10800003 	ldbu	r2,0(r2)
 1204104:	10803fcc 	andi	r2,r2,255
 1204108:	e0bffb0d 	sth	r2,-20(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 120410c:	e0bfff17 	ldw	r2,-4(fp)
 1204110:	10800044 	addi	r2,r2,1
 1204114:	10800003 	ldbu	r2,0(r2)
 1204118:	10803fcc 	andi	r2,r2,255
 120411c:	1004923a 	slli	r2,r2,8
 1204120:	1007883a 	mov	r3,r2
 1204124:	e0bffb0b 	ldhu	r2,-20(fp)
 1204128:	1884b03a 	or	r2,r3,r2
 120412c:	e0bffb0d 	sth	r2,-20(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 1204130:	e0bffd17 	ldw	r2,-12(fp)
 1204134:	10c00a17 	ldw	r3,40(r2)
 1204138:	e0bffe17 	ldw	r2,-8(fp)
 120413c:	1885883a 	add	r2,r3,r2
 1204140:	e0fffb0b 	ldhu	r3,-20(fp)
 1204144:	10c0002d 	sthio	r3,0(r2)
 1204148:	00002606 	br	12041e4 <alt_write_value_to_flash+0x144>
  }
  else if (flash->mode_width == 4)
 120414c:	e0bffd17 	ldw	r2,-12(fp)
 1204150:	10802f17 	ldw	r2,188(r2)
 1204154:	10800118 	cmpnei	r2,r2,4
 1204158:	1000221e 	bne	r2,zero,12041e4 <alt_write_value_to_flash+0x144>
  {
    word_value = (alt_u32)(*src_addr);
 120415c:	e0bfff17 	ldw	r2,-4(fp)
 1204160:	10800003 	ldbu	r2,0(r2)
 1204164:	10803fcc 	andi	r2,r2,255
 1204168:	e0bffc15 	stw	r2,-16(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 120416c:	e0bfff17 	ldw	r2,-4(fp)
 1204170:	10800044 	addi	r2,r2,1
 1204174:	10800003 	ldbu	r2,0(r2)
 1204178:	10803fcc 	andi	r2,r2,255
 120417c:	1004923a 	slli	r2,r2,8
 1204180:	e0fffc17 	ldw	r3,-16(fp)
 1204184:	1884b03a 	or	r2,r3,r2
 1204188:	e0bffc15 	stw	r2,-16(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 120418c:	e0bfff17 	ldw	r2,-4(fp)
 1204190:	10800084 	addi	r2,r2,2
 1204194:	10800003 	ldbu	r2,0(r2)
 1204198:	10803fcc 	andi	r2,r2,255
 120419c:	1004943a 	slli	r2,r2,16
 12041a0:	e0fffc17 	ldw	r3,-16(fp)
 12041a4:	1884b03a 	or	r2,r3,r2
 12041a8:	e0bffc15 	stw	r2,-16(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 12041ac:	e0bfff17 	ldw	r2,-4(fp)
 12041b0:	108000c4 	addi	r2,r2,3
 12041b4:	10800003 	ldbu	r2,0(r2)
 12041b8:	10803fcc 	andi	r2,r2,255
 12041bc:	1004963a 	slli	r2,r2,24
 12041c0:	e0fffc17 	ldw	r3,-16(fp)
 12041c4:	1884b03a 	or	r2,r3,r2
 12041c8:	e0bffc15 	stw	r2,-16(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 12041cc:	e0bffd17 	ldw	r2,-12(fp)
 12041d0:	10c00a17 	ldw	r3,40(r2)
 12041d4:	e0bffe17 	ldw	r2,-8(fp)
 12041d8:	1885883a 	add	r2,r3,r2
 12041dc:	e0fffc17 	ldw	r3,-16(fp)
 12041e0:	10c00035 	stwio	r3,0(r2)
  }

  return;
 12041e4:	0001883a 	nop
}
 12041e8:	e037883a 	mov	sp,fp
 12041ec:	df000017 	ldw	fp,0(sp)
 12041f0:	dec00104 	addi	sp,sp,4
 12041f4:	f800283a 	ret

012041f8 <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 12041f8:	defff304 	addi	sp,sp,-52
 12041fc:	dfc00c15 	stw	ra,48(sp)
 1204200:	df000b15 	stw	fp,44(sp)
 1204204:	df000b04 	addi	fp,sp,44
 1204208:	e13ffc15 	stw	r4,-16(fp)
 120420c:	e17ffd15 	stw	r5,-12(fp)
 1204210:	e1bffe15 	stw	r6,-8(fp)
 1204214:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 1204218:	e03ff515 	stw	zero,-44(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 120421c:	e0bffc17 	ldw	r2,-16(fp)
 1204220:	10c00a17 	ldw	r3,40(r2)
 1204224:	e0bffd17 	ldw	r2,-12(fp)
 1204228:	1885883a 	add	r2,r3,r2
 120422c:	1007883a 	mov	r3,r2
                      flash->mode_width);
 1204230:	e0bffc17 	ldw	r2,-16(fp)
 1204234:	10802f17 	ldw	r2,188(r2)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 1204238:	1809883a 	mov	r4,r3
 120423c:	100b883a 	mov	r5,r2
 1204240:	1207f180 	call	1207f18 <__modsi3>
 1204244:	e0bff815 	stw	r2,-32(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 1204248:	e0bff817 	ldw	r2,-32(fp)
 120424c:	10003a26 	beq	r2,zero,1204338 <alt_flash_program_block+0x140>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 1204250:	e0bffc17 	ldw	r2,-16(fp)
 1204254:	10c02f17 	ldw	r3,188(r2)
 1204258:	e0bff817 	ldw	r2,-32(fp)
 120425c:	1885c83a 	sub	r2,r3,r2
 1204260:	e0bff915 	stw	r2,-28(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 1204264:	e03ff615 	stw	zero,-40(fp)
 1204268:	00001206 	br	12042b4 <alt_flash_program_block+0xbc>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 120426c:	e0bffc17 	ldw	r2,-16(fp)
 1204270:	10800a17 	ldw	r2,40(r2)
 1204274:	e13ffd17 	ldw	r4,-12(fp)
 1204278:	e0fff817 	ldw	r3,-32(fp)
 120427c:	20c9c83a 	sub	r4,r4,r3
 1204280:	e0fff617 	ldw	r3,-40(fp)
 1204284:	20c7883a 	add	r3,r4,r3
 1204288:	10c5883a 	add	r2,r2,r3
 120428c:	10800023 	ldbuio	r2,0(r2)
 1204290:	10803fcc 	andi	r2,r2,255
 1204294:	1009883a 	mov	r4,r2
 1204298:	e0fffb04 	addi	r3,fp,-20
 120429c:	e0bff617 	ldw	r2,-40(fp)
 12042a0:	1885883a 	add	r2,r3,r2
 12042a4:	11000005 	stb	r4,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 12042a8:	e0bff617 	ldw	r2,-40(fp)
 12042ac:	10800044 	addi	r2,r2,1
 12042b0:	e0bff615 	stw	r2,-40(fp)
 12042b4:	e0fff617 	ldw	r3,-40(fp)
 12042b8:	e0bff817 	ldw	r2,-32(fp)
 12042bc:	18bfeb16 	blt	r3,r2,120426c <__alt_mem_instruction_tcm+0xff20426c>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 12042c0:	e03ff615 	stw	zero,-40(fp)
 12042c4:	00000d06 	br	12042fc <alt_flash_program_block+0x104>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 12042c8:	e0fff817 	ldw	r3,-32(fp)
 12042cc:	e0bff617 	ldw	r2,-40(fp)
 12042d0:	1885883a 	add	r2,r3,r2
 12042d4:	e0fff617 	ldw	r3,-40(fp)
 12042d8:	e13ffe17 	ldw	r4,-8(fp)
 12042dc:	20c7883a 	add	r3,r4,r3
 12042e0:	18c00003 	ldbu	r3,0(r3)
 12042e4:	e13ffb04 	addi	r4,fp,-20
 12042e8:	2085883a 	add	r2,r4,r2
 12042ec:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 12042f0:	e0bff617 	ldw	r2,-40(fp)
 12042f4:	10800044 	addi	r2,r2,1
 12042f8:	e0bff615 	stw	r2,-40(fp)
 12042fc:	e0fff617 	ldw	r3,-40(fp)
 1204300:	e0bff917 	ldw	r2,-28(fp)
 1204304:	18bff016 	blt	r3,r2,12042c8 <__alt_mem_instruction_tcm+0xff2042c8>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 1204308:	e0fffd17 	ldw	r3,-12(fp)
 120430c:	e0bff817 	ldw	r2,-32(fp)
 1204310:	188bc83a 	sub	r5,r3,r2
 1204314:	e0fffb04 	addi	r3,fp,-20
 1204318:	e0800217 	ldw	r2,8(fp)
 120431c:	e13ffc17 	ldw	r4,-16(fp)
 1204320:	180d883a 	mov	r6,r3
 1204324:	103ee83a 	callr	r2
 1204328:	e0bff515 	stw	r2,-44(fp)
    i = unaligned_bytes;
 120432c:	e0bff917 	ldw	r2,-28(fp)
 1204330:	e0bff615 	stw	r2,-40(fp)
 1204334:	00000106 	br	120433c <alt_flash_program_block+0x144>
  }
  else
  {
    i = 0;
 1204338:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 120433c:	e0fffd17 	ldw	r3,-12(fp)
 1204340:	e0bfff17 	ldw	r2,-4(fp)
 1204344:	1887883a 	add	r3,r3,r2
 1204348:	e0bffc17 	ldw	r2,-16(fp)
 120434c:	10802f17 	ldw	r2,188(r2)
 1204350:	1809883a 	mov	r4,r3
 1204354:	100b883a 	mov	r5,r2
 1204358:	1207f180 	call	1207f18 <__modsi3>
 120435c:	e0bffa15 	stw	r2,-24(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 1204360:	00001006 	br	12043a4 <alt_flash_program_block+0x1ac>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 1204364:	e0fffd17 	ldw	r3,-12(fp)
 1204368:	e0bff617 	ldw	r2,-40(fp)
 120436c:	188b883a 	add	r5,r3,r2
 1204370:	e0bff617 	ldw	r2,-40(fp)
 1204374:	e0fffe17 	ldw	r3,-8(fp)
 1204378:	1887883a 	add	r3,r3,r2
 120437c:	e0800217 	ldw	r2,8(fp)
 1204380:	e13ffc17 	ldw	r4,-16(fp)
 1204384:	180d883a 	mov	r6,r3
 1204388:	103ee83a 	callr	r2
 120438c:	e0bff515 	stw	r2,-44(fp)
    i += flash->mode_width;     
 1204390:	e0bffc17 	ldw	r2,-16(fp)
 1204394:	10802f17 	ldw	r2,188(r2)
 1204398:	e0fff617 	ldw	r3,-40(fp)
 120439c:	1885883a 	add	r2,r3,r2
 12043a0:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 12043a4:	e0bff517 	ldw	r2,-44(fp)
 12043a8:	1000051e 	bne	r2,zero,12043c0 <alt_flash_program_block+0x1c8>
 12043ac:	e0ffff17 	ldw	r3,-4(fp)
 12043b0:	e0bffa17 	ldw	r2,-24(fp)
 12043b4:	1885c83a 	sub	r2,r3,r2
 12043b8:	e0fff617 	ldw	r3,-40(fp)
 12043bc:	18bfe916 	blt	r3,r2,1204364 <__alt_mem_instruction_tcm+0xff204364>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 12043c0:	e0bffa17 	ldw	r2,-24(fp)
 12043c4:	10003b26 	beq	r2,zero,12044b4 <alt_flash_program_block+0x2bc>
 12043c8:	e0bff517 	ldw	r2,-44(fp)
 12043cc:	1000391e 	bne	r2,zero,12044b4 <alt_flash_program_block+0x2bc>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 12043d0:	e0bffc17 	ldw	r2,-16(fp)
 12043d4:	10c02f17 	ldw	r3,188(r2)
 12043d8:	e0bffa17 	ldw	r2,-24(fp)
 12043dc:	1885c83a 	sub	r2,r3,r2
 12043e0:	e0bff815 	stw	r2,-32(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 12043e4:	e03ff715 	stw	zero,-36(fp)
 12043e8:	00000d06 	br	1204420 <alt_flash_program_block+0x228>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 12043ec:	e0fff617 	ldw	r3,-40(fp)
 12043f0:	e0bff717 	ldw	r2,-36(fp)
 12043f4:	1885883a 	add	r2,r3,r2
 12043f8:	e0fffe17 	ldw	r3,-8(fp)
 12043fc:	1885883a 	add	r2,r3,r2
 1204400:	10c00003 	ldbu	r3,0(r2)
 1204404:	e13ffb04 	addi	r4,fp,-20
 1204408:	e0bff717 	ldw	r2,-36(fp)
 120440c:	2085883a 	add	r2,r4,r2
 1204410:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 1204414:	e0bff717 	ldw	r2,-36(fp)
 1204418:	10800044 	addi	r2,r2,1
 120441c:	e0bff715 	stw	r2,-36(fp)
 1204420:	e0fff717 	ldw	r3,-36(fp)
 1204424:	e0bffa17 	ldw	r2,-24(fp)
 1204428:	18bff016 	blt	r3,r2,12043ec <__alt_mem_instruction_tcm+0xff2043ec>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 120442c:	e03ff715 	stw	zero,-36(fp)
 1204430:	00001406 	br	1204484 <alt_flash_program_block+0x28c>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 1204434:	e0fffa17 	ldw	r3,-24(fp)
 1204438:	e0bff717 	ldw	r2,-36(fp)
 120443c:	1885883a 	add	r2,r3,r2
 1204440:	e0fffc17 	ldw	r3,-16(fp)
 1204444:	18c00a17 	ldw	r3,40(r3)
 1204448:	e17ffd17 	ldw	r5,-12(fp)
 120444c:	e13fff17 	ldw	r4,-4(fp)
 1204450:	290b883a 	add	r5,r5,r4
 1204454:	e13ff717 	ldw	r4,-36(fp)
 1204458:	2909883a 	add	r4,r5,r4
 120445c:	1907883a 	add	r3,r3,r4
 1204460:	18c00023 	ldbuio	r3,0(r3)
 1204464:	18c03fcc 	andi	r3,r3,255
 1204468:	1809883a 	mov	r4,r3
 120446c:	e0fffb04 	addi	r3,fp,-20
 1204470:	1885883a 	add	r2,r3,r2
 1204474:	11000005 	stb	r4,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 1204478:	e0bff717 	ldw	r2,-36(fp)
 120447c:	10800044 	addi	r2,r2,1
 1204480:	e0bff715 	stw	r2,-36(fp)
 1204484:	e0fff717 	ldw	r3,-36(fp)
 1204488:	e0bff817 	ldw	r2,-32(fp)
 120448c:	18bfe916 	blt	r3,r2,1204434 <__alt_mem_instruction_tcm+0xff204434>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 1204490:	e0fffd17 	ldw	r3,-12(fp)
 1204494:	e0bff617 	ldw	r2,-40(fp)
 1204498:	188b883a 	add	r5,r3,r2
 120449c:	e0fffb04 	addi	r3,fp,-20
 12044a0:	e0800217 	ldw	r2,8(fp)
 12044a4:	e13ffc17 	ldw	r4,-16(fp)
 12044a8:	180d883a 	mov	r6,r3
 12044ac:	103ee83a 	callr	r2
 12044b0:	e0bff515 	stw	r2,-44(fp)
  }

  return ret_code;
 12044b4:	e0bff517 	ldw	r2,-44(fp)
}
 12044b8:	e037883a 	mov	sp,fp
 12044bc:	dfc00117 	ldw	ra,4(sp)
 12044c0:	df000017 	ldw	fp,0(sp)
 12044c4:	dec00204 	addi	sp,sp,8
 12044c8:	f800283a 	ret

012044cc <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 12044cc:	defffd04 	addi	sp,sp,-12
 12044d0:	df000215 	stw	fp,8(sp)
 12044d4:	df000204 	addi	fp,sp,8
 12044d8:	e13ffe15 	stw	r4,-8(fp)
 12044dc:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 12044e0:	e0bffe17 	ldw	r2,-8(fp)
 12044e4:	10c00a17 	ldw	r3,40(r2)
 12044e8:	e0bfff17 	ldw	r2,-4(fp)
 12044ec:	1885883a 	add	r2,r3,r2
 12044f0:	10800023 	ldbuio	r2,0(r2)
 12044f4:	10803fcc 	andi	r2,r2,255
}
 12044f8:	e037883a 	mov	sp,fp
 12044fc:	df000017 	ldw	fp,0(sp)
 1204500:	dec00104 	addi	sp,sp,4
 1204504:	f800283a 	ret

01204508 <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 1204508:	defffd04 	addi	sp,sp,-12
 120450c:	df000215 	stw	fp,8(sp)
 1204510:	df000204 	addi	fp,sp,8
 1204514:	e13ffe15 	stw	r4,-8(fp)
 1204518:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 120451c:	e0bffe17 	ldw	r2,-8(fp)
 1204520:	10c00a17 	ldw	r3,40(r2)
 1204524:	e0bfff17 	ldw	r2,-4(fp)
 1204528:	1085883a 	add	r2,r2,r2
 120452c:	1885883a 	add	r2,r3,r2
 1204530:	1080002b 	ldhuio	r2,0(r2)
 1204534:	10bfffcc 	andi	r2,r2,65535
}
 1204538:	e037883a 	mov	sp,fp
 120453c:	df000017 	ldw	fp,0(sp)
 1204540:	dec00104 	addi	sp,sp,4
 1204544:	f800283a 	ret

01204548 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 1204548:	defffd04 	addi	sp,sp,-12
 120454c:	df000215 	stw	fp,8(sp)
 1204550:	df000204 	addi	fp,sp,8
 1204554:	e13ffe15 	stw	r4,-8(fp)
 1204558:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 120455c:	e0bffe17 	ldw	r2,-8(fp)
 1204560:	10c00a17 	ldw	r3,40(r2)
 1204564:	e0bfff17 	ldw	r2,-4(fp)
 1204568:	1085883a 	add	r2,r2,r2
 120456c:	1085883a 	add	r2,r2,r2
 1204570:	1885883a 	add	r2,r3,r2
 1204574:	10800037 	ldwio	r2,0(r2)
}
 1204578:	e037883a 	mov	sp,fp
 120457c:	df000017 	ldw	fp,0(sp)
 1204580:	dec00104 	addi	sp,sp,4
 1204584:	f800283a 	ret

01204588 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 1204588:	defffc04 	addi	sp,sp,-16
 120458c:	df000315 	stw	fp,12(sp)
 1204590:	df000304 	addi	fp,sp,12
 1204594:	e13ffd15 	stw	r4,-12(fp)
 1204598:	e17ffe15 	stw	r5,-8(fp)
 120459c:	3005883a 	mov	r2,r6
 12045a0:	e0bfff05 	stb	r2,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 12045a4:	e0bffe17 	ldw	r2,-8(fp)
 12045a8:	e0fffd17 	ldw	r3,-12(fp)
 12045ac:	1885883a 	add	r2,r3,r2
 12045b0:	e0ffff03 	ldbu	r3,-4(fp)
 12045b4:	10c00025 	stbio	r3,0(r2)
  return;
 12045b8:	0001883a 	nop
}
 12045bc:	e037883a 	mov	sp,fp
 12045c0:	df000017 	ldw	fp,0(sp)
 12045c4:	dec00104 	addi	sp,sp,4
 12045c8:	f800283a 	ret

012045cc <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 12045cc:	defffc04 	addi	sp,sp,-16
 12045d0:	df000315 	stw	fp,12(sp)
 12045d4:	df000304 	addi	fp,sp,12
 12045d8:	e13ffd15 	stw	r4,-12(fp)
 12045dc:	e17ffe15 	stw	r5,-8(fp)
 12045e0:	3005883a 	mov	r2,r6
 12045e4:	e0bfff05 	stb	r2,-4(fp)
  if (offset % 2)
 12045e8:	e0bffe17 	ldw	r2,-8(fp)
 12045ec:	1080004c 	andi	r2,r2,1
 12045f0:	10000826 	beq	r2,zero,1204614 <alt_write_flash_command_16bit_device_8bit_mode+0x48>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 12045f4:	e0bffe17 	ldw	r2,-8(fp)
 12045f8:	1085883a 	add	r2,r2,r2
 12045fc:	1007883a 	mov	r3,r2
 1204600:	e0bffd17 	ldw	r2,-12(fp)
 1204604:	10c5883a 	add	r2,r2,r3
 1204608:	e0ffff03 	ldbu	r3,-4(fp)
 120460c:	10c00025 	stbio	r3,0(r2)
 1204610:	00000706 	br	1204630 <alt_write_flash_command_16bit_device_8bit_mode+0x64>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 1204614:	e0bffe17 	ldw	r2,-8(fp)
 1204618:	1085883a 	add	r2,r2,r2
 120461c:	10800044 	addi	r2,r2,1
 1204620:	e0fffd17 	ldw	r3,-12(fp)
 1204624:	1885883a 	add	r2,r3,r2
 1204628:	e0ffff03 	ldbu	r3,-4(fp)
 120462c:	10c00025 	stbio	r3,0(r2)
  }
  return;
 1204630:	0001883a 	nop
}
 1204634:	e037883a 	mov	sp,fp
 1204638:	df000017 	ldw	fp,0(sp)
 120463c:	dec00104 	addi	sp,sp,4
 1204640:	f800283a 	ret

01204644 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 1204644:	defffc04 	addi	sp,sp,-16
 1204648:	df000315 	stw	fp,12(sp)
 120464c:	df000304 	addi	fp,sp,12
 1204650:	e13ffd15 	stw	r4,-12(fp)
 1204654:	e17ffe15 	stw	r5,-8(fp)
 1204658:	3005883a 	mov	r2,r6
 120465c:	e0bfff05 	stb	r2,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 1204660:	e0bffe17 	ldw	r2,-8(fp)
 1204664:	1085883a 	add	r2,r2,r2
 1204668:	1085883a 	add	r2,r2,r2
 120466c:	1007883a 	mov	r3,r2
 1204670:	e0bffd17 	ldw	r2,-12(fp)
 1204674:	10c5883a 	add	r2,r2,r3
 1204678:	e0ffff03 	ldbu	r3,-4(fp)
 120467c:	10c00025 	stbio	r3,0(r2)
  return;
 1204680:	0001883a 	nop
}
 1204684:	e037883a 	mov	sp,fp
 1204688:	df000017 	ldw	fp,0(sp)
 120468c:	dec00104 	addi	sp,sp,4
 1204690:	f800283a 	ret

01204694 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 1204694:	defffc04 	addi	sp,sp,-16
 1204698:	df000315 	stw	fp,12(sp)
 120469c:	df000304 	addi	fp,sp,12
 12046a0:	e13ffd15 	stw	r4,-12(fp)
 12046a4:	e17ffe15 	stw	r5,-8(fp)
 12046a8:	3005883a 	mov	r2,r6
 12046ac:	e0bfff05 	stb	r2,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 12046b0:	e0bffe17 	ldw	r2,-8(fp)
 12046b4:	1085883a 	add	r2,r2,r2
 12046b8:	1007883a 	mov	r3,r2
 12046bc:	e0bffd17 	ldw	r2,-12(fp)
 12046c0:	10c5883a 	add	r2,r2,r3
 12046c4:	e0ffff03 	ldbu	r3,-4(fp)
 12046c8:	10c0002d 	sthio	r3,0(r2)
  return;
 12046cc:	0001883a 	nop
}
 12046d0:	e037883a 	mov	sp,fp
 12046d4:	df000017 	ldw	fp,0(sp)
 12046d8:	dec00104 	addi	sp,sp,4
 12046dc:	f800283a 	ret

012046e0 <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 12046e0:	defffc04 	addi	sp,sp,-16
 12046e4:	df000315 	stw	fp,12(sp)
 12046e8:	df000304 	addi	fp,sp,12
 12046ec:	e13ffd15 	stw	r4,-12(fp)
 12046f0:	e17ffe15 	stw	r5,-8(fp)
 12046f4:	3005883a 	mov	r2,r6
 12046f8:	e0bfff05 	stb	r2,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 12046fc:	e0bffe17 	ldw	r2,-8(fp)
 1204700:	1085883a 	add	r2,r2,r2
 1204704:	1085883a 	add	r2,r2,r2
 1204708:	1007883a 	mov	r3,r2
 120470c:	e0bffd17 	ldw	r2,-12(fp)
 1204710:	10c5883a 	add	r2,r2,r3
 1204714:	e0ffff03 	ldbu	r3,-4(fp)
 1204718:	10c0002d 	sthio	r3,0(r2)
  return;
 120471c:	0001883a 	nop
}
 1204720:	e037883a 	mov	sp,fp
 1204724:	df000017 	ldw	fp,0(sp)
 1204728:	dec00104 	addi	sp,sp,4
 120472c:	f800283a 	ret

01204730 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 1204730:	defffc04 	addi	sp,sp,-16
 1204734:	df000315 	stw	fp,12(sp)
 1204738:	df000304 	addi	fp,sp,12
 120473c:	e13ffd15 	stw	r4,-12(fp)
 1204740:	e17ffe15 	stw	r5,-8(fp)
 1204744:	3005883a 	mov	r2,r6
 1204748:	e0bfff05 	stb	r2,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 120474c:	e0bffe17 	ldw	r2,-8(fp)
 1204750:	1085883a 	add	r2,r2,r2
 1204754:	1085883a 	add	r2,r2,r2
 1204758:	1007883a 	mov	r3,r2
 120475c:	e0bffd17 	ldw	r2,-12(fp)
 1204760:	10c5883a 	add	r2,r2,r3
 1204764:	e0ffff03 	ldbu	r3,-4(fp)
 1204768:	10c00035 	stwio	r3,0(r2)
  return;
 120476c:	0001883a 	nop
}
 1204770:	e037883a 	mov	sp,fp
 1204774:	df000017 	ldw	fp,0(sp)
 1204778:	dec00104 	addi	sp,sp,4
 120477c:	f800283a 	ret

01204780 <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 1204780:	defffd04 	addi	sp,sp,-12
 1204784:	df000215 	stw	fp,8(sp)
 1204788:	df000204 	addi	fp,sp,8
 120478c:	e13ffe15 	stw	r4,-8(fp)
 1204790:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 1204794:	e0bfff17 	ldw	r2,-4(fp)
 1204798:	10c03fcc 	andi	r3,r2,255
 120479c:	e0bffe17 	ldw	r2,-8(fp)
 12047a0:	10c00025 	stbio	r3,0(r2)
  return;
 12047a4:	0001883a 	nop
}
 12047a8:	e037883a 	mov	sp,fp
 12047ac:	df000017 	ldw	fp,0(sp)
 12047b0:	dec00104 	addi	sp,sp,4
 12047b4:	f800283a 	ret

012047b8 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 12047b8:	defffd04 	addi	sp,sp,-12
 12047bc:	df000215 	stw	fp,8(sp)
 12047c0:	df000204 	addi	fp,sp,8
 12047c4:	e13ffe15 	stw	r4,-8(fp)
 12047c8:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 12047cc:	e0bfff17 	ldw	r2,-4(fp)
 12047d0:	10ffffcc 	andi	r3,r2,65535
 12047d4:	e0bffe17 	ldw	r2,-8(fp)
 12047d8:	10c0002d 	sthio	r3,0(r2)
  return;
 12047dc:	0001883a 	nop
}
 12047e0:	e037883a 	mov	sp,fp
 12047e4:	df000017 	ldw	fp,0(sp)
 12047e8:	dec00104 	addi	sp,sp,4
 12047ec:	f800283a 	ret

012047f0 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 12047f0:	defffd04 	addi	sp,sp,-12
 12047f4:	df000215 	stw	fp,8(sp)
 12047f8:	df000204 	addi	fp,sp,8
 12047fc:	e13ffe15 	stw	r4,-8(fp)
 1204800:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 1204804:	e0ffff17 	ldw	r3,-4(fp)
 1204808:	e0bffe17 	ldw	r2,-8(fp)
 120480c:	10c00035 	stwio	r3,0(r2)
  return;
 1204810:	0001883a 	nop
}
 1204814:	e037883a 	mov	sp,fp
 1204818:	df000017 	ldw	fp,0(sp)
 120481c:	dec00104 	addi	sp,sp,4
 1204820:	f800283a 	ret

01204824 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 1204824:	defffd04 	addi	sp,sp,-12
 1204828:	df000215 	stw	fp,8(sp)
 120482c:	df000204 	addi	fp,sp,8
 1204830:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 1204834:	e03ffe15 	stw	zero,-8(fp)
  
  switch(flash->mode_width)
 1204838:	e0bfff17 	ldw	r2,-4(fp)
 120483c:	10802f17 	ldw	r2,188(r2)
 1204840:	10c000a0 	cmpeqi	r3,r2,2
 1204844:	1800241e 	bne	r3,zero,12048d8 <alt_set_flash_width_func+0xb4>
 1204848:	10c00120 	cmpeqi	r3,r2,4
 120484c:	1800391e 	bne	r3,zero,1204934 <alt_set_flash_width_func+0x110>
 1204850:	10800060 	cmpeqi	r2,r2,1
 1204854:	10004026 	beq	r2,zero,1204958 <alt_set_flash_width_func+0x134>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 1204858:	e0ffff17 	ldw	r3,-4(fp)
 120485c:	00804834 	movhi	r2,288
 1204860:	1091e004 	addi	r2,r2,18304
 1204864:	18803615 	stw	r2,216(r3)

      if (flash->device_width == 1)
 1204868:	e0bfff17 	ldw	r2,-4(fp)
 120486c:	10803017 	ldw	r2,192(r2)
 1204870:	10800058 	cmpnei	r2,r2,1
 1204874:	1000051e 	bne	r2,zero,120488c <alt_set_flash_width_func+0x68>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 1204878:	e0ffff17 	ldw	r3,-4(fp)
 120487c:	00804834 	movhi	r2,288
 1204880:	10916204 	addi	r2,r2,17800
 1204884:	18803415 	stw	r2,208(r3)
 1204888:	00001206 	br	12048d4 <alt_set_flash_width_func+0xb0>
      }
      else if (flash->device_width == 2)
 120488c:	e0bfff17 	ldw	r2,-4(fp)
 1204890:	10803017 	ldw	r2,192(r2)
 1204894:	10800098 	cmpnei	r2,r2,2
 1204898:	1000051e 	bne	r2,zero,12048b0 <alt_set_flash_width_func+0x8c>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 120489c:	e0ffff17 	ldw	r3,-4(fp)
 12048a0:	00804834 	movhi	r2,288
 12048a4:	10917304 	addi	r2,r2,17868
 12048a8:	18803415 	stw	r2,208(r3)
 12048ac:	00000906 	br	12048d4 <alt_set_flash_width_func+0xb0>
      }
      else if (flash->device_width == 4)
 12048b0:	e0bfff17 	ldw	r2,-4(fp)
 12048b4:	10803017 	ldw	r2,192(r2)
 12048b8:	10800118 	cmpnei	r2,r2,4
 12048bc:	1000051e 	bne	r2,zero,12048d4 <alt_set_flash_width_func+0xb0>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 12048c0:	e0ffff17 	ldw	r3,-4(fp)
 12048c4:	00804834 	movhi	r2,288
 12048c8:	10919104 	addi	r2,r2,17988
 12048cc:	18803415 	stw	r2,208(r3)
      }
      break;
 12048d0:	00002306 	br	1204960 <alt_set_flash_width_func+0x13c>
 12048d4:	00002206 	br	1204960 <alt_set_flash_width_func+0x13c>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 12048d8:	e0ffff17 	ldw	r3,-4(fp)
 12048dc:	00804834 	movhi	r2,288
 12048e0:	1091ee04 	addi	r2,r2,18360
 12048e4:	18803615 	stw	r2,216(r3)

      if (flash->device_width == 2)
 12048e8:	e0bfff17 	ldw	r2,-4(fp)
 12048ec:	10803017 	ldw	r2,192(r2)
 12048f0:	10800098 	cmpnei	r2,r2,2
 12048f4:	1000051e 	bne	r2,zero,120490c <alt_set_flash_width_func+0xe8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 12048f8:	e0ffff17 	ldw	r3,-4(fp)
 12048fc:	00804834 	movhi	r2,288
 1204900:	1091a504 	addi	r2,r2,18068
 1204904:	18803415 	stw	r2,208(r3)
 1204908:	00000906 	br	1204930 <alt_set_flash_width_func+0x10c>
      }
      else if (flash->device_width == 4)
 120490c:	e0bfff17 	ldw	r2,-4(fp)
 1204910:	10803017 	ldw	r2,192(r2)
 1204914:	10800118 	cmpnei	r2,r2,4
 1204918:	1000051e 	bne	r2,zero,1204930 <alt_set_flash_width_func+0x10c>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 120491c:	e0ffff17 	ldw	r3,-4(fp)
 1204920:	00804834 	movhi	r2,288
 1204924:	1091b804 	addi	r2,r2,18144
 1204928:	18803415 	stw	r2,208(r3)
      }

      break;
 120492c:	00000c06 	br	1204960 <alt_set_flash_width_func+0x13c>
 1204930:	00000b06 	br	1204960 <alt_set_flash_width_func+0x13c>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 1204934:	e0ffff17 	ldw	r3,-4(fp)
 1204938:	00804834 	movhi	r2,288
 120493c:	1091fc04 	addi	r2,r2,18416
 1204940:	18803615 	stw	r2,216(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 1204944:	e0ffff17 	ldw	r3,-4(fp)
 1204948:	00804834 	movhi	r2,288
 120494c:	1091cc04 	addi	r2,r2,18224
 1204950:	18803415 	stw	r2,208(r3)
      break;
 1204954:	00000206 	br	1204960 <alt_set_flash_width_func+0x13c>
    }
    default:
    {
      ret_code = -EACCES;
 1204958:	00bffcc4 	movi	r2,-13
 120495c:	e0bffe15 	stw	r2,-8(fp)
    }
  }

  if (!ret_code)
 1204960:	e0bffe17 	ldw	r2,-8(fp)
 1204964:	1000191e 	bne	r2,zero,12049cc <alt_set_flash_width_func+0x1a8>
  {
    switch(flash->device_width)
 1204968:	e0bfff17 	ldw	r2,-4(fp)
 120496c:	10803017 	ldw	r2,192(r2)
 1204970:	10c000a0 	cmpeqi	r3,r2,2
 1204974:	1800091e 	bne	r3,zero,120499c <alt_set_flash_width_func+0x178>
 1204978:	10c00120 	cmpeqi	r3,r2,4
 120497c:	18000c1e 	bne	r3,zero,12049b0 <alt_set_flash_width_func+0x18c>
 1204980:	10800060 	cmpeqi	r2,r2,1
 1204984:	10000f26 	beq	r2,zero,12049c4 <alt_set_flash_width_func+0x1a0>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 1204988:	e0ffff17 	ldw	r3,-4(fp)
 120498c:	00804834 	movhi	r2,288
 1204990:	10913304 	addi	r2,r2,17612
 1204994:	18803515 	stw	r2,212(r3)
        break;
 1204998:	00000c06 	br	12049cc <alt_set_flash_width_func+0x1a8>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 120499c:	e0ffff17 	ldw	r3,-4(fp)
 12049a0:	00804834 	movhi	r2,288
 12049a4:	10914204 	addi	r2,r2,17672
 12049a8:	18803515 	stw	r2,212(r3)
        break;
 12049ac:	00000706 	br	12049cc <alt_set_flash_width_func+0x1a8>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 12049b0:	e0ffff17 	ldw	r3,-4(fp)
 12049b4:	00804834 	movhi	r2,288
 12049b8:	10915204 	addi	r2,r2,17736
 12049bc:	18803515 	stw	r2,212(r3)
        break;
 12049c0:	00000206 	br	12049cc <alt_set_flash_width_func+0x1a8>
      }
      default:
      {
        ret_code = -EACCES;
 12049c4:	00bffcc4 	movi	r2,-13
 12049c8:	e0bffe15 	stw	r2,-8(fp)
      }
    }
  }

  return ret_code;
 12049cc:	e0bffe17 	ldw	r2,-8(fp)
}
 12049d0:	e037883a 	mov	sp,fp
 12049d4:	df000017 	ldw	fp,0(sp)
 12049d8:	dec00104 	addi	sp,sp,4
 12049dc:	f800283a 	ret

012049e0 <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 12049e0:	defffd04 	addi	sp,sp,-12
 12049e4:	df000215 	stw	fp,8(sp)
 12049e8:	df000204 	addi	fp,sp,8
 12049ec:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 12049f0:	e03ffe15 	stw	zero,-8(fp)
 
  switch(flash->algorithm)
 12049f4:	e0bfff17 	ldw	r2,-4(fp)
 12049f8:	10802e17 	ldw	r2,184(r2)
 12049fc:	10c000a0 	cmpeqi	r3,r2,2
 1204a00:	1800051e 	bne	r3,zero,1204a18 <alt_set_flash_algorithm_func+0x38>
 1204a04:	10c000e0 	cmpeqi	r3,r2,3
 1204a08:	18000c1e 	bne	r3,zero,1204a3c <alt_set_flash_algorithm_func+0x5c>
 1204a0c:	10800060 	cmpeqi	r2,r2,1
 1204a10:	10000a1e 	bne	r2,zero,1204a3c <alt_set_flash_algorithm_func+0x5c>
 1204a14:	00001206 	br	1204a60 <alt_set_flash_algorithm_func+0x80>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 1204a18:	e0ffff17 	ldw	r3,-4(fp)
 1204a1c:	00804834 	movhi	r2,288
 1204a20:	109c1104 	addi	r2,r2,28740
 1204a24:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 1204a28:	e0ffff17 	ldw	r3,-4(fp)
 1204a2c:	00804834 	movhi	r2,288
 1204a30:	109bf704 	addi	r2,r2,28636
 1204a34:	18800915 	stw	r2,36(r3)
      break;
 1204a38:	00000b06 	br	1204a68 <alt_set_flash_algorithm_func+0x88>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 1204a3c:	e0ffff17 	ldw	r3,-4(fp)
 1204a40:	00804834 	movhi	r2,288
 1204a44:	109d2f04 	addi	r2,r2,29884
 1204a48:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 1204a4c:	e0ffff17 	ldw	r3,-4(fp)
 1204a50:	00804834 	movhi	r2,288
 1204a54:	109d0f04 	addi	r2,r2,29756
 1204a58:	18800915 	stw	r2,36(r3)
      break;
 1204a5c:	00000206 	br	1204a68 <alt_set_flash_algorithm_func+0x88>
    }
    default:
    {
      ret_code = -EIO;
 1204a60:	00bffec4 	movi	r2,-5
 1204a64:	e0bffe15 	stw	r2,-8(fp)
    }
  } 
  return ret_code;  
 1204a68:	e0bffe17 	ldw	r2,-8(fp)
}
 1204a6c:	e037883a 	mov	sp,fp
 1204a70:	df000017 	ldw	fp,0(sp)
 1204a74:	dec00104 	addi	sp,sp,4
 1204a78:	f800283a 	ret

01204a7c <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 1204a7c:	defffb04 	addi	sp,sp,-20
 1204a80:	dfc00415 	stw	ra,16(sp)
 1204a84:	df000315 	stw	fp,12(sp)
 1204a88:	df000304 	addi	fp,sp,12
 1204a8c:	e13ffe15 	stw	r4,-8(fp)
 1204a90:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 1204a94:	e0bffe17 	ldw	r2,-8(fp)
 1204a98:	10803517 	ldw	r2,212(r2)
 1204a9c:	e13ffe17 	ldw	r4,-8(fp)
 1204aa0:	e17fff17 	ldw	r5,-4(fp)
 1204aa4:	103ee83a 	callr	r2
 1204aa8:	10803fcc 	andi	r2,r2,255
 1204aac:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 1204ab0:	e0bffe17 	ldw	r2,-8(fp)
 1204ab4:	10803517 	ldw	r2,212(r2)
 1204ab8:	e0ffff17 	ldw	r3,-4(fp)
 1204abc:	18c00044 	addi	r3,r3,1
 1204ac0:	e13ffe17 	ldw	r4,-8(fp)
 1204ac4:	180b883a 	mov	r5,r3
 1204ac8:	103ee83a 	callr	r2
 1204acc:	10803fcc 	andi	r2,r2,255
 1204ad0:	1004923a 	slli	r2,r2,8
 1204ad4:	1007883a 	mov	r3,r2
 1204ad8:	e0bffd0b 	ldhu	r2,-12(fp)
 1204adc:	1884b03a 	or	r2,r3,r2
 1204ae0:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 1204ae4:	e0bffd0b 	ldhu	r2,-12(fp)
}
 1204ae8:	e037883a 	mov	sp,fp
 1204aec:	dfc00117 	ldw	ra,4(sp)
 1204af0:	df000017 	ldw	fp,0(sp)
 1204af4:	dec00204 	addi	sp,sp,8
 1204af8:	f800283a 	ret

01204afc <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 1204afc:	defff304 	addi	sp,sp,-52
 1204b00:	dfc00c15 	stw	ra,48(sp)
 1204b04:	df000b15 	stw	fp,44(sp)
 1204b08:	df000b04 	addi	fp,sp,44
 1204b0c:	e13fff15 	stw	r4,-4(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 1204b10:	e03ff715 	stw	zero,-36(fp)
  int   size = 0;
 1204b14:	e03ff815 	stw	zero,-32(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 1204b18:	e03ff915 	stw	zero,-28(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 1204b1c:	e13fff17 	ldw	r4,-4(fp)
 1204b20:	12058480 	call	1205848 <alt_check_primary_table>
 1204b24:	e0bff715 	stw	r2,-36(fp)

  if (!ret_code)
 1204b28:	e0bff717 	ldw	r2,-36(fp)
 1204b2c:	10015f1e 	bne	r2,zero,12050ac <alt_read_cfi_table+0x5b0>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 1204b30:	e0bfff17 	ldw	r2,-4(fp)
 1204b34:	10803517 	ldw	r2,212(r2)
 1204b38:	e13fff17 	ldw	r4,-4(fp)
 1204b3c:	014004c4 	movi	r5,19
 1204b40:	103ee83a 	callr	r2
 1204b44:	10c03fcc 	andi	r3,r2,255
 1204b48:	e0bfff17 	ldw	r2,-4(fp)
 1204b4c:	10c02e15 	stw	r3,184(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 1204b50:	e0bfff17 	ldw	r2,-4(fp)
 1204b54:	10803517 	ldw	r2,212(r2)
 1204b58:	e13fff17 	ldw	r4,-4(fp)
 1204b5c:	014007c4 	movi	r5,31
 1204b60:	103ee83a 	callr	r2
 1204b64:	10803fcc 	andi	r2,r2,255
 1204b68:	e0bffa15 	stw	r2,-24(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 1204b6c:	e0bfff17 	ldw	r2,-4(fp)
 1204b70:	10803517 	ldw	r2,212(r2)
 1204b74:	e13fff17 	ldw	r4,-4(fp)
 1204b78:	014008c4 	movi	r5,35
 1204b7c:	103ee83a 	callr	r2
 1204b80:	10803fcc 	andi	r2,r2,255
 1204b84:	e0bffb15 	stw	r2,-20(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 1204b88:	e0bffa17 	ldw	r2,-24(fp)
 1204b8c:	10000226 	beq	r2,zero,1204b98 <alt_read_cfi_table+0x9c>
 1204b90:	e0bffb17 	ldw	r2,-20(fp)
 1204b94:	1000041e 	bne	r2,zero,1204ba8 <alt_read_cfi_table+0xac>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 1204b98:	e0bfff17 	ldw	r2,-4(fp)
 1204b9c:	00c0fa04 	movi	r3,1000
 1204ba0:	10c03115 	stw	r3,196(r2)
 1204ba4:	00000706 	br	1204bc4 <alt_read_cfi_table+0xc8>
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 1204ba8:	00c00044 	movi	r3,1
 1204bac:	e0bffa17 	ldw	r2,-24(fp)
 1204bb0:	1886983a 	sll	r3,r3,r2
 1204bb4:	e0bffb17 	ldw	r2,-20(fp)
 1204bb8:	1886983a 	sll	r3,r3,r2
 1204bbc:	e0bfff17 	ldw	r2,-4(fp)
 1204bc0:	10c03115 	stw	r3,196(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 1204bc4:	e0bfff17 	ldw	r2,-4(fp)
 1204bc8:	10803517 	ldw	r2,212(r2)
 1204bcc:	e13fff17 	ldw	r4,-4(fp)
 1204bd0:	01400844 	movi	r5,33
 1204bd4:	103ee83a 	callr	r2
 1204bd8:	10803fcc 	andi	r2,r2,255
 1204bdc:	e0bffa15 	stw	r2,-24(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 1204be0:	e0bfff17 	ldw	r2,-4(fp)
 1204be4:	10803517 	ldw	r2,212(r2)
 1204be8:	e13fff17 	ldw	r4,-4(fp)
 1204bec:	01400944 	movi	r5,37
 1204bf0:	103ee83a 	callr	r2
 1204bf4:	10803fcc 	andi	r2,r2,255
 1204bf8:	e0bffb15 	stw	r2,-20(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 1204bfc:	e0bffa17 	ldw	r2,-24(fp)
 1204c00:	10000226 	beq	r2,zero,1204c0c <alt_read_cfi_table+0x110>
 1204c04:	e0bffb17 	ldw	r2,-20(fp)
 1204c08:	1000051e 	bne	r2,zero,1204c20 <alt_read_cfi_table+0x124>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 1204c0c:	e0ffff17 	ldw	r3,-4(fp)
 1204c10:	00804c74 	movhi	r2,305
 1204c14:	108b4004 	addi	r2,r2,11520
 1204c18:	18803215 	stw	r2,200(r3)
 1204c1c:	00000806 	br	1204c40 <alt_read_cfi_table+0x144>
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 1204c20:	00c00044 	movi	r3,1
 1204c24:	e0bffa17 	ldw	r2,-24(fp)
 1204c28:	1886983a 	sll	r3,r3,r2
 1204c2c:	e0bffb17 	ldw	r2,-20(fp)
 1204c30:	1884983a 	sll	r2,r3,r2
 1204c34:	10c0fa24 	muli	r3,r2,1000
 1204c38:	e0bfff17 	ldw	r2,-4(fp)
 1204c3c:	10c03215 	stw	r3,200(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 1204c40:	e0bfff17 	ldw	r2,-4(fp)
 1204c44:	10803517 	ldw	r2,212(r2)
 1204c48:	e13fff17 	ldw	r4,-4(fp)
 1204c4c:	014009c4 	movi	r5,39
 1204c50:	103ee83a 	callr	r2
 1204c54:	10803fcc 	andi	r2,r2,255
 1204c58:	00c00044 	movi	r3,1
 1204c5c:	1884983a 	sll	r2,r3,r2
 1204c60:	e0bffc15 	stw	r2,-16(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 1204c64:	e0bfff17 	ldw	r2,-4(fp)
 1204c68:	10803517 	ldw	r2,212(r2)
 1204c6c:	e13fff17 	ldw	r4,-4(fp)
 1204c70:	01400b04 	movi	r5,44
 1204c74:	103ee83a 	callr	r2
 1204c78:	10c03fcc 	andi	r3,r2,255
 1204c7c:	e0bfff17 	ldw	r2,-4(fp)
 1204c80:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 1204c84:	e0bfff17 	ldw	r2,-4(fp)
 1204c88:	10800c17 	ldw	r2,48(r2)
 1204c8c:	10800250 	cmplti	r2,r2,9
 1204c90:	1000031e 	bne	r2,zero,1204ca0 <alt_read_cfi_table+0x1a4>
    {
      ret_code = -ENOMEM;
 1204c94:	00bffd04 	movi	r2,-12
 1204c98:	e0bff715 	stw	r2,-36(fp)
 1204c9c:	00006006 	br	1204e20 <alt_read_cfi_table+0x324>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 1204ca0:	e03ff515 	stw	zero,-44(fp)
 1204ca4:	00005506 	br	1204dfc <alt_read_cfi_table+0x300>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
                                                            flash,
                                                            (0x2D+i*4));
 1204ca8:	e0bff517 	ldw	r2,-44(fp)
 1204cac:	1085883a 	add	r2,r2,r2
 1204cb0:	1085883a 	add	r2,r2,r2
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 1204cb4:	10800b44 	addi	r2,r2,45
 1204cb8:	e13fff17 	ldw	r4,-4(fp)
 1204cbc:	100b883a 	mov	r5,r2
 1204cc0:	1204a7c0 	call	1204a7c <alt_read_16bit_query_entry>
 1204cc4:	10ffffcc 	andi	r3,r2,65535
 1204cc8:	e13fff17 	ldw	r4,-4(fp)
 1204ccc:	e0bff517 	ldw	r2,-44(fp)
 1204cd0:	1004913a 	slli	r2,r2,4
 1204cd4:	2085883a 	add	r2,r4,r2
 1204cd8:	10800f04 	addi	r2,r2,60
 1204cdc:	10c00015 	stw	r3,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 1204ce0:	e0ffff17 	ldw	r3,-4(fp)
 1204ce4:	e0bff517 	ldw	r2,-44(fp)
 1204ce8:	1004913a 	slli	r2,r2,4
 1204cec:	1885883a 	add	r2,r3,r2
 1204cf0:	10800f04 	addi	r2,r2,60
 1204cf4:	10800017 	ldw	r2,0(r2)
 1204cf8:	10c00044 	addi	r3,r2,1
 1204cfc:	e13fff17 	ldw	r4,-4(fp)
 1204d00:	e0bff517 	ldw	r2,-44(fp)
 1204d04:	1004913a 	slli	r2,r2,4
 1204d08:	2085883a 	add	r2,r4,r2
 1204d0c:	10800f04 	addi	r2,r2,60
 1204d10:	10c00015 	stw	r3,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
                                                              (0x2F+i*4));
 1204d14:	e0bff517 	ldw	r2,-44(fp)
 1204d18:	1085883a 	add	r2,r2,r2
 1204d1c:	1085883a 	add	r2,r2,r2
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 1204d20:	10800bc4 	addi	r2,r2,47
 1204d24:	e13fff17 	ldw	r4,-4(fp)
 1204d28:	100b883a 	mov	r5,r2
 1204d2c:	1204a7c0 	call	1204a7c <alt_read_16bit_query_entry>
 1204d30:	10ffffcc 	andi	r3,r2,65535
 1204d34:	e13fff17 	ldw	r4,-4(fp)
 1204d38:	e0bff517 	ldw	r2,-44(fp)
 1204d3c:	10800104 	addi	r2,r2,4
 1204d40:	1004913a 	slli	r2,r2,4
 1204d44:	2085883a 	add	r2,r4,r2
 1204d48:	10c00015 	stw	r3,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 1204d4c:	e0ffff17 	ldw	r3,-4(fp)
 1204d50:	e0bff517 	ldw	r2,-44(fp)
 1204d54:	10800104 	addi	r2,r2,4
 1204d58:	1004913a 	slli	r2,r2,4
 1204d5c:	1885883a 	add	r2,r3,r2
 1204d60:	10800017 	ldw	r2,0(r2)
 1204d64:	1006923a 	slli	r3,r2,8
 1204d68:	e13fff17 	ldw	r4,-4(fp)
 1204d6c:	e0bff517 	ldw	r2,-44(fp)
 1204d70:	10800104 	addi	r2,r2,4
 1204d74:	1004913a 	slli	r2,r2,4
 1204d78:	2085883a 	add	r2,r4,r2
 1204d7c:	10c00015 	stw	r3,0(r2)
        flash->dev.region_info[i].region_size = 
                                    flash->dev.region_info[i].number_of_blocks 
 1204d80:	e0ffff17 	ldw	r3,-4(fp)
 1204d84:	e0bff517 	ldw	r2,-44(fp)
 1204d88:	1004913a 	slli	r2,r2,4
 1204d8c:	1885883a 	add	r2,r3,r2
 1204d90:	10800f04 	addi	r2,r2,60
 1204d94:	10c00017 	ldw	r3,0(r2)
                                    * flash->dev.region_info[i].block_size;
 1204d98:	e13fff17 	ldw	r4,-4(fp)
 1204d9c:	e0bff517 	ldw	r2,-44(fp)
 1204da0:	10800104 	addi	r2,r2,4
 1204da4:	1004913a 	slli	r2,r2,4
 1204da8:	2085883a 	add	r2,r4,r2
 1204dac:	10800017 	ldw	r2,0(r2)
 1204db0:	1887383a 	mul	r3,r3,r2
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
        flash->dev.region_info[i].region_size = 
 1204db4:	e13fff17 	ldw	r4,-4(fp)
 1204db8:	e0bff517 	ldw	r2,-44(fp)
 1204dbc:	1004913a 	slli	r2,r2,4
 1204dc0:	2085883a 	add	r2,r4,r2
 1204dc4:	10800e04 	addi	r2,r2,56
 1204dc8:	10c00015 	stw	r3,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 1204dcc:	e0ffff17 	ldw	r3,-4(fp)
 1204dd0:	e0bff517 	ldw	r2,-44(fp)
 1204dd4:	1004913a 	slli	r2,r2,4
 1204dd8:	1885883a 	add	r2,r3,r2
 1204ddc:	10800e04 	addi	r2,r2,56
 1204de0:	10800017 	ldw	r2,0(r2)
 1204de4:	e0fff817 	ldw	r3,-32(fp)
 1204de8:	1885883a 	add	r2,r3,r2
 1204dec:	e0bff815 	stw	r2,-32(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 1204df0:	e0bff517 	ldw	r2,-44(fp)
 1204df4:	10800044 	addi	r2,r2,1
 1204df8:	e0bff515 	stw	r2,-44(fp)
 1204dfc:	e0bfff17 	ldw	r2,-4(fp)
 1204e00:	10800c17 	ldw	r2,48(r2)
 1204e04:	e0fff517 	ldw	r3,-44(fp)
 1204e08:	18bfa716 	blt	r3,r2,1204ca8 <__alt_mem_instruction_tcm+0xff204ca8>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 1204e0c:	e0fff817 	ldw	r3,-32(fp)
 1204e10:	e0bffc17 	ldw	r2,-16(fp)
 1204e14:	18800226 	beq	r3,r2,1204e20 <alt_read_cfi_table+0x324>
      {
        ret_code = -ENODEV;
 1204e18:	00bffb44 	movi	r2,-19
 1204e1c:	e0bff715 	stw	r2,-36(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 1204e20:	e0bfff17 	ldw	r2,-4(fp)
 1204e24:	10803517 	ldw	r2,212(r2)
 1204e28:	e0ffff17 	ldw	r3,-4(fp)
 1204e2c:	18c03317 	ldw	r3,204(r3)
 1204e30:	18c003c4 	addi	r3,r3,15
 1204e34:	e13fff17 	ldw	r4,-4(fp)
 1204e38:	180b883a 	mov	r5,r3
 1204e3c:	103ee83a 	callr	r2
 1204e40:	e0bffd05 	stb	r2,-12(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 1204e44:	e0bfff17 	ldw	r2,-4(fp)
 1204e48:	10802e17 	ldw	r2,184(r2)
 1204e4c:	10800098 	cmpnei	r2,r2,2
 1204e50:	1000601e 	bne	r2,zero,1204fd4 <alt_read_cfi_table+0x4d8>
 1204e54:	e0bffd03 	ldbu	r2,-12(fp)
 1204e58:	108000d8 	cmpnei	r2,r2,3
 1204e5c:	10005d1e 	bne	r2,zero,1204fd4 <alt_read_cfi_table+0x4d8>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 1204e60:	e0bfff17 	ldw	r2,-4(fp)
 1204e64:	10800c17 	ldw	r2,48(r2)
 1204e68:	10bfffc4 	addi	r2,r2,-1
 1204e6c:	e0bff515 	stw	r2,-44(fp)
 1204e70:	e03ff615 	stw	zero,-40(fp)
 1204e74:	00005406 	br	1204fc8 <alt_read_cfi_table+0x4cc>
          j<=i;i--,j++)
      {
        swap = flash->dev.region_info[i].region_size;
 1204e78:	e0ffff17 	ldw	r3,-4(fp)
 1204e7c:	e0bff517 	ldw	r2,-44(fp)
 1204e80:	1004913a 	slli	r2,r2,4
 1204e84:	1885883a 	add	r2,r3,r2
 1204e88:	10800e04 	addi	r2,r2,56
 1204e8c:	10800017 	ldw	r2,0(r2)
 1204e90:	e0bffe15 	stw	r2,-8(fp)
        flash->dev.region_info[i].region_size =  
                                flash->dev.region_info[j].region_size;
 1204e94:	e0ffff17 	ldw	r3,-4(fp)
 1204e98:	e0bff617 	ldw	r2,-40(fp)
 1204e9c:	1004913a 	slli	r2,r2,4
 1204ea0:	1885883a 	add	r2,r3,r2
 1204ea4:	10800e04 	addi	r2,r2,56
 1204ea8:	10c00017 	ldw	r3,0(r2)
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
      {
        swap = flash->dev.region_info[i].region_size;
        flash->dev.region_info[i].region_size =  
 1204eac:	e13fff17 	ldw	r4,-4(fp)
 1204eb0:	e0bff517 	ldw	r2,-44(fp)
 1204eb4:	1004913a 	slli	r2,r2,4
 1204eb8:	2085883a 	add	r2,r4,r2
 1204ebc:	10800e04 	addi	r2,r2,56
 1204ec0:	10c00015 	stw	r3,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 1204ec4:	e0ffff17 	ldw	r3,-4(fp)
 1204ec8:	e0bff617 	ldw	r2,-40(fp)
 1204ecc:	1004913a 	slli	r2,r2,4
 1204ed0:	1885883a 	add	r2,r3,r2
 1204ed4:	10800e04 	addi	r2,r2,56
 1204ed8:	e0fffe17 	ldw	r3,-8(fp)
 1204edc:	10c00015 	stw	r3,0(r2)

        swap = flash->dev.region_info[i].block_size;
 1204ee0:	e0ffff17 	ldw	r3,-4(fp)
 1204ee4:	e0bff517 	ldw	r2,-44(fp)
 1204ee8:	10800104 	addi	r2,r2,4
 1204eec:	1004913a 	slli	r2,r2,4
 1204ef0:	1885883a 	add	r2,r3,r2
 1204ef4:	10800017 	ldw	r2,0(r2)
 1204ef8:	e0bffe15 	stw	r2,-8(fp)
        flash->dev.region_info[i].block_size =  
                                flash->dev.region_info[j].block_size;
 1204efc:	e0ffff17 	ldw	r3,-4(fp)
 1204f00:	e0bff617 	ldw	r2,-40(fp)
 1204f04:	10800104 	addi	r2,r2,4
 1204f08:	1004913a 	slli	r2,r2,4
 1204f0c:	1885883a 	add	r2,r3,r2
 1204f10:	10c00017 	ldw	r3,0(r2)
        flash->dev.region_info[i].region_size =  
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;

        swap = flash->dev.region_info[i].block_size;
        flash->dev.region_info[i].block_size =  
 1204f14:	e13fff17 	ldw	r4,-4(fp)
 1204f18:	e0bff517 	ldw	r2,-44(fp)
 1204f1c:	10800104 	addi	r2,r2,4
 1204f20:	1004913a 	slli	r2,r2,4
 1204f24:	2085883a 	add	r2,r4,r2
 1204f28:	10c00015 	stw	r3,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 1204f2c:	e0ffff17 	ldw	r3,-4(fp)
 1204f30:	e0bff617 	ldw	r2,-40(fp)
 1204f34:	10800104 	addi	r2,r2,4
 1204f38:	1004913a 	slli	r2,r2,4
 1204f3c:	1885883a 	add	r2,r3,r2
 1204f40:	e0fffe17 	ldw	r3,-8(fp)
 1204f44:	10c00015 	stw	r3,0(r2)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 1204f48:	e0ffff17 	ldw	r3,-4(fp)
 1204f4c:	e0bff517 	ldw	r2,-44(fp)
 1204f50:	1004913a 	slli	r2,r2,4
 1204f54:	1885883a 	add	r2,r3,r2
 1204f58:	10800f04 	addi	r2,r2,60
 1204f5c:	10800017 	ldw	r2,0(r2)
 1204f60:	e0bffe15 	stw	r2,-8(fp)
        flash->dev.region_info[i].number_of_blocks =  
                                flash->dev.region_info[j].number_of_blocks;
 1204f64:	e0ffff17 	ldw	r3,-4(fp)
 1204f68:	e0bff617 	ldw	r2,-40(fp)
 1204f6c:	1004913a 	slli	r2,r2,4
 1204f70:	1885883a 	add	r2,r3,r2
 1204f74:	10800f04 	addi	r2,r2,60
 1204f78:	10c00017 	ldw	r3,0(r2)
        flash->dev.region_info[i].block_size =  
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 
        swap = flash->dev.region_info[i].number_of_blocks;
        flash->dev.region_info[i].number_of_blocks =  
 1204f7c:	e13fff17 	ldw	r4,-4(fp)
 1204f80:	e0bff517 	ldw	r2,-44(fp)
 1204f84:	1004913a 	slli	r2,r2,4
 1204f88:	2085883a 	add	r2,r4,r2
 1204f8c:	10800f04 	addi	r2,r2,60
 1204f90:	10c00015 	stw	r3,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 1204f94:	e0ffff17 	ldw	r3,-4(fp)
 1204f98:	e0bff617 	ldw	r2,-40(fp)
 1204f9c:	1004913a 	slli	r2,r2,4
 1204fa0:	1885883a 	add	r2,r3,r2
 1204fa4:	10800f04 	addi	r2,r2,60
 1204fa8:	e0fffe17 	ldw	r3,-8(fp)
 1204fac:	10c00015 	stw	r3,0(r2)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 1204fb0:	e0bff517 	ldw	r2,-44(fp)
 1204fb4:	10bfffc4 	addi	r2,r2,-1
 1204fb8:	e0bff515 	stw	r2,-44(fp)
 1204fbc:	e0bff617 	ldw	r2,-40(fp)
 1204fc0:	10800044 	addi	r2,r2,1
 1204fc4:	e0bff615 	stw	r2,-40(fp)
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 1204fc8:	e0bff617 	ldw	r2,-40(fp)
 1204fcc:	e0fff517 	ldw	r3,-44(fp)
 1204fd0:	18bfa90e 	bge	r3,r2,1204e78 <__alt_mem_instruction_tcm+0xff204e78>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 1204fd4:	e03ff515 	stw	zero,-44(fp)
 1204fd8:	00001306 	br	1205028 <alt_read_cfi_table+0x52c>
    {
      flash->dev.region_info[i].offset = offset;
 1204fdc:	e0ffff17 	ldw	r3,-4(fp)
 1204fe0:	e0bff517 	ldw	r2,-44(fp)
 1204fe4:	1004913a 	slli	r2,r2,4
 1204fe8:	1885883a 	add	r2,r3,r2
 1204fec:	10800d04 	addi	r2,r2,52
 1204ff0:	e0fff917 	ldw	r3,-28(fp)
 1204ff4:	10c00015 	stw	r3,0(r2)
      offset += flash->dev.region_info[i].region_size;
 1204ff8:	e0ffff17 	ldw	r3,-4(fp)
 1204ffc:	e0bff517 	ldw	r2,-44(fp)
 1205000:	1004913a 	slli	r2,r2,4
 1205004:	1885883a 	add	r2,r3,r2
 1205008:	10800e04 	addi	r2,r2,56
 120500c:	10800017 	ldw	r2,0(r2)
 1205010:	e0fff917 	ldw	r3,-28(fp)
 1205014:	1885883a 	add	r2,r3,r2
 1205018:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 120501c:	e0bff517 	ldw	r2,-44(fp)
 1205020:	10800044 	addi	r2,r2,1
 1205024:	e0bff515 	stw	r2,-44(fp)
 1205028:	e0bfff17 	ldw	r2,-4(fp)
 120502c:	10800c17 	ldw	r2,48(r2)
 1205030:	e0fff517 	ldw	r3,-44(fp)
 1205034:	18bfe916 	blt	r3,r2,1204fdc <__alt_mem_instruction_tcm+0xff204fdc>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
 1205038:	e0bfff17 	ldw	r2,-4(fp)
 120503c:	10802e17 	ldw	r2,184(r2)
 1205040:	10c000a0 	cmpeqi	r3,r2,2
 1205044:	1800051e 	bne	r3,zero,120505c <alt_read_cfi_table+0x560>
 1205048:	10c000e0 	cmpeqi	r3,r2,3
 120504c:	18000c1e 	bne	r3,zero,1205080 <alt_read_cfi_table+0x584>
 1205050:	10800060 	cmpeqi	r2,r2,1
 1205054:	10000a1e 	bne	r2,zero,1205080 <alt_read_cfi_table+0x584>
 1205058:	00001206 	br	12050a4 <alt_read_cfi_table+0x5a8>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 120505c:	e0bfff17 	ldw	r2,-4(fp)
 1205060:	10803417 	ldw	r2,208(r2)
 1205064:	e0ffff17 	ldw	r3,-4(fp)
 1205068:	18c00a17 	ldw	r3,40(r3)
 120506c:	1809883a 	mov	r4,r3
 1205070:	01401544 	movi	r5,85
 1205074:	01803c04 	movi	r6,240
 1205078:	103ee83a 	callr	r2
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
 120507c:	00000b06 	br	12050ac <alt_read_cfi_table+0x5b0>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 1205080:	e0bfff17 	ldw	r2,-4(fp)
 1205084:	10803417 	ldw	r2,208(r2)
 1205088:	e0ffff17 	ldw	r3,-4(fp)
 120508c:	18c00a17 	ldw	r3,40(r3)
 1205090:	1809883a 	mov	r4,r3
 1205094:	01401544 	movi	r5,85
 1205098:	01803fc4 	movi	r6,255
 120509c:	103ee83a 	callr	r2
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
 12050a0:	00000206 	br	12050ac <alt_read_cfi_table+0x5b0>
      }
      default:
      {
        ret_code = -EIO;
 12050a4:	00bffec4 	movi	r2,-5
 12050a8:	e0bff715 	stw	r2,-36(fp)
      }
    } 
  }  

  return ret_code;
 12050ac:	e0bff717 	ldw	r2,-36(fp)
}
 12050b0:	e037883a 	mov	sp,fp
 12050b4:	dfc00117 	ldw	ra,4(sp)
 12050b8:	df000017 	ldw	fp,0(sp)
 12050bc:	dec00204 	addi	sp,sp,8
 12050c0:	f800283a 	ret

012050c4 <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 12050c4:	defff704 	addi	sp,sp,-36
 12050c8:	dfc00815 	stw	ra,32(sp)
 12050cc:	df000715 	stw	fp,28(sp)
 12050d0:	df000704 	addi	fp,sp,28
 12050d4:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 12050d8:	e03ffa15 	stw	zero,-24(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 12050dc:	e0bfff17 	ldw	r2,-4(fp)
 12050e0:	10800a17 	ldw	r2,40(r2)
 12050e4:	1009883a 	mov	r4,r2
 12050e8:	01401544 	movi	r5,85
 12050ec:	01802604 	movi	r6,152
 12050f0:	12045880 	call	1204588 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 12050f4:	e03ff915 	stw	zero,-28(fp)
 12050f8:	00000f06 	br	1205138 <alt_read_cfi_width+0x74>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 12050fc:	e0bfff17 	ldw	r2,-4(fp)
 1205100:	10800a17 	ldw	r2,40(r2)
 1205104:	e0fff917 	ldw	r3,-28(fp)
 1205108:	18c00404 	addi	r3,r3,16
 120510c:	10c5883a 	add	r2,r2,r3
 1205110:	10800023 	ldbuio	r2,0(r2)
 1205114:	10803fcc 	andi	r2,r2,255
 1205118:	1009883a 	mov	r4,r2
 120511c:	e0fffb84 	addi	r3,fp,-18
 1205120:	e0bff917 	ldw	r2,-28(fp)
 1205124:	1885883a 	add	r2,r3,r2
 1205128:	11000005 	stb	r4,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 120512c:	e0bff917 	ldw	r2,-28(fp)
 1205130:	10800044 	addi	r2,r2,1
 1205134:	e0bff915 	stw	r2,-28(fp)
 1205138:	e0bff917 	ldw	r2,-28(fp)
 120513c:	108000d0 	cmplti	r2,r2,3
 1205140:	103fee1e 	bne	r2,zero,12050fc <__alt_mem_instruction_tcm+0xff2050fc>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 1205144:	e0bffb83 	ldbu	r2,-18(fp)
 1205148:	10803fcc 	andi	r2,r2,255
 120514c:	10801458 	cmpnei	r2,r2,81
 1205150:	10001e1e 	bne	r2,zero,12051cc <alt_read_cfi_width+0x108>
      (byte_id[1] == 'R') &&
 1205154:	e0bffbc3 	ldbu	r2,-17(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 1205158:	10803fcc 	andi	r2,r2,255
 120515c:	10801498 	cmpnei	r2,r2,82
 1205160:	10001a1e 	bne	r2,zero,12051cc <alt_read_cfi_width+0x108>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
 1205164:	e0bffc03 	ldbu	r2,-16(fp)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
      (byte_id[1] == 'R') &&
 1205168:	10803fcc 	andi	r2,r2,255
 120516c:	10801658 	cmpnei	r2,r2,89
 1205170:	1000161e 	bne	r2,zero,12051cc <alt_read_cfi_width+0x108>
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 1205174:	e0bfff17 	ldw	r2,-4(fp)
 1205178:	00c00044 	movi	r3,1
 120517c:	10c02f15 	stw	r3,188(r2)
    flash->device_width = 1; 
 1205180:	e0bfff17 	ldw	r2,-4(fp)
 1205184:	00c00044 	movi	r3,1
 1205188:	10c03015 	stw	r3,192(r2)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 120518c:	e0bfff17 	ldw	r2,-4(fp)
 1205190:	10800a17 	ldw	r2,40(r2)
 1205194:	10800a04 	addi	r2,r2,40
 1205198:	1080002b 	ldhuio	r2,0(r2)
 120519c:	10bfffcc 	andi	r2,r2,65535
 12051a0:	e0bffb0d 	sth	r2,-20(fp)
    iface += 1;
 12051a4:	e0bffb0b 	ldhu	r2,-20(fp)
 12051a8:	10800044 	addi	r2,r2,1
 12051ac:	e0bffb0d 	sth	r2,-20(fp)
    if (!(iface & 0x1))
 12051b0:	e0bffb0b 	ldhu	r2,-20(fp)
 12051b4:	1080004c 	andi	r2,r2,1
 12051b8:	1000031e 	bne	r2,zero,12051c8 <alt_read_cfi_width+0x104>
    {
      ret_code = -ENODEV;
 12051bc:	00bffb44 	movi	r2,-19
 12051c0:	e0bffa15 	stw	r2,-24(fp)
  {
    flash->mode_width = 1;
    flash->device_width = 1; 
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
    iface += 1;
    if (!(iface & 0x1))
 12051c4:	00019a06 	br	1205830 <alt_read_cfi_width+0x76c>
 12051c8:	00019906 	br	1205830 <alt_read_cfi_width+0x76c>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 12051cc:	e0bfff17 	ldw	r2,-4(fp)
 12051d0:	10800a17 	ldw	r2,40(r2)
 12051d4:	1009883a 	mov	r4,r2
 12051d8:	01401544 	movi	r5,85
 12051dc:	01802604 	movi	r6,152
 12051e0:	12045cc0 	call	12045cc <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 12051e4:	e03ff915 	stw	zero,-28(fp)
 12051e8:	00000f06 	br	1205228 <alt_read_cfi_width+0x164>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 12051ec:	e0bfff17 	ldw	r2,-4(fp)
 12051f0:	10800a17 	ldw	r2,40(r2)
 12051f4:	e0fff917 	ldw	r3,-28(fp)
 12051f8:	18c00804 	addi	r3,r3,32
 12051fc:	10c5883a 	add	r2,r2,r3
 1205200:	10800023 	ldbuio	r2,0(r2)
 1205204:	10803fcc 	andi	r2,r2,255
 1205208:	1009883a 	mov	r4,r2
 120520c:	e0fffb84 	addi	r3,fp,-18
 1205210:	e0bff917 	ldw	r2,-28(fp)
 1205214:	1885883a 	add	r2,r3,r2
 1205218:	11000005 	stb	r4,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 120521c:	e0bff917 	ldw	r2,-28(fp)
 1205220:	10800044 	addi	r2,r2,1
 1205224:	e0bff915 	stw	r2,-28(fp)
 1205228:	e0bff917 	ldw	r2,-28(fp)
 120522c:	10800190 	cmplti	r2,r2,6
 1205230:	103fee1e 	bne	r2,zero,12051ec <__alt_mem_instruction_tcm+0xff2051ec>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 1205234:	e0bffb83 	ldbu	r2,-18(fp)
 1205238:	10803fcc 	andi	r2,r2,255
 120523c:	10801458 	cmpnei	r2,r2,81
 1205240:	10002a1e 	bne	r2,zero,12052ec <alt_read_cfi_width+0x228>
        (byte_id[1] == 'Q') && 
 1205244:	e0bffbc3 	ldbu	r2,-17(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 1205248:	10803fcc 	andi	r2,r2,255
 120524c:	10801458 	cmpnei	r2,r2,81
 1205250:	1000261e 	bne	r2,zero,12052ec <alt_read_cfi_width+0x228>
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
 1205254:	e0bffc03 	ldbu	r2,-16(fp)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
 1205258:	10803fcc 	andi	r2,r2,255
 120525c:	10801498 	cmpnei	r2,r2,82
 1205260:	1000221e 	bne	r2,zero,12052ec <alt_read_cfi_width+0x228>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
 1205264:	e0bffc43 	ldbu	r2,-15(fp)
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
 1205268:	10803fcc 	andi	r2,r2,255
 120526c:	10801498 	cmpnei	r2,r2,82
 1205270:	10001e1e 	bne	r2,zero,12052ec <alt_read_cfi_width+0x228>
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
 1205274:	e0bffc83 	ldbu	r2,-14(fp)
    }

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
 1205278:	10803fcc 	andi	r2,r2,255
 120527c:	10801658 	cmpnei	r2,r2,89
 1205280:	10001a1e 	bne	r2,zero,12052ec <alt_read_cfi_width+0x228>
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
 1205284:	e0bffcc3 	ldbu	r2,-13(fp)

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
 1205288:	10803fcc 	andi	r2,r2,255
 120528c:	10801658 	cmpnei	r2,r2,89
 1205290:	1000161e 	bne	r2,zero,12052ec <alt_read_cfi_width+0x228>
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 1205294:	e0bfff17 	ldw	r2,-4(fp)
 1205298:	00c00044 	movi	r3,1
 120529c:	10c02f15 	stw	r3,188(r2)
      flash->device_width = 2; 
 12052a0:	e0bfff17 	ldw	r2,-4(fp)
 12052a4:	00c00084 	movi	r3,2
 12052a8:	10c03015 	stw	r3,192(r2)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 12052ac:	e0bfff17 	ldw	r2,-4(fp)
 12052b0:	10800a17 	ldw	r2,40(r2)
 12052b4:	10801404 	addi	r2,r2,80
 12052b8:	1080002b 	ldhuio	r2,0(r2)
 12052bc:	10bfffcc 	andi	r2,r2,65535
 12052c0:	e0bffb0d 	sth	r2,-20(fp)
      iface += 1;
 12052c4:	e0bffb0b 	ldhu	r2,-20(fp)
 12052c8:	10800044 	addi	r2,r2,1
 12052cc:	e0bffb0d 	sth	r2,-20(fp)
      if (!(iface & 0x1))
 12052d0:	e0bffb0b 	ldhu	r2,-20(fp)
 12052d4:	1080004c 	andi	r2,r2,1
 12052d8:	1000031e 	bne	r2,zero,12052e8 <alt_read_cfi_width+0x224>
      {
        ret_code = -ENODEV;
 12052dc:	00bffb44 	movi	r2,-19
 12052e0:	e0bffa15 	stw	r2,-24(fp)
    {
      flash->mode_width = 1;
      flash->device_width = 2; 
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
      iface += 1;
      if (!(iface & 0x1))
 12052e4:	00015206 	br	1205830 <alt_read_cfi_width+0x76c>
 12052e8:	00015106 	br	1205830 <alt_read_cfi_width+0x76c>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 12052ec:	e0bfff17 	ldw	r2,-4(fp)
 12052f0:	10800a17 	ldw	r2,40(r2)
 12052f4:	1009883a 	mov	r4,r2
 12052f8:	01401544 	movi	r5,85
 12052fc:	01802604 	movi	r6,152
 1205300:	12046940 	call	1204694 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 1205304:	e03ff915 	stw	zero,-28(fp)
 1205308:	00000f06 	br	1205348 <alt_read_cfi_width+0x284>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 120530c:	e0bfff17 	ldw	r2,-4(fp)
 1205310:	10800a17 	ldw	r2,40(r2)
 1205314:	e0fff917 	ldw	r3,-28(fp)
 1205318:	18c00804 	addi	r3,r3,32
 120531c:	10c5883a 	add	r2,r2,r3
 1205320:	10800023 	ldbuio	r2,0(r2)
 1205324:	10803fcc 	andi	r2,r2,255
 1205328:	1009883a 	mov	r4,r2
 120532c:	e0fffb84 	addi	r3,fp,-18
 1205330:	e0bff917 	ldw	r2,-28(fp)
 1205334:	1885883a 	add	r2,r3,r2
 1205338:	11000005 	stb	r4,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 120533c:	e0bff917 	ldw	r2,-28(fp)
 1205340:	10800044 	addi	r2,r2,1
 1205344:	e0bff915 	stw	r2,-28(fp)
 1205348:	e0bff917 	ldw	r2,-28(fp)
 120534c:	10800190 	cmplti	r2,r2,6
 1205350:	103fee1e 	bne	r2,zero,120530c <__alt_mem_instruction_tcm+0xff20530c>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 1205354:	e0bffb83 	ldbu	r2,-18(fp)
 1205358:	10803fcc 	andi	r2,r2,255
 120535c:	10801458 	cmpnei	r2,r2,81
 1205360:	1000271e 	bne	r2,zero,1205400 <alt_read_cfi_width+0x33c>
          (byte_id[1] == '\0') && 
 1205364:	e0bffbc3 	ldbu	r2,-17(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 1205368:	10803fcc 	andi	r2,r2,255
 120536c:	1000241e 	bne	r2,zero,1205400 <alt_read_cfi_width+0x33c>
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
 1205370:	e0bffc03 	ldbu	r2,-16(fp)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
 1205374:	10803fcc 	andi	r2,r2,255
 1205378:	10801498 	cmpnei	r2,r2,82
 120537c:	1000201e 	bne	r2,zero,1205400 <alt_read_cfi_width+0x33c>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
 1205380:	e0bffc43 	ldbu	r2,-15(fp)
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
 1205384:	10803fcc 	andi	r2,r2,255
 1205388:	10001d1e 	bne	r2,zero,1205400 <alt_read_cfi_width+0x33c>
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
 120538c:	e0bffc83 	ldbu	r2,-14(fp)
      }

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
 1205390:	10803fcc 	andi	r2,r2,255
 1205394:	10801658 	cmpnei	r2,r2,89
 1205398:	1000191e 	bne	r2,zero,1205400 <alt_read_cfi_width+0x33c>
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
 120539c:	e0bffcc3 	ldbu	r2,-13(fp)

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
 12053a0:	10803fcc 	andi	r2,r2,255
 12053a4:	1000161e 	bne	r2,zero,1205400 <alt_read_cfi_width+0x33c>
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 12053a8:	e0bfff17 	ldw	r2,-4(fp)
 12053ac:	00c00084 	movi	r3,2
 12053b0:	10c02f15 	stw	r3,188(r2)
        flash->device_width = 2; 
 12053b4:	e0bfff17 	ldw	r2,-4(fp)
 12053b8:	00c00084 	movi	r3,2
 12053bc:	10c03015 	stw	r3,192(r2)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 12053c0:	e0bfff17 	ldw	r2,-4(fp)
 12053c4:	10800a17 	ldw	r2,40(r2)
 12053c8:	10801404 	addi	r2,r2,80
 12053cc:	1080002b 	ldhuio	r2,0(r2)
 12053d0:	10bfffcc 	andi	r2,r2,65535
 12053d4:	e0bffb0d 	sth	r2,-20(fp)
        iface += 1;
 12053d8:	e0bffb0b 	ldhu	r2,-20(fp)
 12053dc:	10800044 	addi	r2,r2,1
 12053e0:	e0bffb0d 	sth	r2,-20(fp)
        if (!(iface & 0x2))
 12053e4:	e0bffb0b 	ldhu	r2,-20(fp)
 12053e8:	1080008c 	andi	r2,r2,2
 12053ec:	1000031e 	bne	r2,zero,12053fc <alt_read_cfi_width+0x338>
        {
          ret_code = -ENODEV;
 12053f0:	00bffb44 	movi	r2,-19
 12053f4:	e0bffa15 	stw	r2,-24(fp)
      {
        flash->mode_width = 2;
        flash->device_width = 2; 
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
        iface += 1;
        if (!(iface & 0x2))
 12053f8:	00010d06 	br	1205830 <alt_read_cfi_width+0x76c>
 12053fc:	00010c06 	br	1205830 <alt_read_cfi_width+0x76c>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 1205400:	e0bfff17 	ldw	r2,-4(fp)
 1205404:	10800a17 	ldw	r2,40(r2)
 1205408:	1009883a 	mov	r4,r2
 120540c:	01401544 	movi	r5,85
 1205410:	01802604 	movi	r6,152
 1205414:	12047300 	call	1204730 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 1205418:	e03ff915 	stw	zero,-28(fp)
 120541c:	00000f06 	br	120545c <alt_read_cfi_width+0x398>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 1205420:	e0bfff17 	ldw	r2,-4(fp)
 1205424:	10800a17 	ldw	r2,40(r2)
 1205428:	e0fff917 	ldw	r3,-28(fp)
 120542c:	18c01004 	addi	r3,r3,64
 1205430:	10c5883a 	add	r2,r2,r3
 1205434:	10800023 	ldbuio	r2,0(r2)
 1205438:	10803fcc 	andi	r2,r2,255
 120543c:	1009883a 	mov	r4,r2
 1205440:	e0fffb84 	addi	r3,fp,-18
 1205444:	e0bff917 	ldw	r2,-28(fp)
 1205448:	1885883a 	add	r2,r3,r2
 120544c:	11000005 	stb	r4,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 1205450:	e0bff917 	ldw	r2,-28(fp)
 1205454:	10800044 	addi	r2,r2,1
 1205458:	e0bff915 	stw	r2,-28(fp)
 120545c:	e0bff917 	ldw	r2,-28(fp)
 1205460:	10800310 	cmplti	r2,r2,12
 1205464:	103fee1e 	bne	r2,zero,1205420 <__alt_mem_instruction_tcm+0xff205420>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 1205468:	e0bffb83 	ldbu	r2,-18(fp)
 120546c:	10803fcc 	andi	r2,r2,255
 1205470:	10801458 	cmpnei	r2,r2,81
 1205474:	1000381e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[1] == '\0') && 
 1205478:	e0bffbc3 	ldbu	r2,-17(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 120547c:	10803fcc 	andi	r2,r2,255
 1205480:	1000351e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
 1205484:	e0bffc03 	ldbu	r2,-16(fp)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
 1205488:	10803fcc 	andi	r2,r2,255
 120548c:	1000321e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
 1205490:	e0bffc43 	ldbu	r2,-15(fp)
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
 1205494:	10803fcc 	andi	r2,r2,255
 1205498:	10002f1e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
 120549c:	e0bffc83 	ldbu	r2,-14(fp)
        }

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
 12054a0:	10803fcc 	andi	r2,r2,255
 12054a4:	10801498 	cmpnei	r2,r2,82
 12054a8:	10002b1e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
 12054ac:	e0bffcc3 	ldbu	r2,-13(fp)

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
 12054b0:	10803fcc 	andi	r2,r2,255
 12054b4:	1000281e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
 12054b8:	e0bffd03 	ldbu	r2,-12(fp)
        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
 12054bc:	10803fcc 	andi	r2,r2,255
 12054c0:	1000251e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
 12054c4:	e0bffd43 	ldbu	r2,-11(fp)
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
 12054c8:	10803fcc 	andi	r2,r2,255
 12054cc:	1000221e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
 12054d0:	e0bffd83 	ldbu	r2,-10(fp)
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
 12054d4:	10803fcc 	andi	r2,r2,255
 12054d8:	10801658 	cmpnei	r2,r2,89
 12054dc:	10001e1e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
 12054e0:	e0bffdc3 	ldbu	r2,-9(fp)
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
 12054e4:	10803fcc 	andi	r2,r2,255
 12054e8:	10001b1e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
 12054ec:	e0bffe03 	ldbu	r2,-8(fp)
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
 12054f0:	10803fcc 	andi	r2,r2,255
 12054f4:	1000181e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
 12054f8:	e0bffe43 	ldbu	r2,-7(fp)
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
 12054fc:	10803fcc 	andi	r2,r2,255
 1205500:	1000151e 	bne	r2,zero,1205558 <alt_read_cfi_width+0x494>
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 1205504:	e0bfff17 	ldw	r2,-4(fp)
 1205508:	00c00104 	movi	r3,4
 120550c:	10c02f15 	stw	r3,188(r2)
          flash->device_width = 4; 
 1205510:	e0bfff17 	ldw	r2,-4(fp)
 1205514:	00c00104 	movi	r3,4
 1205518:	10c03015 	stw	r3,192(r2)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 120551c:	e0bfff17 	ldw	r2,-4(fp)
 1205520:	10800a17 	ldw	r2,40(r2)
 1205524:	10802804 	addi	r2,r2,160
 1205528:	10800037 	ldwio	r2,0(r2)
 120552c:	e0bffb0d 	sth	r2,-20(fp)
          iface += 1;
 1205530:	e0bffb0b 	ldhu	r2,-20(fp)
 1205534:	10800044 	addi	r2,r2,1
 1205538:	e0bffb0d 	sth	r2,-20(fp)
          if (!(iface & 0x4))
 120553c:	e0bffb0b 	ldhu	r2,-20(fp)
 1205540:	1080010c 	andi	r2,r2,4
 1205544:	1000031e 	bne	r2,zero,1205554 <alt_read_cfi_width+0x490>
          {
            ret_code = -ENODEV;
 1205548:	00bffb44 	movi	r2,-19
 120554c:	e0bffa15 	stw	r2,-24(fp)
        {
          flash->mode_width = 4;
          flash->device_width = 4; 
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
          iface += 1;
          if (!(iface & 0x4))
 1205550:	0000b706 	br	1205830 <alt_read_cfi_width+0x76c>
 1205554:	0000b606 	br	1205830 <alt_read_cfi_width+0x76c>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 1205558:	e0bfff17 	ldw	r2,-4(fp)
 120555c:	10800a17 	ldw	r2,40(r2)
 1205560:	1009883a 	mov	r4,r2
 1205564:	01401544 	movi	r5,85
 1205568:	01802604 	movi	r6,152
 120556c:	12046e00 	call	12046e0 <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 1205570:	e03ff915 	stw	zero,-28(fp)
 1205574:	00000f06 	br	12055b4 <alt_read_cfi_width+0x4f0>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 1205578:	e0bfff17 	ldw	r2,-4(fp)
 120557c:	10800a17 	ldw	r2,40(r2)
 1205580:	e0fff917 	ldw	r3,-28(fp)
 1205584:	18c01004 	addi	r3,r3,64
 1205588:	10c5883a 	add	r2,r2,r3
 120558c:	10800023 	ldbuio	r2,0(r2)
 1205590:	10803fcc 	andi	r2,r2,255
 1205594:	1009883a 	mov	r4,r2
 1205598:	e0fffb84 	addi	r3,fp,-18
 120559c:	e0bff917 	ldw	r2,-28(fp)
 12055a0:	1885883a 	add	r2,r3,r2
 12055a4:	11000005 	stb	r4,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 12055a8:	e0bff917 	ldw	r2,-28(fp)
 12055ac:	10800044 	addi	r2,r2,1
 12055b0:	e0bff915 	stw	r2,-28(fp)
 12055b4:	e0bff917 	ldw	r2,-28(fp)
 12055b8:	10800310 	cmplti	r2,r2,12
 12055bc:	103fee1e 	bne	r2,zero,1205578 <__alt_mem_instruction_tcm+0xff205578>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 12055c0:	e0bffb83 	ldbu	r2,-18(fp)
 12055c4:	10803fcc 	andi	r2,r2,255
 12055c8:	10801458 	cmpnei	r2,r2,81
 12055cc:	10003b1e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[1] == '\0') &&
 12055d0:	e0bffbc3 	ldbu	r2,-17(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 12055d4:	10803fcc 	andi	r2,r2,255
 12055d8:	1000381e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
 12055dc:	e0bffc03 	ldbu	r2,-16(fp)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
 12055e0:	10803fcc 	andi	r2,r2,255
 12055e4:	10801458 	cmpnei	r2,r2,81
 12055e8:	1000341e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
 12055ec:	e0bffc43 	ldbu	r2,-15(fp)
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
 12055f0:	10803fcc 	andi	r2,r2,255
 12055f4:	1000311e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
 12055f8:	e0bffc83 	ldbu	r2,-14(fp)
          }

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
 12055fc:	10803fcc 	andi	r2,r2,255
 1205600:	10801498 	cmpnei	r2,r2,82
 1205604:	10002d1e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
 1205608:	e0bffcc3 	ldbu	r2,-13(fp)

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
 120560c:	10803fcc 	andi	r2,r2,255
 1205610:	10002a1e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
 1205614:	e0bffd03 	ldbu	r2,-12(fp)
          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
 1205618:	10803fcc 	andi	r2,r2,255
 120561c:	10801498 	cmpnei	r2,r2,82
 1205620:	1000261e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
 1205624:	e0bffd43 	ldbu	r2,-11(fp)
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
 1205628:	10803fcc 	andi	r2,r2,255
 120562c:	1000231e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
 1205630:	e0bffd83 	ldbu	r2,-10(fp)
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
 1205634:	10803fcc 	andi	r2,r2,255
 1205638:	10801658 	cmpnei	r2,r2,89
 120563c:	10001f1e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
 1205640:	e0bffdc3 	ldbu	r2,-9(fp)
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
 1205644:	10803fcc 	andi	r2,r2,255
 1205648:	10001c1e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
 120564c:	e0bffe03 	ldbu	r2,-8(fp)
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
 1205650:	10803fcc 	andi	r2,r2,255
 1205654:	10801658 	cmpnei	r2,r2,89
 1205658:	1000181e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
 120565c:	e0bffe43 	ldbu	r2,-7(fp)
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
 1205660:	10803fcc 	andi	r2,r2,255
 1205664:	1000151e 	bne	r2,zero,12056bc <alt_read_cfi_width+0x5f8>
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 1205668:	e0bfff17 	ldw	r2,-4(fp)
 120566c:	00c00084 	movi	r3,2
 1205670:	10c02f15 	stw	r3,188(r2)
            flash->device_width = 4; 
 1205674:	e0bfff17 	ldw	r2,-4(fp)
 1205678:	00c00104 	movi	r3,4
 120567c:	10c03015 	stw	r3,192(r2)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 1205680:	e0bfff17 	ldw	r2,-4(fp)
 1205684:	10800a17 	ldw	r2,40(r2)
 1205688:	10802804 	addi	r2,r2,160
 120568c:	10800037 	ldwio	r2,0(r2)
 1205690:	e0bffb0d 	sth	r2,-20(fp)
            iface += 1;
 1205694:	e0bffb0b 	ldhu	r2,-20(fp)
 1205698:	10800044 	addi	r2,r2,1
 120569c:	e0bffb0d 	sth	r2,-20(fp)
            if (!(iface & 0x4))
 12056a0:	e0bffb0b 	ldhu	r2,-20(fp)
 12056a4:	1080010c 	andi	r2,r2,4
 12056a8:	1000031e 	bne	r2,zero,12056b8 <alt_read_cfi_width+0x5f4>
            {
              ret_code = -ENODEV;
 12056ac:	00bffb44 	movi	r2,-19
 12056b0:	e0bffa15 	stw	r2,-24(fp)
          {
            flash->mode_width = 2;
            flash->device_width = 4; 
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
            iface += 1;
            if (!(iface & 0x4))
 12056b4:	00005e06 	br	1205830 <alt_read_cfi_width+0x76c>
 12056b8:	00005d06 	br	1205830 <alt_read_cfi_width+0x76c>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 12056bc:	e0bfff17 	ldw	r2,-4(fp)
 12056c0:	10800a17 	ldw	r2,40(r2)
 12056c4:	1009883a 	mov	r4,r2
 12056c8:	01401544 	movi	r5,85
 12056cc:	01802604 	movi	r6,152
 12056d0:	12046440 	call	1204644 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 12056d4:	e03ff915 	stw	zero,-28(fp)
 12056d8:	00000f06 	br	1205718 <alt_read_cfi_width+0x654>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 12056dc:	e0bfff17 	ldw	r2,-4(fp)
 12056e0:	10800a17 	ldw	r2,40(r2)
 12056e4:	e0fff917 	ldw	r3,-28(fp)
 12056e8:	18c01004 	addi	r3,r3,64
 12056ec:	10c5883a 	add	r2,r2,r3
 12056f0:	10800023 	ldbuio	r2,0(r2)
 12056f4:	10803fcc 	andi	r2,r2,255
 12056f8:	1009883a 	mov	r4,r2
 12056fc:	e0fffb84 	addi	r3,fp,-18
 1205700:	e0bff917 	ldw	r2,-28(fp)
 1205704:	1885883a 	add	r2,r3,r2
 1205708:	11000005 	stb	r4,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 120570c:	e0bff917 	ldw	r2,-28(fp)
 1205710:	10800044 	addi	r2,r2,1
 1205714:	e0bff915 	stw	r2,-28(fp)
 1205718:	e0bff917 	ldw	r2,-28(fp)
 120571c:	10800310 	cmplti	r2,r2,12
 1205720:	103fee1e 	bne	r2,zero,12056dc <__alt_mem_instruction_tcm+0xff2056dc>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 1205724:	e0bffb83 	ldbu	r2,-18(fp)
 1205728:	10803fcc 	andi	r2,r2,255
 120572c:	10801458 	cmpnei	r2,r2,81
 1205730:	10003f1e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[1] == 'Q') &&
 1205734:	e0bffbc3 	ldbu	r2,-17(fp)
            for(i=0;i<12;i++)
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 1205738:	10803fcc 	andi	r2,r2,255
 120573c:	10801458 	cmpnei	r2,r2,81
 1205740:	10003b1e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
 1205744:	e0bffc03 	ldbu	r2,-16(fp)
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
 1205748:	10803fcc 	andi	r2,r2,255
 120574c:	10801458 	cmpnei	r2,r2,81
 1205750:	1000371e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
 1205754:	e0bffc43 	ldbu	r2,-15(fp)
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
 1205758:	10803fcc 	andi	r2,r2,255
 120575c:	10801458 	cmpnei	r2,r2,81
 1205760:	1000331e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
 1205764:	e0bffc83 	ldbu	r2,-14(fp)
            }

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
 1205768:	10803fcc 	andi	r2,r2,255
 120576c:	10801498 	cmpnei	r2,r2,82
 1205770:	10002f1e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
 1205774:	e0bffcc3 	ldbu	r2,-13(fp)

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
 1205778:	10803fcc 	andi	r2,r2,255
 120577c:	10801498 	cmpnei	r2,r2,82
 1205780:	10002b1e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
 1205784:	e0bffd03 	ldbu	r2,-12(fp)
            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
 1205788:	10803fcc 	andi	r2,r2,255
 120578c:	10801498 	cmpnei	r2,r2,82
 1205790:	1000271e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
 1205794:	e0bffd43 	ldbu	r2,-11(fp)
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
 1205798:	10803fcc 	andi	r2,r2,255
 120579c:	10801498 	cmpnei	r2,r2,82
 12057a0:	1000231e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
 12057a4:	e0bffd83 	ldbu	r2,-10(fp)
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
 12057a8:	10803fcc 	andi	r2,r2,255
 12057ac:	10801658 	cmpnei	r2,r2,89
 12057b0:	10001f1e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
 12057b4:	e0bffdc3 	ldbu	r2,-9(fp)
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
 12057b8:	10803fcc 	andi	r2,r2,255
 12057bc:	10801658 	cmpnei	r2,r2,89
 12057c0:	10001b1e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
 12057c4:	e0bffe03 	ldbu	r2,-8(fp)
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
 12057c8:	10803fcc 	andi	r2,r2,255
 12057cc:	10801658 	cmpnei	r2,r2,89
 12057d0:	1000171e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
 12057d4:	e0bffe43 	ldbu	r2,-7(fp)
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
 12057d8:	10803fcc 	andi	r2,r2,255
 12057dc:	10801658 	cmpnei	r2,r2,89
 12057e0:	1000131e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 12057e4:	e0bfff17 	ldw	r2,-4(fp)
 12057e8:	00c00044 	movi	r3,1
 12057ec:	10c02f15 	stw	r3,188(r2)
              flash->device_width = 4; 
 12057f0:	e0bfff17 	ldw	r2,-4(fp)
 12057f4:	00c00104 	movi	r3,4
 12057f8:	10c03015 	stw	r3,192(r2)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 12057fc:	e0bfff17 	ldw	r2,-4(fp)
 1205800:	10800a17 	ldw	r2,40(r2)
 1205804:	10802804 	addi	r2,r2,160
 1205808:	10800037 	ldwio	r2,0(r2)
 120580c:	e0bffb0d 	sth	r2,-20(fp)
              iface += 1;
 1205810:	e0bffb0b 	ldhu	r2,-20(fp)
 1205814:	10800044 	addi	r2,r2,1
 1205818:	e0bffb0d 	sth	r2,-20(fp)
              if (!(iface & 0x4))
 120581c:	e0bffb0b 	ldhu	r2,-20(fp)
 1205820:	1080010c 	andi	r2,r2,4
 1205824:	1000021e 	bne	r2,zero,1205830 <alt_read_cfi_width+0x76c>
              {
                ret_code = -ENODEV;
 1205828:	00bffb44 	movi	r2,-19
 120582c:	e0bffa15 	stw	r2,-24(fp)
        }
      }
    }
  }
  
  return ret_code;
 1205830:	e0bffa17 	ldw	r2,-24(fp)
}
 1205834:	e037883a 	mov	sp,fp
 1205838:	dfc00117 	ldw	ra,4(sp)
 120583c:	df000017 	ldw	fp,0(sp)
 1205840:	dec00204 	addi	sp,sp,8
 1205844:	f800283a 	ret

01205848 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 1205848:	defffa04 	addi	sp,sp,-24
 120584c:	dfc00515 	stw	ra,20(sp)
 1205850:	df000415 	stw	fp,16(sp)
 1205854:	df000404 	addi	fp,sp,16
 1205858:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 120585c:	e03ffd15 	stw	zero,-12(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 1205860:	e13fff17 	ldw	r4,-4(fp)
 1205864:	01400544 	movi	r5,21
 1205868:	1204a7c0 	call	1204a7c <alt_read_16bit_query_entry>
 120586c:	10ffffcc 	andi	r3,r2,65535
 1205870:	e0bfff17 	ldw	r2,-4(fp)
 1205874:	10c03315 	stw	r3,204(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 1205878:	e03ffc15 	stw	zero,-16(fp)
 120587c:	00001106 	br	12058c4 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
 1205880:	e0bfff17 	ldw	r2,-4(fp)
 1205884:	10803517 	ldw	r2,212(r2)
 1205888:	e0ffff17 	ldw	r3,-4(fp)
 120588c:	19003317 	ldw	r4,204(r3)
 1205890:	e0fffc17 	ldw	r3,-16(fp)
 1205894:	20c7883a 	add	r3,r4,r3
 1205898:	e13fff17 	ldw	r4,-4(fp)
 120589c:	180b883a 	mov	r5,r3
 12058a0:	103ee83a 	callr	r2
 12058a4:	1009883a 	mov	r4,r2
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
  {
    primary_query_string[i] = 
 12058a8:	e0fffe04 	addi	r3,fp,-8
 12058ac:	e0bffc17 	ldw	r2,-16(fp)
 12058b0:	1885883a 	add	r2,r3,r2
 12058b4:	11000005 	stb	r4,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 12058b8:	e0bffc17 	ldw	r2,-16(fp)
 12058bc:	10800044 	addi	r2,r2,1
 12058c0:	e0bffc15 	stw	r2,-16(fp)
 12058c4:	e0bffc17 	ldw	r2,-16(fp)
 12058c8:	108000d0 	cmplti	r2,r2,3
 12058cc:	103fec1e 	bne	r2,zero,1205880 <__alt_mem_instruction_tcm+0xff205880>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 12058d0:	e0bffe03 	ldbu	r2,-8(fp)
 12058d4:	10803fcc 	andi	r2,r2,255
 12058d8:	10801418 	cmpnei	r2,r2,80
 12058dc:	1000081e 	bne	r2,zero,1205900 <alt_check_primary_table+0xb8>
      (primary_query_string[1] != 'R') ||
 12058e0:	e0bffe43 	ldbu	r2,-7(fp)
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 12058e4:	10803fcc 	andi	r2,r2,255
 12058e8:	10801498 	cmpnei	r2,r2,82
 12058ec:	1000041e 	bne	r2,zero,1205900 <alt_check_primary_table+0xb8>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
 12058f0:	e0bffe83 	ldbu	r2,-6(fp)
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
      (primary_query_string[1] != 'R') ||
 12058f4:	10803fcc 	andi	r2,r2,255
 12058f8:	10801260 	cmpeqi	r2,r2,73
 12058fc:	1000021e 	bne	r2,zero,1205908 <alt_check_primary_table+0xc0>
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 1205900:	00bffb44 	movi	r2,-19
 1205904:	e0bffd15 	stw	r2,-12(fp)
  }
  
  return ret_code;
 1205908:	e0bffd17 	ldw	r2,-12(fp)
}
 120590c:	e037883a 	mov	sp,fp
 1205910:	dfc00117 	ldw	ra,4(sp)
 1205914:	df000017 	ldw	fp,0(sp)
 1205918:	dec00204 	addi	sp,sp,8
 120591c:	f800283a 	ret

01205920 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 1205920:	defffa04 	addi	sp,sp,-24
 1205924:	dfc00515 	stw	ra,20(sp)
 1205928:	df000415 	stw	fp,16(sp)
 120592c:	df000404 	addi	fp,sp,16
 1205930:	e13ffd15 	stw	r4,-12(fp)
 1205934:	e17ffe15 	stw	r5,-8(fp)
 1205938:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 120593c:	e0bffd17 	ldw	r2,-12(fp)
 1205940:	10800017 	ldw	r2,0(r2)
 1205944:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 1205948:	e0bffc17 	ldw	r2,-16(fp)
 120594c:	10c00a04 	addi	r3,r2,40
 1205950:	e0bffd17 	ldw	r2,-12(fp)
 1205954:	10800217 	ldw	r2,8(r2)
 1205958:	1809883a 	mov	r4,r3
 120595c:	e17ffe17 	ldw	r5,-8(fp)
 1205960:	e1bfff17 	ldw	r6,-4(fp)
 1205964:	100f883a 	mov	r7,r2
 1205968:	1205f480 	call	1205f48 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 120596c:	e037883a 	mov	sp,fp
 1205970:	dfc00117 	ldw	ra,4(sp)
 1205974:	df000017 	ldw	fp,0(sp)
 1205978:	dec00204 	addi	sp,sp,8
 120597c:	f800283a 	ret

01205980 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1205980:	defffa04 	addi	sp,sp,-24
 1205984:	dfc00515 	stw	ra,20(sp)
 1205988:	df000415 	stw	fp,16(sp)
 120598c:	df000404 	addi	fp,sp,16
 1205990:	e13ffd15 	stw	r4,-12(fp)
 1205994:	e17ffe15 	stw	r5,-8(fp)
 1205998:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 120599c:	e0bffd17 	ldw	r2,-12(fp)
 12059a0:	10800017 	ldw	r2,0(r2)
 12059a4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 12059a8:	e0bffc17 	ldw	r2,-16(fp)
 12059ac:	10c00a04 	addi	r3,r2,40
 12059b0:	e0bffd17 	ldw	r2,-12(fp)
 12059b4:	10800217 	ldw	r2,8(r2)
 12059b8:	1809883a 	mov	r4,r3
 12059bc:	e17ffe17 	ldw	r5,-8(fp)
 12059c0:	e1bfff17 	ldw	r6,-4(fp)
 12059c4:	100f883a 	mov	r7,r2
 12059c8:	12061540 	call	1206154 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 12059cc:	e037883a 	mov	sp,fp
 12059d0:	dfc00117 	ldw	ra,4(sp)
 12059d4:	df000017 	ldw	fp,0(sp)
 12059d8:	dec00204 	addi	sp,sp,8
 12059dc:	f800283a 	ret

012059e0 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 12059e0:	defffc04 	addi	sp,sp,-16
 12059e4:	dfc00315 	stw	ra,12(sp)
 12059e8:	df000215 	stw	fp,8(sp)
 12059ec:	df000204 	addi	fp,sp,8
 12059f0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 12059f4:	e0bfff17 	ldw	r2,-4(fp)
 12059f8:	10800017 	ldw	r2,0(r2)
 12059fc:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 1205a00:	e0bffe17 	ldw	r2,-8(fp)
 1205a04:	10c00a04 	addi	r3,r2,40
 1205a08:	e0bfff17 	ldw	r2,-4(fp)
 1205a0c:	10800217 	ldw	r2,8(r2)
 1205a10:	1809883a 	mov	r4,r3
 1205a14:	100b883a 	mov	r5,r2
 1205a18:	1205df40 	call	1205df4 <altera_avalon_jtag_uart_close>
}
 1205a1c:	e037883a 	mov	sp,fp
 1205a20:	dfc00117 	ldw	ra,4(sp)
 1205a24:	df000017 	ldw	fp,0(sp)
 1205a28:	dec00204 	addi	sp,sp,8
 1205a2c:	f800283a 	ret

01205a30 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 1205a30:	defffa04 	addi	sp,sp,-24
 1205a34:	dfc00515 	stw	ra,20(sp)
 1205a38:	df000415 	stw	fp,16(sp)
 1205a3c:	df000404 	addi	fp,sp,16
 1205a40:	e13ffd15 	stw	r4,-12(fp)
 1205a44:	e17ffe15 	stw	r5,-8(fp)
 1205a48:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 1205a4c:	e0bffd17 	ldw	r2,-12(fp)
 1205a50:	10800017 	ldw	r2,0(r2)
 1205a54:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 1205a58:	e0bffc17 	ldw	r2,-16(fp)
 1205a5c:	10800a04 	addi	r2,r2,40
 1205a60:	1009883a 	mov	r4,r2
 1205a64:	e17ffe17 	ldw	r5,-8(fp)
 1205a68:	e1bfff17 	ldw	r6,-4(fp)
 1205a6c:	1205e5c0 	call	1205e5c <altera_avalon_jtag_uart_ioctl>
}
 1205a70:	e037883a 	mov	sp,fp
 1205a74:	dfc00117 	ldw	ra,4(sp)
 1205a78:	df000017 	ldw	fp,0(sp)
 1205a7c:	dec00204 	addi	sp,sp,8
 1205a80:	f800283a 	ret

01205a84 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 1205a84:	defffa04 	addi	sp,sp,-24
 1205a88:	dfc00515 	stw	ra,20(sp)
 1205a8c:	df000415 	stw	fp,16(sp)
 1205a90:	df000404 	addi	fp,sp,16
 1205a94:	e13ffd15 	stw	r4,-12(fp)
 1205a98:	e17ffe15 	stw	r5,-8(fp)
 1205a9c:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1205aa0:	e0bffd17 	ldw	r2,-12(fp)
 1205aa4:	00c00044 	movi	r3,1
 1205aa8:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 1205aac:	e0bffd17 	ldw	r2,-12(fp)
 1205ab0:	10800017 	ldw	r2,0(r2)
 1205ab4:	10800104 	addi	r2,r2,4
 1205ab8:	1007883a 	mov	r3,r2
 1205abc:	e0bffd17 	ldw	r2,-12(fp)
 1205ac0:	10800817 	ldw	r2,32(r2)
 1205ac4:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 1205ac8:	e0fffe17 	ldw	r3,-8(fp)
 1205acc:	e0bfff17 	ldw	r2,-4(fp)
 1205ad0:	d8000015 	stw	zero,0(sp)
 1205ad4:	1809883a 	mov	r4,r3
 1205ad8:	100b883a 	mov	r5,r2
 1205adc:	01804834 	movhi	r6,288
 1205ae0:	3196d204 	addi	r6,r6,23368
 1205ae4:	e1fffd17 	ldw	r7,-12(fp)
 1205ae8:	12031f40 	call	12031f4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 1205aec:	e0bffd17 	ldw	r2,-12(fp)
 1205af0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 1205af4:	e0bffd17 	ldw	r2,-12(fp)
 1205af8:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1205afc:	00804874 	movhi	r2,289
 1205b00:	10a6e804 	addi	r2,r2,-25696
 1205b04:	10800017 	ldw	r2,0(r2)
 1205b08:	1809883a 	mov	r4,r3
 1205b0c:	100b883a 	mov	r5,r2
 1205b10:	01804834 	movhi	r6,288
 1205b14:	31975304 	addi	r6,r6,23884
 1205b18:	e1fffd17 	ldw	r7,-12(fp)
 1205b1c:	12064680 	call	1206468 <alt_alarm_start>
 1205b20:	1000040e 	bge	r2,zero,1205b34 <altera_avalon_jtag_uart_init+0xb0>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 1205b24:	e0fffd17 	ldw	r3,-12(fp)
 1205b28:	00a00034 	movhi	r2,32768
 1205b2c:	10bfffc4 	addi	r2,r2,-1
 1205b30:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 1205b34:	e037883a 	mov	sp,fp
 1205b38:	dfc00117 	ldw	ra,4(sp)
 1205b3c:	df000017 	ldw	fp,0(sp)
 1205b40:	dec00204 	addi	sp,sp,8
 1205b44:	f800283a 	ret

01205b48 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 1205b48:	defff804 	addi	sp,sp,-32
 1205b4c:	df000715 	stw	fp,28(sp)
 1205b50:	df000704 	addi	fp,sp,28
 1205b54:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 1205b58:	e0bfff17 	ldw	r2,-4(fp)
 1205b5c:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 1205b60:	e0bffb17 	ldw	r2,-20(fp)
 1205b64:	10800017 	ldw	r2,0(r2)
 1205b68:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1205b6c:	e0bffc17 	ldw	r2,-16(fp)
 1205b70:	10800104 	addi	r2,r2,4
 1205b74:	10800037 	ldwio	r2,0(r2)
 1205b78:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 1205b7c:	e0bffd17 	ldw	r2,-12(fp)
 1205b80:	1080c00c 	andi	r2,r2,768
 1205b84:	1000011e 	bne	r2,zero,1205b8c <altera_avalon_jtag_uart_irq+0x44>
      break;
 1205b88:	00006c06 	br	1205d3c <altera_avalon_jtag_uart_irq+0x1f4>

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 1205b8c:	e0bffd17 	ldw	r2,-12(fp)
 1205b90:	1080400c 	andi	r2,r2,256
 1205b94:	10003426 	beq	r2,zero,1205c68 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 1205b98:	00800074 	movhi	r2,1
 1205b9c:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1205ba0:	e0bffb17 	ldw	r2,-20(fp)
 1205ba4:	10800a17 	ldw	r2,40(r2)
 1205ba8:	10800044 	addi	r2,r2,1
 1205bac:	1081ffcc 	andi	r2,r2,2047
 1205bb0:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 1205bb4:	e0bffb17 	ldw	r2,-20(fp)
 1205bb8:	10c00b17 	ldw	r3,44(r2)
 1205bbc:	e0bffe17 	ldw	r2,-8(fp)
 1205bc0:	1880011e 	bne	r3,r2,1205bc8 <altera_avalon_jtag_uart_irq+0x80>
          break;
 1205bc4:	00001606 	br	1205c20 <altera_avalon_jtag_uart_irq+0xd8>

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 1205bc8:	e0bffc17 	ldw	r2,-16(fp)
 1205bcc:	10800037 	ldwio	r2,0(r2)
 1205bd0:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 1205bd4:	e0bff917 	ldw	r2,-28(fp)
 1205bd8:	10a0000c 	andi	r2,r2,32768
 1205bdc:	1000011e 	bne	r2,zero,1205be4 <altera_avalon_jtag_uart_irq+0x9c>
          break;
 1205be0:	00000f06 	br	1205c20 <altera_avalon_jtag_uart_irq+0xd8>

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 1205be4:	e0bffb17 	ldw	r2,-20(fp)
 1205be8:	10800a17 	ldw	r2,40(r2)
 1205bec:	e0fff917 	ldw	r3,-28(fp)
 1205bf0:	1809883a 	mov	r4,r3
 1205bf4:	e0fffb17 	ldw	r3,-20(fp)
 1205bf8:	1885883a 	add	r2,r3,r2
 1205bfc:	10800e04 	addi	r2,r2,56
 1205c00:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1205c04:	e0bffb17 	ldw	r2,-20(fp)
 1205c08:	10800a17 	ldw	r2,40(r2)
 1205c0c:	10800044 	addi	r2,r2,1
 1205c10:	10c1ffcc 	andi	r3,r2,2047
 1205c14:	e0bffb17 	ldw	r2,-20(fp)
 1205c18:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 1205c1c:	003fe006 	br	1205ba0 <__alt_mem_instruction_tcm+0xff205ba0>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 1205c20:	e0bff917 	ldw	r2,-28(fp)
 1205c24:	10bfffec 	andhi	r2,r2,65535
 1205c28:	10000f26 	beq	r2,zero,1205c68 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1205c2c:	e0bffb17 	ldw	r2,-20(fp)
 1205c30:	10c00817 	ldw	r3,32(r2)
 1205c34:	00bfff84 	movi	r2,-2
 1205c38:	1886703a 	and	r3,r3,r2
 1205c3c:	e0bffb17 	ldw	r2,-20(fp)
 1205c40:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 1205c44:	e0bffc17 	ldw	r2,-16(fp)
 1205c48:	10800104 	addi	r2,r2,4
 1205c4c:	1007883a 	mov	r3,r2
 1205c50:	e0bffb17 	ldw	r2,-20(fp)
 1205c54:	10800817 	ldw	r2,32(r2)
 1205c58:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1205c5c:	e0bffc17 	ldw	r2,-16(fp)
 1205c60:	10800104 	addi	r2,r2,4
 1205c64:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 1205c68:	e0bffd17 	ldw	r2,-12(fp)
 1205c6c:	1080800c 	andi	r2,r2,512
 1205c70:	10003126 	beq	r2,zero,1205d38 <altera_avalon_jtag_uart_irq+0x1f0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 1205c74:	e0bffd17 	ldw	r2,-12(fp)
 1205c78:	1004d43a 	srli	r2,r2,16
 1205c7c:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 1205c80:	00001406 	br	1205cd4 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 1205c84:	e0bffc17 	ldw	r2,-16(fp)
 1205c88:	e0fffb17 	ldw	r3,-20(fp)
 1205c8c:	18c00d17 	ldw	r3,52(r3)
 1205c90:	e13ffb17 	ldw	r4,-20(fp)
 1205c94:	20c7883a 	add	r3,r4,r3
 1205c98:	18c20e04 	addi	r3,r3,2104
 1205c9c:	18c00003 	ldbu	r3,0(r3)
 1205ca0:	18c03fcc 	andi	r3,r3,255
 1205ca4:	18c0201c 	xori	r3,r3,128
 1205ca8:	18ffe004 	addi	r3,r3,-128
 1205cac:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1205cb0:	e0bffb17 	ldw	r2,-20(fp)
 1205cb4:	10800d17 	ldw	r2,52(r2)
 1205cb8:	10800044 	addi	r2,r2,1
 1205cbc:	10c1ffcc 	andi	r3,r2,2047
 1205cc0:	e0bffb17 	ldw	r2,-20(fp)
 1205cc4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 1205cc8:	e0bffa17 	ldw	r2,-24(fp)
 1205ccc:	10bfffc4 	addi	r2,r2,-1
 1205cd0:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 1205cd4:	e0bffa17 	ldw	r2,-24(fp)
 1205cd8:	10000526 	beq	r2,zero,1205cf0 <altera_avalon_jtag_uart_irq+0x1a8>
 1205cdc:	e0bffb17 	ldw	r2,-20(fp)
 1205ce0:	10c00d17 	ldw	r3,52(r2)
 1205ce4:	e0bffb17 	ldw	r2,-20(fp)
 1205ce8:	10800c17 	ldw	r2,48(r2)
 1205cec:	18bfe51e 	bne	r3,r2,1205c84 <__alt_mem_instruction_tcm+0xff205c84>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 1205cf0:	e0bffa17 	ldw	r2,-24(fp)
 1205cf4:	10001026 	beq	r2,zero,1205d38 <altera_avalon_jtag_uart_irq+0x1f0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 1205cf8:	e0bffb17 	ldw	r2,-20(fp)
 1205cfc:	10c00817 	ldw	r3,32(r2)
 1205d00:	00bfff44 	movi	r2,-3
 1205d04:	1886703a 	and	r3,r3,r2
 1205d08:	e0bffb17 	ldw	r2,-20(fp)
 1205d0c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1205d10:	e0bffb17 	ldw	r2,-20(fp)
 1205d14:	10800017 	ldw	r2,0(r2)
 1205d18:	10800104 	addi	r2,r2,4
 1205d1c:	1007883a 	mov	r3,r2
 1205d20:	e0bffb17 	ldw	r2,-20(fp)
 1205d24:	10800817 	ldw	r2,32(r2)
 1205d28:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1205d2c:	e0bffc17 	ldw	r2,-16(fp)
 1205d30:	10800104 	addi	r2,r2,4
 1205d34:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 1205d38:	003f8c06 	br	1205b6c <__alt_mem_instruction_tcm+0xff205b6c>
}
 1205d3c:	e037883a 	mov	sp,fp
 1205d40:	df000017 	ldw	fp,0(sp)
 1205d44:	dec00104 	addi	sp,sp,4
 1205d48:	f800283a 	ret

01205d4c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 1205d4c:	defff804 	addi	sp,sp,-32
 1205d50:	df000715 	stw	fp,28(sp)
 1205d54:	df000704 	addi	fp,sp,28
 1205d58:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 1205d5c:	e0bffb17 	ldw	r2,-20(fp)
 1205d60:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 1205d64:	e0bff917 	ldw	r2,-28(fp)
 1205d68:	10800017 	ldw	r2,0(r2)
 1205d6c:	10800104 	addi	r2,r2,4
 1205d70:	10800037 	ldwio	r2,0(r2)
 1205d74:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 1205d78:	e0bffa17 	ldw	r2,-24(fp)
 1205d7c:	1081000c 	andi	r2,r2,1024
 1205d80:	10000b26 	beq	r2,zero,1205db0 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 1205d84:	e0bff917 	ldw	r2,-28(fp)
 1205d88:	10800017 	ldw	r2,0(r2)
 1205d8c:	10800104 	addi	r2,r2,4
 1205d90:	1007883a 	mov	r3,r2
 1205d94:	e0bff917 	ldw	r2,-28(fp)
 1205d98:	10800817 	ldw	r2,32(r2)
 1205d9c:	10810014 	ori	r2,r2,1024
 1205da0:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 1205da4:	e0bff917 	ldw	r2,-28(fp)
 1205da8:	10000915 	stw	zero,36(r2)
 1205dac:	00000a06 	br	1205dd8 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 1205db0:	e0bff917 	ldw	r2,-28(fp)
 1205db4:	10c00917 	ldw	r3,36(r2)
 1205db8:	00a00034 	movhi	r2,32768
 1205dbc:	10bfff04 	addi	r2,r2,-4
 1205dc0:	10c00536 	bltu	r2,r3,1205dd8 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 1205dc4:	e0bff917 	ldw	r2,-28(fp)
 1205dc8:	10800917 	ldw	r2,36(r2)
 1205dcc:	10c00044 	addi	r3,r2,1
 1205dd0:	e0bff917 	ldw	r2,-28(fp)
 1205dd4:	10c00915 	stw	r3,36(r2)
 1205dd8:	00804874 	movhi	r2,289
 1205ddc:	10a6e804 	addi	r2,r2,-25696
 1205de0:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 1205de4:	e037883a 	mov	sp,fp
 1205de8:	df000017 	ldw	fp,0(sp)
 1205dec:	dec00104 	addi	sp,sp,4
 1205df0:	f800283a 	ret

01205df4 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 1205df4:	defffd04 	addi	sp,sp,-12
 1205df8:	df000215 	stw	fp,8(sp)
 1205dfc:	df000204 	addi	fp,sp,8
 1205e00:	e13ffe15 	stw	r4,-8(fp)
 1205e04:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 1205e08:	00000506 	br	1205e20 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 1205e0c:	e0bfff17 	ldw	r2,-4(fp)
 1205e10:	1090000c 	andi	r2,r2,16384
 1205e14:	10000226 	beq	r2,zero,1205e20 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 1205e18:	00bffd44 	movi	r2,-11
 1205e1c:	00000b06 	br	1205e4c <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 1205e20:	e0bffe17 	ldw	r2,-8(fp)
 1205e24:	10c00d17 	ldw	r3,52(r2)
 1205e28:	e0bffe17 	ldw	r2,-8(fp)
 1205e2c:	10800c17 	ldw	r2,48(r2)
 1205e30:	18800526 	beq	r3,r2,1205e48 <altera_avalon_jtag_uart_close+0x54>
 1205e34:	e0bffe17 	ldw	r2,-8(fp)
 1205e38:	10c00917 	ldw	r3,36(r2)
 1205e3c:	e0bffe17 	ldw	r2,-8(fp)
 1205e40:	10800117 	ldw	r2,4(r2)
 1205e44:	18bff136 	bltu	r3,r2,1205e0c <__alt_mem_instruction_tcm+0xff205e0c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 1205e48:	0005883a 	mov	r2,zero
}
 1205e4c:	e037883a 	mov	sp,fp
 1205e50:	df000017 	ldw	fp,0(sp)
 1205e54:	dec00104 	addi	sp,sp,4
 1205e58:	f800283a 	ret

01205e5c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 1205e5c:	defffa04 	addi	sp,sp,-24
 1205e60:	df000515 	stw	fp,20(sp)
 1205e64:	df000504 	addi	fp,sp,20
 1205e68:	e13ffd15 	stw	r4,-12(fp)
 1205e6c:	e17ffe15 	stw	r5,-8(fp)
 1205e70:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 1205e74:	00bff9c4 	movi	r2,-25
 1205e78:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 1205e7c:	e0bffe17 	ldw	r2,-8(fp)
 1205e80:	10da8060 	cmpeqi	r3,r2,27137
 1205e84:	1800031e 	bne	r3,zero,1205e94 <altera_avalon_jtag_uart_ioctl+0x38>
 1205e88:	109a80a0 	cmpeqi	r2,r2,27138
 1205e8c:	1000191e 	bne	r2,zero,1205ef4 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
 1205e90:	00002806 	br	1205f34 <altera_avalon_jtag_uart_ioctl+0xd8>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 1205e94:	e0bffd17 	ldw	r2,-12(fp)
 1205e98:	10c00117 	ldw	r3,4(r2)
 1205e9c:	00a00034 	movhi	r2,32768
 1205ea0:	10bfffc4 	addi	r2,r2,-1
 1205ea4:	18801226 	beq	r3,r2,1205ef0 <altera_avalon_jtag_uart_ioctl+0x94>
    {
      int timeout = *((int *)arg);
 1205ea8:	e0bfff17 	ldw	r2,-4(fp)
 1205eac:	10800017 	ldw	r2,0(r2)
 1205eb0:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 1205eb4:	e0bffc17 	ldw	r2,-16(fp)
 1205eb8:	10800090 	cmplti	r2,r2,2
 1205ebc:	1000061e 	bne	r2,zero,1205ed8 <altera_avalon_jtag_uart_ioctl+0x7c>
 1205ec0:	e0fffc17 	ldw	r3,-16(fp)
 1205ec4:	00a00034 	movhi	r2,32768
 1205ec8:	10bfffc4 	addi	r2,r2,-1
 1205ecc:	18800226 	beq	r3,r2,1205ed8 <altera_avalon_jtag_uart_ioctl+0x7c>
 1205ed0:	e0bffc17 	ldw	r2,-16(fp)
 1205ed4:	00000206 	br	1205ee0 <altera_avalon_jtag_uart_ioctl+0x84>
 1205ed8:	00a00034 	movhi	r2,32768
 1205edc:	10bfff84 	addi	r2,r2,-2
 1205ee0:	e0fffd17 	ldw	r3,-12(fp)
 1205ee4:	18800115 	stw	r2,4(r3)
      rc = 0;
 1205ee8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 1205eec:	00001106 	br	1205f34 <altera_avalon_jtag_uart_ioctl+0xd8>
 1205ef0:	00001006 	br	1205f34 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 1205ef4:	e0bffd17 	ldw	r2,-12(fp)
 1205ef8:	10c00117 	ldw	r3,4(r2)
 1205efc:	00a00034 	movhi	r2,32768
 1205f00:	10bfffc4 	addi	r2,r2,-1
 1205f04:	18800a26 	beq	r3,r2,1205f30 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 1205f08:	e0bffd17 	ldw	r2,-12(fp)
 1205f0c:	10c00917 	ldw	r3,36(r2)
 1205f10:	e0bffd17 	ldw	r2,-12(fp)
 1205f14:	10800117 	ldw	r2,4(r2)
 1205f18:	1885803a 	cmpltu	r2,r3,r2
 1205f1c:	10c03fcc 	andi	r3,r2,255
 1205f20:	e0bfff17 	ldw	r2,-4(fp)
 1205f24:	10c00015 	stw	r3,0(r2)
      rc = 0;
 1205f28:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 1205f2c:	00000006 	br	1205f30 <altera_avalon_jtag_uart_ioctl+0xd4>
 1205f30:	0001883a 	nop

  default:
    break;
  }

  return rc;
 1205f34:	e0bffb17 	ldw	r2,-20(fp)
}
 1205f38:	e037883a 	mov	sp,fp
 1205f3c:	df000017 	ldw	fp,0(sp)
 1205f40:	dec00104 	addi	sp,sp,4
 1205f44:	f800283a 	ret

01205f48 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 1205f48:	defff304 	addi	sp,sp,-52
 1205f4c:	dfc00c15 	stw	ra,48(sp)
 1205f50:	df000b15 	stw	fp,44(sp)
 1205f54:	df000b04 	addi	fp,sp,44
 1205f58:	e13ffc15 	stw	r4,-16(fp)
 1205f5c:	e17ffd15 	stw	r5,-12(fp)
 1205f60:	e1bffe15 	stw	r6,-8(fp)
 1205f64:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 1205f68:	e0bffd17 	ldw	r2,-12(fp)
 1205f6c:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 1205f70:	00004906 	br	1206098 <altera_avalon_jtag_uart_read+0x150>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 1205f74:	e0bffc17 	ldw	r2,-16(fp)
 1205f78:	10800a17 	ldw	r2,40(r2)
 1205f7c:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 1205f80:	e0bffc17 	ldw	r2,-16(fp)
 1205f84:	10800b17 	ldw	r2,44(r2)
 1205f88:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 1205f8c:	e0fff717 	ldw	r3,-36(fp)
 1205f90:	e0bff817 	ldw	r2,-32(fp)
 1205f94:	18800536 	bltu	r3,r2,1205fac <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 1205f98:	e0fff717 	ldw	r3,-36(fp)
 1205f9c:	e0bff817 	ldw	r2,-32(fp)
 1205fa0:	1885c83a 	sub	r2,r3,r2
 1205fa4:	e0bff615 	stw	r2,-40(fp)
 1205fa8:	00000406 	br	1205fbc <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 1205fac:	00c20004 	movi	r3,2048
 1205fb0:	e0bff817 	ldw	r2,-32(fp)
 1205fb4:	1885c83a 	sub	r2,r3,r2
 1205fb8:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 1205fbc:	e0bff617 	ldw	r2,-40(fp)
 1205fc0:	1000011e 	bne	r2,zero,1205fc8 <altera_avalon_jtag_uart_read+0x80>
        break; /* No more data available */
 1205fc4:	00001d06 	br	120603c <altera_avalon_jtag_uart_read+0xf4>

      if (n > space)
 1205fc8:	e0fffe17 	ldw	r3,-8(fp)
 1205fcc:	e0bff617 	ldw	r2,-40(fp)
 1205fd0:	1880022e 	bgeu	r3,r2,1205fdc <altera_avalon_jtag_uart_read+0x94>
        n = space;
 1205fd4:	e0bffe17 	ldw	r2,-8(fp)
 1205fd8:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 1205fdc:	e0bff817 	ldw	r2,-32(fp)
 1205fe0:	10800e04 	addi	r2,r2,56
 1205fe4:	e0fffc17 	ldw	r3,-16(fp)
 1205fe8:	1885883a 	add	r2,r3,r2
 1205fec:	e13ff517 	ldw	r4,-44(fp)
 1205ff0:	100b883a 	mov	r5,r2
 1205ff4:	e1bff617 	ldw	r6,-40(fp)
 1205ff8:	12013340 	call	1201334 <memcpy>
      ptr   += n;
 1205ffc:	e0fff517 	ldw	r3,-44(fp)
 1206000:	e0bff617 	ldw	r2,-40(fp)
 1206004:	1885883a 	add	r2,r3,r2
 1206008:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 120600c:	e0fffe17 	ldw	r3,-8(fp)
 1206010:	e0bff617 	ldw	r2,-40(fp)
 1206014:	1885c83a 	sub	r2,r3,r2
 1206018:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 120601c:	e0fff817 	ldw	r3,-32(fp)
 1206020:	e0bff617 	ldw	r2,-40(fp)
 1206024:	1885883a 	add	r2,r3,r2
 1206028:	10c1ffcc 	andi	r3,r2,2047
 120602c:	e0bffc17 	ldw	r2,-16(fp)
 1206030:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 1206034:	e0bffe17 	ldw	r2,-8(fp)
 1206038:	00bfce16 	blt	zero,r2,1205f74 <__alt_mem_instruction_tcm+0xff205f74>

    /* If we read any data then return it */
    if (ptr != buffer)
 120603c:	e0fff517 	ldw	r3,-44(fp)
 1206040:	e0bffd17 	ldw	r2,-12(fp)
 1206044:	18800126 	beq	r3,r2,120604c <altera_avalon_jtag_uart_read+0x104>
      break;
 1206048:	00001506 	br	12060a0 <altera_avalon_jtag_uart_read+0x158>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 120604c:	e0bfff17 	ldw	r2,-4(fp)
 1206050:	1090000c 	andi	r2,r2,16384
 1206054:	10000126 	beq	r2,zero,120605c <altera_avalon_jtag_uart_read+0x114>
      break;
 1206058:	00001106 	br	12060a0 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 120605c:	0001883a 	nop
 1206060:	e0bffc17 	ldw	r2,-16(fp)
 1206064:	10c00a17 	ldw	r3,40(r2)
 1206068:	e0bff717 	ldw	r2,-36(fp)
 120606c:	1880051e 	bne	r3,r2,1206084 <altera_avalon_jtag_uart_read+0x13c>
 1206070:	e0bffc17 	ldw	r2,-16(fp)
 1206074:	10c00917 	ldw	r3,36(r2)
 1206078:	e0bffc17 	ldw	r2,-16(fp)
 120607c:	10800117 	ldw	r2,4(r2)
 1206080:	18bff736 	bltu	r3,r2,1206060 <__alt_mem_instruction_tcm+0xff206060>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 1206084:	e0bffc17 	ldw	r2,-16(fp)
 1206088:	10c00a17 	ldw	r3,40(r2)
 120608c:	e0bff717 	ldw	r2,-36(fp)
 1206090:	1880011e 	bne	r3,r2,1206098 <altera_avalon_jtag_uart_read+0x150>
      break;
 1206094:	00000206 	br	12060a0 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 1206098:	e0bffe17 	ldw	r2,-8(fp)
 120609c:	00bfb516 	blt	zero,r2,1205f74 <__alt_mem_instruction_tcm+0xff205f74>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 12060a0:	e0fff517 	ldw	r3,-44(fp)
 12060a4:	e0bffd17 	ldw	r2,-12(fp)
 12060a8:	18801826 	beq	r3,r2,120610c <altera_avalon_jtag_uart_read+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 12060ac:	0005303a 	rdctl	r2,status
 12060b0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 12060b4:	e0fffa17 	ldw	r3,-24(fp)
 12060b8:	00bfff84 	movi	r2,-2
 12060bc:	1884703a 	and	r2,r3,r2
 12060c0:	1001703a 	wrctl	status,r2
  
  return context;
 12060c4:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 12060c8:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 12060cc:	e0bffc17 	ldw	r2,-16(fp)
 12060d0:	10800817 	ldw	r2,32(r2)
 12060d4:	10c00054 	ori	r3,r2,1
 12060d8:	e0bffc17 	ldw	r2,-16(fp)
 12060dc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 12060e0:	e0bffc17 	ldw	r2,-16(fp)
 12060e4:	10800017 	ldw	r2,0(r2)
 12060e8:	10800104 	addi	r2,r2,4
 12060ec:	1007883a 	mov	r3,r2
 12060f0:	e0bffc17 	ldw	r2,-16(fp)
 12060f4:	10800817 	ldw	r2,32(r2)
 12060f8:	18800035 	stwio	r2,0(r3)
 12060fc:	e0bff917 	ldw	r2,-28(fp)
 1206100:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1206104:	e0bffb17 	ldw	r2,-20(fp)
 1206108:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 120610c:	e0fff517 	ldw	r3,-44(fp)
 1206110:	e0bffd17 	ldw	r2,-12(fp)
 1206114:	18800426 	beq	r3,r2,1206128 <altera_avalon_jtag_uart_read+0x1e0>
    return ptr - buffer;
 1206118:	e0fff517 	ldw	r3,-44(fp)
 120611c:	e0bffd17 	ldw	r2,-12(fp)
 1206120:	1885c83a 	sub	r2,r3,r2
 1206124:	00000606 	br	1206140 <altera_avalon_jtag_uart_read+0x1f8>
  else if (flags & O_NONBLOCK)
 1206128:	e0bfff17 	ldw	r2,-4(fp)
 120612c:	1090000c 	andi	r2,r2,16384
 1206130:	10000226 	beq	r2,zero,120613c <altera_avalon_jtag_uart_read+0x1f4>
    return -EWOULDBLOCK;
 1206134:	00bffd44 	movi	r2,-11
 1206138:	00000106 	br	1206140 <altera_avalon_jtag_uart_read+0x1f8>
  else
    return -EIO;
 120613c:	00bffec4 	movi	r2,-5
}
 1206140:	e037883a 	mov	sp,fp
 1206144:	dfc00117 	ldw	ra,4(sp)
 1206148:	df000017 	ldw	fp,0(sp)
 120614c:	dec00204 	addi	sp,sp,8
 1206150:	f800283a 	ret

01206154 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 1206154:	defff304 	addi	sp,sp,-52
 1206158:	dfc00c15 	stw	ra,48(sp)
 120615c:	df000b15 	stw	fp,44(sp)
 1206160:	df000b04 	addi	fp,sp,44
 1206164:	e13ffc15 	stw	r4,-16(fp)
 1206168:	e17ffd15 	stw	r5,-12(fp)
 120616c:	e1bffe15 	stw	r6,-8(fp)
 1206170:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 1206174:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 1206178:	e0bffd17 	ldw	r2,-12(fp)
 120617c:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1206180:	00003806 	br	1206264 <altera_avalon_jtag_uart_write+0x110>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 1206184:	e0bffc17 	ldw	r2,-16(fp)
 1206188:	10800c17 	ldw	r2,48(r2)
 120618c:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
 1206190:	e0bffc17 	ldw	r2,-16(fp)
 1206194:	10800d17 	ldw	r2,52(r2)
 1206198:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 120619c:	e0fff817 	ldw	r3,-32(fp)
 12061a0:	e0bff517 	ldw	r2,-44(fp)
 12061a4:	1880062e 	bgeu	r3,r2,12061c0 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 12061a8:	e0fff517 	ldw	r3,-44(fp)
 12061ac:	e0bff817 	ldw	r2,-32(fp)
 12061b0:	1885c83a 	sub	r2,r3,r2
 12061b4:	10bfffc4 	addi	r2,r2,-1
 12061b8:	e0bff615 	stw	r2,-40(fp)
 12061bc:	00000b06 	br	12061ec <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 12061c0:	e0bff517 	ldw	r2,-44(fp)
 12061c4:	10000526 	beq	r2,zero,12061dc <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 12061c8:	00c20004 	movi	r3,2048
 12061cc:	e0bff817 	ldw	r2,-32(fp)
 12061d0:	1885c83a 	sub	r2,r3,r2
 12061d4:	e0bff615 	stw	r2,-40(fp)
 12061d8:	00000406 	br	12061ec <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 12061dc:	00c1ffc4 	movi	r3,2047
 12061e0:	e0bff817 	ldw	r2,-32(fp)
 12061e4:	1885c83a 	sub	r2,r3,r2
 12061e8:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 12061ec:	e0bff617 	ldw	r2,-40(fp)
 12061f0:	1000011e 	bne	r2,zero,12061f8 <altera_avalon_jtag_uart_write+0xa4>
        break;
 12061f4:	00001d06 	br	120626c <altera_avalon_jtag_uart_write+0x118>

      if (n > count)
 12061f8:	e0fffe17 	ldw	r3,-8(fp)
 12061fc:	e0bff617 	ldw	r2,-40(fp)
 1206200:	1880022e 	bgeu	r3,r2,120620c <altera_avalon_jtag_uart_write+0xb8>
        n = count;
 1206204:	e0bffe17 	ldw	r2,-8(fp)
 1206208:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 120620c:	e0bff817 	ldw	r2,-32(fp)
 1206210:	10820e04 	addi	r2,r2,2104
 1206214:	e0fffc17 	ldw	r3,-16(fp)
 1206218:	1885883a 	add	r2,r3,r2
 120621c:	1009883a 	mov	r4,r2
 1206220:	e17ffd17 	ldw	r5,-12(fp)
 1206224:	e1bff617 	ldw	r6,-40(fp)
 1206228:	12013340 	call	1201334 <memcpy>
      ptr   += n;
 120622c:	e0fffd17 	ldw	r3,-12(fp)
 1206230:	e0bff617 	ldw	r2,-40(fp)
 1206234:	1885883a 	add	r2,r3,r2
 1206238:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 120623c:	e0fffe17 	ldw	r3,-8(fp)
 1206240:	e0bff617 	ldw	r2,-40(fp)
 1206244:	1885c83a 	sub	r2,r3,r2
 1206248:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 120624c:	e0fff817 	ldw	r3,-32(fp)
 1206250:	e0bff617 	ldw	r2,-40(fp)
 1206254:	1885883a 	add	r2,r3,r2
 1206258:	10c1ffcc 	andi	r3,r2,2047
 120625c:	e0bffc17 	ldw	r2,-16(fp)
 1206260:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1206264:	e0bffe17 	ldw	r2,-8(fp)
 1206268:	00bfc616 	blt	zero,r2,1206184 <__alt_mem_instruction_tcm+0xff206184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 120626c:	0005303a 	rdctl	r2,status
 1206270:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1206274:	e0fffa17 	ldw	r3,-24(fp)
 1206278:	00bfff84 	movi	r2,-2
 120627c:	1884703a 	and	r2,r3,r2
 1206280:	1001703a 	wrctl	status,r2
  
  return context;
 1206284:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 1206288:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 120628c:	e0bffc17 	ldw	r2,-16(fp)
 1206290:	10800817 	ldw	r2,32(r2)
 1206294:	10c00094 	ori	r3,r2,2
 1206298:	e0bffc17 	ldw	r2,-16(fp)
 120629c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 12062a0:	e0bffc17 	ldw	r2,-16(fp)
 12062a4:	10800017 	ldw	r2,0(r2)
 12062a8:	10800104 	addi	r2,r2,4
 12062ac:	1007883a 	mov	r3,r2
 12062b0:	e0bffc17 	ldw	r2,-16(fp)
 12062b4:	10800817 	ldw	r2,32(r2)
 12062b8:	18800035 	stwio	r2,0(r3)
 12062bc:	e0bff917 	ldw	r2,-28(fp)
 12062c0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 12062c4:	e0bffb17 	ldw	r2,-20(fp)
 12062c8:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 12062cc:	e0bffe17 	ldw	r2,-8(fp)
 12062d0:	0080120e 	bge	zero,r2,120631c <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
 12062d4:	e0bfff17 	ldw	r2,-4(fp)
 12062d8:	1090000c 	andi	r2,r2,16384
 12062dc:	10000126 	beq	r2,zero,12062e4 <altera_avalon_jtag_uart_write+0x190>
        break;
 12062e0:	00001006 	br	1206324 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 12062e4:	0001883a 	nop
 12062e8:	e0bffc17 	ldw	r2,-16(fp)
 12062ec:	10c00d17 	ldw	r3,52(r2)
 12062f0:	e0bff517 	ldw	r2,-44(fp)
 12062f4:	1880051e 	bne	r3,r2,120630c <altera_avalon_jtag_uart_write+0x1b8>
 12062f8:	e0bffc17 	ldw	r2,-16(fp)
 12062fc:	10c00917 	ldw	r3,36(r2)
 1206300:	e0bffc17 	ldw	r2,-16(fp)
 1206304:	10800117 	ldw	r2,4(r2)
 1206308:	18bff736 	bltu	r3,r2,12062e8 <__alt_mem_instruction_tcm+0xff2062e8>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 120630c:	e0bffc17 	ldw	r2,-16(fp)
 1206310:	10800917 	ldw	r2,36(r2)
 1206314:	10000126 	beq	r2,zero,120631c <altera_avalon_jtag_uart_write+0x1c8>
         break;
 1206318:	00000206 	br	1206324 <altera_avalon_jtag_uart_write+0x1d0>
    }
  }
  while (count > 0);
 120631c:	e0bffe17 	ldw	r2,-8(fp)
 1206320:	00bf9716 	blt	zero,r2,1206180 <__alt_mem_instruction_tcm+0xff206180>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 1206324:	e0fffd17 	ldw	r3,-12(fp)
 1206328:	e0bff717 	ldw	r2,-36(fp)
 120632c:	18800426 	beq	r3,r2,1206340 <altera_avalon_jtag_uart_write+0x1ec>
    return ptr - start;
 1206330:	e0fffd17 	ldw	r3,-12(fp)
 1206334:	e0bff717 	ldw	r2,-36(fp)
 1206338:	1885c83a 	sub	r2,r3,r2
 120633c:	00000606 	br	1206358 <altera_avalon_jtag_uart_write+0x204>
  else if (flags & O_NONBLOCK)
 1206340:	e0bfff17 	ldw	r2,-4(fp)
 1206344:	1090000c 	andi	r2,r2,16384
 1206348:	10000226 	beq	r2,zero,1206354 <altera_avalon_jtag_uart_write+0x200>
    return -EWOULDBLOCK;
 120634c:	00bffd44 	movi	r2,-11
 1206350:	00000106 	br	1206358 <altera_avalon_jtag_uart_write+0x204>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 1206354:	00bffec4 	movi	r2,-5
}
 1206358:	e037883a 	mov	sp,fp
 120635c:	dfc00117 	ldw	ra,4(sp)
 1206360:	df000017 	ldw	fp,0(sp)
 1206364:	dec00204 	addi	sp,sp,8
 1206368:	f800283a 	ret

0120636c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 120636c:	defffa04 	addi	sp,sp,-24
 1206370:	dfc00515 	stw	ra,20(sp)
 1206374:	df000415 	stw	fp,16(sp)
 1206378:	df000404 	addi	fp,sp,16
 120637c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 1206380:	0007883a 	mov	r3,zero
 1206384:	e0bfff17 	ldw	r2,-4(fp)
 1206388:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 120638c:	e0bfff17 	ldw	r2,-4(fp)
 1206390:	10800104 	addi	r2,r2,4
 1206394:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1206398:	0005303a 	rdctl	r2,status
 120639c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 12063a0:	e0fffd17 	ldw	r3,-12(fp)
 12063a4:	00bfff84 	movi	r2,-2
 12063a8:	1884703a 	and	r2,r3,r2
 12063ac:	1001703a 	wrctl	status,r2
  
  return context;
 12063b0:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 12063b4:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 12063b8:	1206eb80 	call	1206eb8 <alt_tick>
 12063bc:	e0bffc17 	ldw	r2,-16(fp)
 12063c0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 12063c4:	e0bffe17 	ldw	r2,-8(fp)
 12063c8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 12063cc:	e037883a 	mov	sp,fp
 12063d0:	dfc00117 	ldw	ra,4(sp)
 12063d4:	df000017 	ldw	fp,0(sp)
 12063d8:	dec00204 	addi	sp,sp,8
 12063dc:	f800283a 	ret

012063e0 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 12063e0:	defff804 	addi	sp,sp,-32
 12063e4:	dfc00715 	stw	ra,28(sp)
 12063e8:	df000615 	stw	fp,24(sp)
 12063ec:	df000604 	addi	fp,sp,24
 12063f0:	e13ffc15 	stw	r4,-16(fp)
 12063f4:	e17ffd15 	stw	r5,-12(fp)
 12063f8:	e1bffe15 	stw	r6,-8(fp)
 12063fc:	e1ffff15 	stw	r7,-4(fp)
 1206400:	e0bfff17 	ldw	r2,-4(fp)
 1206404:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 1206408:	00804874 	movhi	r2,289
 120640c:	10a6e804 	addi	r2,r2,-25696
 1206410:	10800017 	ldw	r2,0(r2)
 1206414:	1000041e 	bne	r2,zero,1206428 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
 1206418:	00804874 	movhi	r2,289
 120641c:	10a6e804 	addi	r2,r2,-25696
 1206420:	e0fffb17 	ldw	r3,-20(fp)
 1206424:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 1206428:	e0bffc17 	ldw	r2,-16(fp)
 120642c:	10800104 	addi	r2,r2,4
 1206430:	00c001c4 	movi	r3,7
 1206434:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 1206438:	d8000015 	stw	zero,0(sp)
 120643c:	e13ffd17 	ldw	r4,-12(fp)
 1206440:	e17ffe17 	ldw	r5,-8(fp)
 1206444:	01804834 	movhi	r6,288
 1206448:	3198db04 	addi	r6,r6,25452
 120644c:	e1fffc17 	ldw	r7,-16(fp)
 1206450:	12031f40 	call	12031f4 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 1206454:	e037883a 	mov	sp,fp
 1206458:	dfc00117 	ldw	ra,4(sp)
 120645c:	df000017 	ldw	fp,0(sp)
 1206460:	dec00204 	addi	sp,sp,8
 1206464:	f800283a 	ret

01206468 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 1206468:	defff504 	addi	sp,sp,-44
 120646c:	df000a15 	stw	fp,40(sp)
 1206470:	df000a04 	addi	fp,sp,40
 1206474:	e13ffc15 	stw	r4,-16(fp)
 1206478:	e17ffd15 	stw	r5,-12(fp)
 120647c:	e1bffe15 	stw	r6,-8(fp)
 1206480:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 1206484:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1206488:	00804874 	movhi	r2,289
 120648c:	10a6e804 	addi	r2,r2,-25696
 1206490:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 1206494:	10003f26 	beq	r2,zero,1206594 <alt_alarm_start+0x12c>
  {
    if (alarm)
 1206498:	e0bffc17 	ldw	r2,-16(fp)
 120649c:	10003b26 	beq	r2,zero,120658c <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
 12064a0:	e0bffc17 	ldw	r2,-16(fp)
 12064a4:	e0fffe17 	ldw	r3,-8(fp)
 12064a8:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 12064ac:	e0bffc17 	ldw	r2,-16(fp)
 12064b0:	e0ffff17 	ldw	r3,-4(fp)
 12064b4:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 12064b8:	0005303a 	rdctl	r2,status
 12064bc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 12064c0:	e0fff817 	ldw	r3,-32(fp)
 12064c4:	00bfff84 	movi	r2,-2
 12064c8:	1884703a 	and	r2,r3,r2
 12064cc:	1001703a 	wrctl	status,r2
  
  return context;
 12064d0:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 12064d4:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 12064d8:	00804874 	movhi	r2,289
 12064dc:	10a6e904 	addi	r2,r2,-25692
 12064e0:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 12064e4:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 12064e8:	e0fffd17 	ldw	r3,-12(fp)
 12064ec:	e0bff617 	ldw	r2,-40(fp)
 12064f0:	1885883a 	add	r2,r3,r2
 12064f4:	10c00044 	addi	r3,r2,1
 12064f8:	e0bffc17 	ldw	r2,-16(fp)
 12064fc:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 1206500:	e0bffc17 	ldw	r2,-16(fp)
 1206504:	10c00217 	ldw	r3,8(r2)
 1206508:	e0bff617 	ldw	r2,-40(fp)
 120650c:	1880042e 	bgeu	r3,r2,1206520 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
 1206510:	e0bffc17 	ldw	r2,-16(fp)
 1206514:	00c00044 	movi	r3,1
 1206518:	10c00405 	stb	r3,16(r2)
 120651c:	00000206 	br	1206528 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
 1206520:	e0bffc17 	ldw	r2,-16(fp)
 1206524:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 1206528:	e0fffc17 	ldw	r3,-16(fp)
 120652c:	00804874 	movhi	r2,289
 1206530:	10a6dc04 	addi	r2,r2,-25744
 1206534:	e0bff915 	stw	r2,-28(fp)
 1206538:	e0fffa15 	stw	r3,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 120653c:	e0bffa17 	ldw	r2,-24(fp)
 1206540:	e0fff917 	ldw	r3,-28(fp)
 1206544:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1206548:	e0bff917 	ldw	r2,-28(fp)
 120654c:	10c00017 	ldw	r3,0(r2)
 1206550:	e0bffa17 	ldw	r2,-24(fp)
 1206554:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1206558:	e0bff917 	ldw	r2,-28(fp)
 120655c:	10800017 	ldw	r2,0(r2)
 1206560:	e0fffa17 	ldw	r3,-24(fp)
 1206564:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 1206568:	e0bff917 	ldw	r2,-28(fp)
 120656c:	e0fffa17 	ldw	r3,-24(fp)
 1206570:	10c00015 	stw	r3,0(r2)
 1206574:	e0bff717 	ldw	r2,-36(fp)
 1206578:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 120657c:	e0bffb17 	ldw	r2,-20(fp)
 1206580:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 1206584:	0005883a 	mov	r2,zero
 1206588:	00000306 	br	1206598 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
 120658c:	00bffa84 	movi	r2,-22
 1206590:	00000106 	br	1206598 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
 1206594:	00bfde84 	movi	r2,-134
  }
}
 1206598:	e037883a 	mov	sp,fp
 120659c:	df000017 	ldw	fp,0(sp)
 12065a0:	dec00104 	addi	sp,sp,4
 12065a4:	f800283a 	ret

012065a8 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 12065a8:	defffa04 	addi	sp,sp,-24
 12065ac:	dfc00515 	stw	ra,20(sp)
 12065b0:	df000415 	stw	fp,16(sp)
 12065b4:	df000404 	addi	fp,sp,16
 12065b8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 12065bc:	008000c4 	movi	r2,3
 12065c0:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 12065c4:	e0fffd17 	ldw	r3,-12(fp)
 12065c8:	008003f4 	movhi	r2,15
 12065cc:	10909004 	addi	r2,r2,16960
 12065d0:	1885383a 	mul	r2,r3,r2
 12065d4:	0100bef4 	movhi	r4,763
 12065d8:	213c2004 	addi	r4,r4,-3968
 12065dc:	100b883a 	mov	r5,r2
 12065e0:	1207f740 	call	1207f74 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 12065e4:	01200034 	movhi	r4,32768
 12065e8:	213fffc4 	addi	r4,r4,-1
 12065ec:	100b883a 	mov	r5,r2
 12065f0:	1207f740 	call	1207f74 <__udivsi3>
 12065f4:	e13fff17 	ldw	r4,-4(fp)
 12065f8:	100b883a 	mov	r5,r2
 12065fc:	1207f740 	call	1207f74 <__udivsi3>
 1206600:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 1206604:	e0bffe17 	ldw	r2,-8(fp)
 1206608:	10002a26 	beq	r2,zero,12066b4 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 120660c:	e03ffc15 	stw	zero,-16(fp)
 1206610:	00001706 	br	1206670 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 1206614:	00a00034 	movhi	r2,32768
 1206618:	10bfffc4 	addi	r2,r2,-1
 120661c:	10bfffc4 	addi	r2,r2,-1
 1206620:	103ffe1e 	bne	r2,zero,120661c <__alt_mem_instruction_tcm+0xff20661c>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 1206624:	e0fffd17 	ldw	r3,-12(fp)
 1206628:	008003f4 	movhi	r2,15
 120662c:	10909004 	addi	r2,r2,16960
 1206630:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 1206634:	0100bef4 	movhi	r4,763
 1206638:	213c2004 	addi	r4,r4,-3968
 120663c:	100b883a 	mov	r5,r2
 1206640:	1207f740 	call	1207f74 <__udivsi3>
 1206644:	01200034 	movhi	r4,32768
 1206648:	213fffc4 	addi	r4,r4,-1
 120664c:	100b883a 	mov	r5,r2
 1206650:	1207f740 	call	1207f74 <__udivsi3>
 1206654:	1007883a 	mov	r3,r2
 1206658:	e0bfff17 	ldw	r2,-4(fp)
 120665c:	10c5c83a 	sub	r2,r2,r3
 1206660:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 1206664:	e0bffc17 	ldw	r2,-16(fp)
 1206668:	10800044 	addi	r2,r2,1
 120666c:	e0bffc15 	stw	r2,-16(fp)
 1206670:	e0fffc17 	ldw	r3,-16(fp)
 1206674:	e0bffe17 	ldw	r2,-8(fp)
 1206678:	18bfe616 	blt	r3,r2,1206614 <__alt_mem_instruction_tcm+0xff206614>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 120667c:	e0fffd17 	ldw	r3,-12(fp)
 1206680:	008003f4 	movhi	r2,15
 1206684:	10909004 	addi	r2,r2,16960
 1206688:	1885383a 	mul	r2,r3,r2
 120668c:	0100bef4 	movhi	r4,763
 1206690:	213c2004 	addi	r4,r4,-3968
 1206694:	100b883a 	mov	r5,r2
 1206698:	1207f740 	call	1207f74 <__udivsi3>
 120669c:	1007883a 	mov	r3,r2
 12066a0:	e0bfff17 	ldw	r2,-4(fp)
 12066a4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 12066a8:	10bfffc4 	addi	r2,r2,-1
 12066ac:	103ffe1e 	bne	r2,zero,12066a8 <__alt_mem_instruction_tcm+0xff2066a8>
 12066b0:	00000d06 	br	12066e8 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 12066b4:	e0fffd17 	ldw	r3,-12(fp)
 12066b8:	008003f4 	movhi	r2,15
 12066bc:	10909004 	addi	r2,r2,16960
 12066c0:	1885383a 	mul	r2,r3,r2
 12066c4:	0100bef4 	movhi	r4,763
 12066c8:	213c2004 	addi	r4,r4,-3968
 12066cc:	100b883a 	mov	r5,r2
 12066d0:	1207f740 	call	1207f74 <__udivsi3>
 12066d4:	1007883a 	mov	r3,r2
 12066d8:	e0bfff17 	ldw	r2,-4(fp)
 12066dc:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 12066e0:	10bfffc4 	addi	r2,r2,-1
 12066e4:	00bffe16 	blt	zero,r2,12066e0 <__alt_mem_instruction_tcm+0xff2066e0>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 12066e8:	0005883a 	mov	r2,zero
}
 12066ec:	e037883a 	mov	sp,fp
 12066f0:	dfc00117 	ldw	ra,4(sp)
 12066f4:	df000017 	ldw	fp,0(sp)
 12066f8:	dec00204 	addi	sp,sp,8
 12066fc:	f800283a 	ret

01206700 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 1206700:	defffb04 	addi	sp,sp,-20
 1206704:	df000415 	stw	fp,16(sp)
 1206708:	df000404 	addi	fp,sp,16
 120670c:	e13ffe15 	stw	r4,-8(fp)
 1206710:	e17fff15 	stw	r5,-4(fp)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 
 1206714:	e0fffe17 	ldw	r3,-8(fp)
 1206718:	e0bfff17 	ldw	r2,-4(fp)
 120671c:	1885883a 	add	r2,r3,r2
 1206720:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 1206724:	e0bffe17 	ldw	r2,-8(fp)
 1206728:	e0bffc15 	stw	r2,-16(fp)
 120672c:	00000506 	br	1206744 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 1206730:	e0bffc17 	ldw	r2,-16(fp)
 1206734:	1000001b 	flushda	0(r2)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 1206738:	e0bffc17 	ldw	r2,-16(fp)
 120673c:	10800804 	addi	r2,r2,32
 1206740:	e0bffc15 	stw	r2,-16(fp)
 1206744:	e0fffc17 	ldw	r3,-16(fp)
 1206748:	e0bffd17 	ldw	r2,-12(fp)
 120674c:	18bff836 	bltu	r3,r2,1206730 <__alt_mem_instruction_tcm+0xff206730>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 1206750:	e0bffe17 	ldw	r2,-8(fp)
 1206754:	108007cc 	andi	r2,r2,31
 1206758:	10000226 	beq	r2,zero,1206764 <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 120675c:	e0bffc17 	ldw	r2,-16(fp)
 1206760:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 1206764:	e037883a 	mov	sp,fp
 1206768:	df000017 	ldw	fp,0(sp)
 120676c:	dec00104 	addi	sp,sp,4
 1206770:	f800283a 	ret

01206774 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1206774:	defffe04 	addi	sp,sp,-8
 1206778:	dfc00115 	stw	ra,4(sp)
 120677c:	df000015 	stw	fp,0(sp)
 1206780:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1206784:	00804874 	movhi	r2,289
 1206788:	10a6d704 	addi	r2,r2,-25764
 120678c:	10800017 	ldw	r2,0(r2)
 1206790:	10000526 	beq	r2,zero,12067a8 <alt_get_errno+0x34>
 1206794:	00804874 	movhi	r2,289
 1206798:	10a6d704 	addi	r2,r2,-25764
 120679c:	10800017 	ldw	r2,0(r2)
 12067a0:	103ee83a 	callr	r2
 12067a4:	00000206 	br	12067b0 <alt_get_errno+0x3c>
 12067a8:	00804874 	movhi	r2,289
 12067ac:	10a6e204 	addi	r2,r2,-25720
}
 12067b0:	e037883a 	mov	sp,fp
 12067b4:	dfc00117 	ldw	ra,4(sp)
 12067b8:	df000017 	ldw	fp,0(sp)
 12067bc:	dec00204 	addi	sp,sp,8
 12067c0:	f800283a 	ret

012067c4 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 12067c4:	defffa04 	addi	sp,sp,-24
 12067c8:	dfc00515 	stw	ra,20(sp)
 12067cc:	df000415 	stw	fp,16(sp)
 12067d0:	df000404 	addi	fp,sp,16
 12067d4:	e13ffe15 	stw	r4,-8(fp)
 12067d8:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 12067dc:	e0bffe17 	ldw	r2,-8(fp)
 12067e0:	10000326 	beq	r2,zero,12067f0 <alt_dev_llist_insert+0x2c>
 12067e4:	e0bffe17 	ldw	r2,-8(fp)
 12067e8:	10800217 	ldw	r2,8(r2)
 12067ec:	1000061e 	bne	r2,zero,1206808 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 12067f0:	12067740 	call	1206774 <alt_get_errno>
 12067f4:	1007883a 	mov	r3,r2
 12067f8:	00800584 	movi	r2,22
 12067fc:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 1206800:	00bffa84 	movi	r2,-22
 1206804:	00001306 	br	1206854 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 1206808:	e0bffe17 	ldw	r2,-8(fp)
 120680c:	e0ffff17 	ldw	r3,-4(fp)
 1206810:	e0fffc15 	stw	r3,-16(fp)
 1206814:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1206818:	e0bffd17 	ldw	r2,-12(fp)
 120681c:	e0fffc17 	ldw	r3,-16(fp)
 1206820:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1206824:	e0bffc17 	ldw	r2,-16(fp)
 1206828:	10c00017 	ldw	r3,0(r2)
 120682c:	e0bffd17 	ldw	r2,-12(fp)
 1206830:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1206834:	e0bffc17 	ldw	r2,-16(fp)
 1206838:	10800017 	ldw	r2,0(r2)
 120683c:	e0fffd17 	ldw	r3,-12(fp)
 1206840:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 1206844:	e0bffc17 	ldw	r2,-16(fp)
 1206848:	e0fffd17 	ldw	r3,-12(fp)
 120684c:	10c00015 	stw	r3,0(r2)

  return 0;  
 1206850:	0005883a 	mov	r2,zero
}
 1206854:	e037883a 	mov	sp,fp
 1206858:	dfc00117 	ldw	ra,4(sp)
 120685c:	df000017 	ldw	fp,0(sp)
 1206860:	dec00204 	addi	sp,sp,8
 1206864:	f800283a 	ret

01206868 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 1206868:	defffd04 	addi	sp,sp,-12
 120686c:	dfc00215 	stw	ra,8(sp)
 1206870:	df000115 	stw	fp,4(sp)
 1206874:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1206878:	00804834 	movhi	r2,288
 120687c:	109fed04 	addi	r2,r2,32692
 1206880:	e0bfff15 	stw	r2,-4(fp)
 1206884:	00000606 	br	12068a0 <_do_ctors+0x38>
        (*ctor) (); 
 1206888:	e0bfff17 	ldw	r2,-4(fp)
 120688c:	10800017 	ldw	r2,0(r2)
 1206890:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1206894:	e0bfff17 	ldw	r2,-4(fp)
 1206898:	10bfff04 	addi	r2,r2,-4
 120689c:	e0bfff15 	stw	r2,-4(fp)
 12068a0:	e0ffff17 	ldw	r3,-4(fp)
 12068a4:	00804834 	movhi	r2,288
 12068a8:	109fee04 	addi	r2,r2,32696
 12068ac:	18bff62e 	bgeu	r3,r2,1206888 <__alt_mem_instruction_tcm+0xff206888>
        (*ctor) (); 
}
 12068b0:	e037883a 	mov	sp,fp
 12068b4:	dfc00117 	ldw	ra,4(sp)
 12068b8:	df000017 	ldw	fp,0(sp)
 12068bc:	dec00204 	addi	sp,sp,8
 12068c0:	f800283a 	ret

012068c4 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 12068c4:	defffd04 	addi	sp,sp,-12
 12068c8:	dfc00215 	stw	ra,8(sp)
 12068cc:	df000115 	stw	fp,4(sp)
 12068d0:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 12068d4:	00804834 	movhi	r2,288
 12068d8:	109fed04 	addi	r2,r2,32692
 12068dc:	e0bfff15 	stw	r2,-4(fp)
 12068e0:	00000606 	br	12068fc <_do_dtors+0x38>
        (*dtor) (); 
 12068e4:	e0bfff17 	ldw	r2,-4(fp)
 12068e8:	10800017 	ldw	r2,0(r2)
 12068ec:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 12068f0:	e0bfff17 	ldw	r2,-4(fp)
 12068f4:	10bfff04 	addi	r2,r2,-4
 12068f8:	e0bfff15 	stw	r2,-4(fp)
 12068fc:	e0ffff17 	ldw	r3,-4(fp)
 1206900:	00804834 	movhi	r2,288
 1206904:	109fee04 	addi	r2,r2,32696
 1206908:	18bff62e 	bgeu	r3,r2,12068e4 <__alt_mem_instruction_tcm+0xff2068e4>
        (*dtor) (); 
}
 120690c:	e037883a 	mov	sp,fp
 1206910:	dfc00117 	ldw	ra,4(sp)
 1206914:	df000017 	ldw	fp,0(sp)
 1206918:	dec00204 	addi	sp,sp,8
 120691c:	f800283a 	ret

01206920 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 1206920:	defffc04 	addi	sp,sp,-16
 1206924:	dfc00315 	stw	ra,12(sp)
 1206928:	df000215 	stw	fp,8(sp)
 120692c:	df000204 	addi	fp,sp,8
 1206930:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 1206934:	e13fff17 	ldw	r4,-4(fp)
 1206938:	d1600c04 	addi	r5,gp,-32720
 120693c:	12078900 	call	1207890 <alt_find_dev>
 1206940:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 1206944:	e0bffe17 	ldw	r2,-8(fp)
 1206948:	10000926 	beq	r2,zero,1206970 <alt_flash_open_dev+0x50>
 120694c:	e0bffe17 	ldw	r2,-8(fp)
 1206950:	10800317 	ldw	r2,12(r2)
 1206954:	10000626 	beq	r2,zero,1206970 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 1206958:	e0bffe17 	ldw	r2,-8(fp)
 120695c:	10800317 	ldw	r2,12(r2)
 1206960:	e13ffe17 	ldw	r4,-8(fp)
 1206964:	e17fff17 	ldw	r5,-4(fp)
 1206968:	103ee83a 	callr	r2
 120696c:	00000106 	br	1206974 <alt_flash_open_dev+0x54>
  }

  return dev;
 1206970:	e0bffe17 	ldw	r2,-8(fp)
}
 1206974:	e037883a 	mov	sp,fp
 1206978:	dfc00117 	ldw	ra,4(sp)
 120697c:	df000017 	ldw	fp,0(sp)
 1206980:	dec00204 	addi	sp,sp,8
 1206984:	f800283a 	ret

01206988 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 1206988:	defffd04 	addi	sp,sp,-12
 120698c:	dfc00215 	stw	ra,8(sp)
 1206990:	df000115 	stw	fp,4(sp)
 1206994:	df000104 	addi	fp,sp,4
 1206998:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 120699c:	e0bfff17 	ldw	r2,-4(fp)
 12069a0:	10000726 	beq	r2,zero,12069c0 <alt_flash_close_dev+0x38>
 12069a4:	e0bfff17 	ldw	r2,-4(fp)
 12069a8:	10800417 	ldw	r2,16(r2)
 12069ac:	10000426 	beq	r2,zero,12069c0 <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
 12069b0:	e0bfff17 	ldw	r2,-4(fp)
 12069b4:	10800417 	ldw	r2,16(r2)
 12069b8:	e13fff17 	ldw	r4,-4(fp)
 12069bc:	103ee83a 	callr	r2
  }
  return;
 12069c0:	0001883a 	nop
}
 12069c4:	e037883a 	mov	sp,fp
 12069c8:	dfc00117 	ldw	ra,4(sp)
 12069cc:	df000017 	ldw	fp,0(sp)
 12069d0:	dec00204 	addi	sp,sp,8
 12069d4:	f800283a 	ret

012069d8 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 12069d8:	defffe04 	addi	sp,sp,-8
 12069dc:	df000115 	stw	fp,4(sp)
 12069e0:	df000104 	addi	fp,sp,4
 12069e4:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 12069e8:	e0bfff17 	ldw	r2,-4(fp)
 12069ec:	10bffe84 	addi	r2,r2,-6
 12069f0:	10c00428 	cmpgeui	r3,r2,16
 12069f4:	18001a1e 	bne	r3,zero,1206a60 <alt_exception_cause_generated_bad_addr+0x88>
 12069f8:	100690ba 	slli	r3,r2,2
 12069fc:	00804834 	movhi	r2,288
 1206a00:	109a8404 	addi	r2,r2,27152
 1206a04:	1885883a 	add	r2,r3,r2
 1206a08:	10800017 	ldw	r2,0(r2)
 1206a0c:	1000683a 	jmp	r2
 1206a10:	01206a50 	cmplti	r4,zero,-32343
 1206a14:	01206a50 	cmplti	r4,zero,-32343
 1206a18:	01206a60 	cmpeqi	r4,zero,-32343
 1206a1c:	01206a60 	cmpeqi	r4,zero,-32343
 1206a20:	01206a60 	cmpeqi	r4,zero,-32343
 1206a24:	01206a50 	cmplti	r4,zero,-32343
 1206a28:	01206a58 	cmpnei	r4,zero,-32343
 1206a2c:	01206a60 	cmpeqi	r4,zero,-32343
 1206a30:	01206a50 	cmplti	r4,zero,-32343
 1206a34:	01206a50 	cmplti	r4,zero,-32343
 1206a38:	01206a60 	cmpeqi	r4,zero,-32343
 1206a3c:	01206a50 	cmplti	r4,zero,-32343
 1206a40:	01206a58 	cmpnei	r4,zero,-32343
 1206a44:	01206a60 	cmpeqi	r4,zero,-32343
 1206a48:	01206a60 	cmpeqi	r4,zero,-32343
 1206a4c:	01206a50 	cmplti	r4,zero,-32343
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 1206a50:	00800044 	movi	r2,1
 1206a54:	00000306 	br	1206a64 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 1206a58:	0005883a 	mov	r2,zero
 1206a5c:	00000106 	br	1206a64 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 1206a60:	0005883a 	mov	r2,zero
  }
}
 1206a64:	e037883a 	mov	sp,fp
 1206a68:	df000017 	ldw	fp,0(sp)
 1206a6c:	dec00104 	addi	sp,sp,4
 1206a70:	f800283a 	ret

01206a74 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 1206a74:	defff904 	addi	sp,sp,-28
 1206a78:	dfc00615 	stw	ra,24(sp)
 1206a7c:	df000515 	stw	fp,20(sp)
 1206a80:	df000504 	addi	fp,sp,20
 1206a84:	e13ffc15 	stw	r4,-16(fp)
 1206a88:	e17ffd15 	stw	r5,-12(fp)
 1206a8c:	e1bffe15 	stw	r6,-8(fp)
 1206a90:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 1206a94:	e13ffd17 	ldw	r4,-12(fp)
 1206a98:	e17ffe17 	ldw	r5,-8(fp)
 1206a9c:	e1bfff17 	ldw	r6,-4(fp)
 1206aa0:	1206cc80 	call	1206cc8 <open>
 1206aa4:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 1206aa8:	e0bffb17 	ldw	r2,-20(fp)
 1206aac:	10001c16 	blt	r2,zero,1206b20 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 1206ab0:	00804874 	movhi	r2,289
 1206ab4:	10a21f04 	addi	r2,r2,-30596
 1206ab8:	e0fffb17 	ldw	r3,-20(fp)
 1206abc:	18c00324 	muli	r3,r3,12
 1206ac0:	10c5883a 	add	r2,r2,r3
 1206ac4:	10c00017 	ldw	r3,0(r2)
 1206ac8:	e0bffc17 	ldw	r2,-16(fp)
 1206acc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 1206ad0:	00804874 	movhi	r2,289
 1206ad4:	10a21f04 	addi	r2,r2,-30596
 1206ad8:	e0fffb17 	ldw	r3,-20(fp)
 1206adc:	18c00324 	muli	r3,r3,12
 1206ae0:	10c5883a 	add	r2,r2,r3
 1206ae4:	10800104 	addi	r2,r2,4
 1206ae8:	10c00017 	ldw	r3,0(r2)
 1206aec:	e0bffc17 	ldw	r2,-16(fp)
 1206af0:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 1206af4:	00804874 	movhi	r2,289
 1206af8:	10a21f04 	addi	r2,r2,-30596
 1206afc:	e0fffb17 	ldw	r3,-20(fp)
 1206b00:	18c00324 	muli	r3,r3,12
 1206b04:	10c5883a 	add	r2,r2,r3
 1206b08:	10800204 	addi	r2,r2,8
 1206b0c:	10c00017 	ldw	r3,0(r2)
 1206b10:	e0bffc17 	ldw	r2,-16(fp)
 1206b14:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 1206b18:	e13ffb17 	ldw	r4,-20(fp)
 1206b1c:	12038e00 	call	12038e0 <alt_release_fd>
  }
} 
 1206b20:	e037883a 	mov	sp,fp
 1206b24:	dfc00117 	ldw	ra,4(sp)
 1206b28:	df000017 	ldw	fp,0(sp)
 1206b2c:	dec00204 	addi	sp,sp,8
 1206b30:	f800283a 	ret

01206b34 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 1206b34:	defffb04 	addi	sp,sp,-20
 1206b38:	dfc00415 	stw	ra,16(sp)
 1206b3c:	df000315 	stw	fp,12(sp)
 1206b40:	df000304 	addi	fp,sp,12
 1206b44:	e13ffd15 	stw	r4,-12(fp)
 1206b48:	e17ffe15 	stw	r5,-8(fp)
 1206b4c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 1206b50:	01004874 	movhi	r4,289
 1206b54:	21222204 	addi	r4,r4,-30584
 1206b58:	e17ffd17 	ldw	r5,-12(fp)
 1206b5c:	01800044 	movi	r6,1
 1206b60:	01c07fc4 	movi	r7,511
 1206b64:	1206a740 	call	1206a74 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 1206b68:	01004874 	movhi	r4,289
 1206b6c:	21221f04 	addi	r4,r4,-30596
 1206b70:	e17ffe17 	ldw	r5,-8(fp)
 1206b74:	000d883a 	mov	r6,zero
 1206b78:	01c07fc4 	movi	r7,511
 1206b7c:	1206a740 	call	1206a74 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 1206b80:	01004874 	movhi	r4,289
 1206b84:	21222504 	addi	r4,r4,-30572
 1206b88:	e17fff17 	ldw	r5,-4(fp)
 1206b8c:	01800044 	movi	r6,1
 1206b90:	01c07fc4 	movi	r7,511
 1206b94:	1206a740 	call	1206a74 <alt_open_fd>
}  
 1206b98:	e037883a 	mov	sp,fp
 1206b9c:	dfc00117 	ldw	ra,4(sp)
 1206ba0:	df000017 	ldw	fp,0(sp)
 1206ba4:	dec00204 	addi	sp,sp,8
 1206ba8:	f800283a 	ret

01206bac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1206bac:	defffe04 	addi	sp,sp,-8
 1206bb0:	dfc00115 	stw	ra,4(sp)
 1206bb4:	df000015 	stw	fp,0(sp)
 1206bb8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1206bbc:	00804874 	movhi	r2,289
 1206bc0:	10a6d704 	addi	r2,r2,-25764
 1206bc4:	10800017 	ldw	r2,0(r2)
 1206bc8:	10000526 	beq	r2,zero,1206be0 <alt_get_errno+0x34>
 1206bcc:	00804874 	movhi	r2,289
 1206bd0:	10a6d704 	addi	r2,r2,-25764
 1206bd4:	10800017 	ldw	r2,0(r2)
 1206bd8:	103ee83a 	callr	r2
 1206bdc:	00000206 	br	1206be8 <alt_get_errno+0x3c>
 1206be0:	00804874 	movhi	r2,289
 1206be4:	10a6e204 	addi	r2,r2,-25720
}
 1206be8:	e037883a 	mov	sp,fp
 1206bec:	dfc00117 	ldw	ra,4(sp)
 1206bf0:	df000017 	ldw	fp,0(sp)
 1206bf4:	dec00204 	addi	sp,sp,8
 1206bf8:	f800283a 	ret

01206bfc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 1206bfc:	defffd04 	addi	sp,sp,-12
 1206c00:	df000215 	stw	fp,8(sp)
 1206c04:	df000204 	addi	fp,sp,8
 1206c08:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 1206c0c:	e0bfff17 	ldw	r2,-4(fp)
 1206c10:	10800217 	ldw	r2,8(r2)
 1206c14:	10d00034 	orhi	r3,r2,16384
 1206c18:	e0bfff17 	ldw	r2,-4(fp)
 1206c1c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1206c20:	e03ffe15 	stw	zero,-8(fp)
 1206c24:	00001d06 	br	1206c9c <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1206c28:	00804874 	movhi	r2,289
 1206c2c:	10a21f04 	addi	r2,r2,-30596
 1206c30:	e0fffe17 	ldw	r3,-8(fp)
 1206c34:	18c00324 	muli	r3,r3,12
 1206c38:	10c5883a 	add	r2,r2,r3
 1206c3c:	10c00017 	ldw	r3,0(r2)
 1206c40:	e0bfff17 	ldw	r2,-4(fp)
 1206c44:	10800017 	ldw	r2,0(r2)
 1206c48:	1880111e 	bne	r3,r2,1206c90 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1206c4c:	00804874 	movhi	r2,289
 1206c50:	10a21f04 	addi	r2,r2,-30596
 1206c54:	e0fffe17 	ldw	r3,-8(fp)
 1206c58:	18c00324 	muli	r3,r3,12
 1206c5c:	10c5883a 	add	r2,r2,r3
 1206c60:	10800204 	addi	r2,r2,8
 1206c64:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1206c68:	1000090e 	bge	r2,zero,1206c90 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 1206c6c:	e0bffe17 	ldw	r2,-8(fp)
 1206c70:	10c00324 	muli	r3,r2,12
 1206c74:	00804874 	movhi	r2,289
 1206c78:	10a21f04 	addi	r2,r2,-30596
 1206c7c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1206c80:	e0bfff17 	ldw	r2,-4(fp)
 1206c84:	18800226 	beq	r3,r2,1206c90 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 1206c88:	00bffcc4 	movi	r2,-13
 1206c8c:	00000a06 	br	1206cb8 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1206c90:	e0bffe17 	ldw	r2,-8(fp)
 1206c94:	10800044 	addi	r2,r2,1
 1206c98:	e0bffe15 	stw	r2,-8(fp)
 1206c9c:	00804874 	movhi	r2,289
 1206ca0:	10a6d604 	addi	r2,r2,-25768
 1206ca4:	10800017 	ldw	r2,0(r2)
 1206ca8:	1007883a 	mov	r3,r2
 1206cac:	e0bffe17 	ldw	r2,-8(fp)
 1206cb0:	18bfdd2e 	bgeu	r3,r2,1206c28 <__alt_mem_instruction_tcm+0xff206c28>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 1206cb4:	0005883a 	mov	r2,zero
}
 1206cb8:	e037883a 	mov	sp,fp
 1206cbc:	df000017 	ldw	fp,0(sp)
 1206cc0:	dec00104 	addi	sp,sp,4
 1206cc4:	f800283a 	ret

01206cc8 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 1206cc8:	defff604 	addi	sp,sp,-40
 1206ccc:	dfc00915 	stw	ra,36(sp)
 1206cd0:	df000815 	stw	fp,32(sp)
 1206cd4:	df000804 	addi	fp,sp,32
 1206cd8:	e13ffd15 	stw	r4,-12(fp)
 1206cdc:	e17ffe15 	stw	r5,-8(fp)
 1206ce0:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 1206ce4:	00bfffc4 	movi	r2,-1
 1206ce8:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 1206cec:	00bffb44 	movi	r2,-19
 1206cf0:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 1206cf4:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 1206cf8:	e13ffd17 	ldw	r4,-12(fp)
 1206cfc:	01404874 	movhi	r5,289
 1206d00:	2966d404 	addi	r5,r5,-25776
 1206d04:	12078900 	call	1207890 <alt_find_dev>
 1206d08:	e0bff815 	stw	r2,-32(fp)
 1206d0c:	e0bff817 	ldw	r2,-32(fp)
 1206d10:	1000051e 	bne	r2,zero,1206d28 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 1206d14:	e13ffd17 	ldw	r4,-12(fp)
 1206d18:	12079200 	call	1207920 <alt_find_file>
 1206d1c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 1206d20:	00800044 	movi	r2,1
 1206d24:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 1206d28:	e0bff817 	ldw	r2,-32(fp)
 1206d2c:	10002926 	beq	r2,zero,1206dd4 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
 1206d30:	e13ff817 	ldw	r4,-32(fp)
 1206d34:	1207a340 	call	1207a34 <alt_get_fd>
 1206d38:	e0bff915 	stw	r2,-28(fp)
 1206d3c:	e0bff917 	ldw	r2,-28(fp)
 1206d40:	1000030e 	bge	r2,zero,1206d50 <open+0x88>
    {
      status = index;
 1206d44:	e0bff917 	ldw	r2,-28(fp)
 1206d48:	e0bffa15 	stw	r2,-24(fp)
 1206d4c:	00002306 	br	1206ddc <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
 1206d50:	e0bff917 	ldw	r2,-28(fp)
 1206d54:	10c00324 	muli	r3,r2,12
 1206d58:	00804874 	movhi	r2,289
 1206d5c:	10a21f04 	addi	r2,r2,-30596
 1206d60:	1885883a 	add	r2,r3,r2
 1206d64:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 1206d68:	e0fffe17 	ldw	r3,-8(fp)
 1206d6c:	00900034 	movhi	r2,16384
 1206d70:	10bfffc4 	addi	r2,r2,-1
 1206d74:	1886703a 	and	r3,r3,r2
 1206d78:	e0bffc17 	ldw	r2,-16(fp)
 1206d7c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 1206d80:	e0bffb17 	ldw	r2,-20(fp)
 1206d84:	1000051e 	bne	r2,zero,1206d9c <open+0xd4>
 1206d88:	e13ffc17 	ldw	r4,-16(fp)
 1206d8c:	1206bfc0 	call	1206bfc <alt_file_locked>
 1206d90:	e0bffa15 	stw	r2,-24(fp)
 1206d94:	e0bffa17 	ldw	r2,-24(fp)
 1206d98:	10001016 	blt	r2,zero,1206ddc <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 1206d9c:	e0bff817 	ldw	r2,-32(fp)
 1206da0:	10800317 	ldw	r2,12(r2)
 1206da4:	10000826 	beq	r2,zero,1206dc8 <open+0x100>
 1206da8:	e0bff817 	ldw	r2,-32(fp)
 1206dac:	10800317 	ldw	r2,12(r2)
 1206db0:	e13ffc17 	ldw	r4,-16(fp)
 1206db4:	e17ffd17 	ldw	r5,-12(fp)
 1206db8:	e1bffe17 	ldw	r6,-8(fp)
 1206dbc:	e1ffff17 	ldw	r7,-4(fp)
 1206dc0:	103ee83a 	callr	r2
 1206dc4:	00000106 	br	1206dcc <open+0x104>
 1206dc8:	0005883a 	mov	r2,zero
 1206dcc:	e0bffa15 	stw	r2,-24(fp)
 1206dd0:	00000206 	br	1206ddc <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
 1206dd4:	00bffb44 	movi	r2,-19
 1206dd8:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 1206ddc:	e0bffa17 	ldw	r2,-24(fp)
 1206de0:	1000090e 	bge	r2,zero,1206e08 <open+0x140>
  {
    alt_release_fd (index);  
 1206de4:	e13ff917 	ldw	r4,-28(fp)
 1206de8:	12038e00 	call	12038e0 <alt_release_fd>
    ALT_ERRNO = -status;
 1206dec:	1206bac0 	call	1206bac <alt_get_errno>
 1206df0:	1007883a 	mov	r3,r2
 1206df4:	e0bffa17 	ldw	r2,-24(fp)
 1206df8:	0085c83a 	sub	r2,zero,r2
 1206dfc:	18800015 	stw	r2,0(r3)
    return -1;
 1206e00:	00bfffc4 	movi	r2,-1
 1206e04:	00000106 	br	1206e0c <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
 1206e08:	e0bff917 	ldw	r2,-28(fp)
}
 1206e0c:	e037883a 	mov	sp,fp
 1206e10:	dfc00117 	ldw	ra,4(sp)
 1206e14:	df000017 	ldw	fp,0(sp)
 1206e18:	dec00204 	addi	sp,sp,8
 1206e1c:	f800283a 	ret

01206e20 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 1206e20:	defffa04 	addi	sp,sp,-24
 1206e24:	df000515 	stw	fp,20(sp)
 1206e28:	df000504 	addi	fp,sp,20
 1206e2c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1206e30:	0005303a 	rdctl	r2,status
 1206e34:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1206e38:	e0fffc17 	ldw	r3,-16(fp)
 1206e3c:	00bfff84 	movi	r2,-2
 1206e40:	1884703a 	and	r2,r3,r2
 1206e44:	1001703a 	wrctl	status,r2
  
  return context;
 1206e48:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 1206e4c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 1206e50:	e0bfff17 	ldw	r2,-4(fp)
 1206e54:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 1206e58:	e0bffd17 	ldw	r2,-12(fp)
 1206e5c:	10800017 	ldw	r2,0(r2)
 1206e60:	e0fffd17 	ldw	r3,-12(fp)
 1206e64:	18c00117 	ldw	r3,4(r3)
 1206e68:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 1206e6c:	e0bffd17 	ldw	r2,-12(fp)
 1206e70:	10800117 	ldw	r2,4(r2)
 1206e74:	e0fffd17 	ldw	r3,-12(fp)
 1206e78:	18c00017 	ldw	r3,0(r3)
 1206e7c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 1206e80:	e0bffd17 	ldw	r2,-12(fp)
 1206e84:	e0fffd17 	ldw	r3,-12(fp)
 1206e88:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 1206e8c:	e0bffd17 	ldw	r2,-12(fp)
 1206e90:	e0fffd17 	ldw	r3,-12(fp)
 1206e94:	10c00015 	stw	r3,0(r2)
 1206e98:	e0bffb17 	ldw	r2,-20(fp)
 1206e9c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1206ea0:	e0bffe17 	ldw	r2,-8(fp)
 1206ea4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 1206ea8:	e037883a 	mov	sp,fp
 1206eac:	df000017 	ldw	fp,0(sp)
 1206eb0:	dec00104 	addi	sp,sp,4
 1206eb4:	f800283a 	ret

01206eb8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 1206eb8:	defffb04 	addi	sp,sp,-20
 1206ebc:	dfc00415 	stw	ra,16(sp)
 1206ec0:	df000315 	stw	fp,12(sp)
 1206ec4:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 1206ec8:	d0a00e17 	ldw	r2,-32712(gp)
 1206ecc:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 1206ed0:	d0a01b17 	ldw	r2,-32660(gp)
 1206ed4:	10800044 	addi	r2,r2,1
 1206ed8:	d0a01b15 	stw	r2,-32660(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1206edc:	00002e06 	br	1206f98 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 1206ee0:	e0bffd17 	ldw	r2,-12(fp)
 1206ee4:	10800017 	ldw	r2,0(r2)
 1206ee8:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 1206eec:	e0bffd17 	ldw	r2,-12(fp)
 1206ef0:	10800403 	ldbu	r2,16(r2)
 1206ef4:	10803fcc 	andi	r2,r2,255
 1206ef8:	10000426 	beq	r2,zero,1206f0c <alt_tick+0x54>
 1206efc:	d0a01b17 	ldw	r2,-32660(gp)
 1206f00:	1000021e 	bne	r2,zero,1206f0c <alt_tick+0x54>
    {
      alarm->rollover = 0;
 1206f04:	e0bffd17 	ldw	r2,-12(fp)
 1206f08:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 1206f0c:	e0bffd17 	ldw	r2,-12(fp)
 1206f10:	10800217 	ldw	r2,8(r2)
 1206f14:	d0e01b17 	ldw	r3,-32660(gp)
 1206f18:	18801d36 	bltu	r3,r2,1206f90 <alt_tick+0xd8>
 1206f1c:	e0bffd17 	ldw	r2,-12(fp)
 1206f20:	10800403 	ldbu	r2,16(r2)
 1206f24:	10803fcc 	andi	r2,r2,255
 1206f28:	1000191e 	bne	r2,zero,1206f90 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 1206f2c:	e0bffd17 	ldw	r2,-12(fp)
 1206f30:	10800317 	ldw	r2,12(r2)
 1206f34:	e0fffd17 	ldw	r3,-12(fp)
 1206f38:	18c00517 	ldw	r3,20(r3)
 1206f3c:	1809883a 	mov	r4,r3
 1206f40:	103ee83a 	callr	r2
 1206f44:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 1206f48:	e0bfff17 	ldw	r2,-4(fp)
 1206f4c:	1000031e 	bne	r2,zero,1206f5c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 1206f50:	e13ffd17 	ldw	r4,-12(fp)
 1206f54:	1206e200 	call	1206e20 <alt_alarm_stop>
 1206f58:	00000d06 	br	1206f90 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 1206f5c:	e0bffd17 	ldw	r2,-12(fp)
 1206f60:	10c00217 	ldw	r3,8(r2)
 1206f64:	e0bfff17 	ldw	r2,-4(fp)
 1206f68:	1887883a 	add	r3,r3,r2
 1206f6c:	e0bffd17 	ldw	r2,-12(fp)
 1206f70:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 1206f74:	e0bffd17 	ldw	r2,-12(fp)
 1206f78:	10c00217 	ldw	r3,8(r2)
 1206f7c:	d0a01b17 	ldw	r2,-32660(gp)
 1206f80:	1880032e 	bgeu	r3,r2,1206f90 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 1206f84:	e0bffd17 	ldw	r2,-12(fp)
 1206f88:	00c00044 	movi	r3,1
 1206f8c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 1206f90:	e0bffe17 	ldw	r2,-8(fp)
 1206f94:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1206f98:	e0fffd17 	ldw	r3,-12(fp)
 1206f9c:	d0a00e04 	addi	r2,gp,-32712
 1206fa0:	18bfcf1e 	bne	r3,r2,1206ee0 <__alt_mem_instruction_tcm+0xff206ee0>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 1206fa4:	0001883a 	nop
}
 1206fa8:	e037883a 	mov	sp,fp
 1206fac:	dfc00117 	ldw	ra,4(sp)
 1206fb0:	df000017 	ldw	fp,0(sp)
 1206fb4:	dec00204 	addi	sp,sp,8
 1206fb8:	f800283a 	ret

01206fbc <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 1206fbc:	deffff04 	addi	sp,sp,-4
 1206fc0:	df000015 	stw	fp,0(sp)
 1206fc4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 1206fc8:	000170fa 	wrctl	ienable,zero
}
 1206fcc:	e037883a 	mov	sp,fp
 1206fd0:	df000017 	ldw	fp,0(sp)
 1206fd4:	dec00104 	addi	sp,sp,4
 1206fd8:	f800283a 	ret

01206fdc <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 1206fdc:	defff704 	addi	sp,sp,-36
 1206fe0:	dfc00815 	stw	ra,32(sp)
 1206fe4:	df000715 	stw	fp,28(sp)
 1206fe8:	df000704 	addi	fp,sp,28
 1206fec:	e13ffc15 	stw	r4,-16(fp)
 1206ff0:	e17ffd15 	stw	r5,-12(fp)
 1206ff4:	e1bffe15 	stw	r6,-8(fp)
 1206ff8:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 1206ffc:	e03ffa15 	stw	zero,-24(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 1207000:	e0bffc17 	ldw	r2,-16(fp)
 1207004:	e0bffb15 	stw	r2,-20(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 1207008:	00804834 	movhi	r2,288
 120700c:	109cdc04 	addi	r2,r2,29552
 1207010:	d8800015 	stw	r2,0(sp)
 1207014:	e13ffb17 	ldw	r4,-20(fp)
 1207018:	e17ffe17 	ldw	r5,-8(fp)
 120701c:	e1bfff17 	ldw	r6,-4(fp)
 1207020:	e1c00217 	ldw	r7,8(fp)
 1207024:	12041f80 	call	12041f8 <alt_flash_program_block>
 1207028:	e0bffa15 	stw	r2,-24(fp)
                                    alt_write_word_amd);
  return ret_code;
 120702c:	e0bffa17 	ldw	r2,-24(fp)
}
 1207030:	e037883a 	mov	sp,fp
 1207034:	dfc00117 	ldw	ra,4(sp)
 1207038:	df000017 	ldw	fp,0(sp)
 120703c:	dec00204 	addi	sp,sp,8
 1207040:	f800283a 	ret

01207044 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 1207044:	defff804 	addi	sp,sp,-32
 1207048:	dfc00715 	stw	ra,28(sp)
 120704c:	df000615 	stw	fp,24(sp)
 1207050:	df000604 	addi	fp,sp,24
 1207054:	e13ffe15 	stw	r4,-8(fp)
 1207058:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 120705c:	e03ffa15 	stw	zero,-24(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 1207060:	e0bffe17 	ldw	r2,-8(fp)
 1207064:	e0bffc15 	stw	r2,-16(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 1207068:	e0bffc17 	ldw	r2,-16(fp)
 120706c:	10803417 	ldw	r2,208(r2)
 1207070:	e0fffc17 	ldw	r3,-16(fp)
 1207074:	18c00a17 	ldw	r3,40(r3)
 1207078:	1809883a 	mov	r4,r3
 120707c:	01415544 	movi	r5,1365
 1207080:	01802a84 	movi	r6,170
 1207084:	103ee83a 	callr	r2
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 1207088:	e0bffc17 	ldw	r2,-16(fp)
 120708c:	10803417 	ldw	r2,208(r2)
 1207090:	e0fffc17 	ldw	r3,-16(fp)
 1207094:	18c00a17 	ldw	r3,40(r3)
 1207098:	1809883a 	mov	r4,r3
 120709c:	0140aa84 	movi	r5,682
 12070a0:	01801544 	movi	r6,85
 12070a4:	103ee83a 	callr	r2
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 12070a8:	e0bffc17 	ldw	r2,-16(fp)
 12070ac:	10803417 	ldw	r2,208(r2)
 12070b0:	e0fffc17 	ldw	r3,-16(fp)
 12070b4:	18c00a17 	ldw	r3,40(r3)
 12070b8:	1809883a 	mov	r4,r3
 12070bc:	01415544 	movi	r5,1365
 12070c0:	01802004 	movi	r6,128
 12070c4:	103ee83a 	callr	r2
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 12070c8:	e0bffc17 	ldw	r2,-16(fp)
 12070cc:	10803417 	ldw	r2,208(r2)
 12070d0:	e0fffc17 	ldw	r3,-16(fp)
 12070d4:	18c00a17 	ldw	r3,40(r3)
 12070d8:	1809883a 	mov	r4,r3
 12070dc:	01415544 	movi	r5,1365
 12070e0:	01802a84 	movi	r6,170
 12070e4:	103ee83a 	callr	r2
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 12070e8:	e0bffc17 	ldw	r2,-16(fp)
 12070ec:	10803417 	ldw	r2,208(r2)
 12070f0:	e0fffc17 	ldw	r3,-16(fp)
 12070f4:	18c00a17 	ldw	r3,40(r3)
 12070f8:	1809883a 	mov	r4,r3
 12070fc:	0140aa84 	movi	r5,682
 1207100:	01801544 	movi	r6,85
 1207104:	103ee83a 	callr	r2

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 1207108:	e0bffc17 	ldw	r2,-16(fp)
 120710c:	10803617 	ldw	r2,216(r2)
 1207110:	e0fffc17 	ldw	r3,-16(fp)
 1207114:	19000a17 	ldw	r4,40(r3)
 1207118:	e0ffff17 	ldw	r3,-4(fp)
 120711c:	20c7883a 	add	r3,r4,r3
 1207120:	1809883a 	mov	r4,r3
 1207124:	01400c04 	movi	r5,48
 1207128:	103ee83a 	callr	r2

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 120712c:	0109c404 	movi	r4,10000
 1207130:	12039f00 	call	12039f0 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 1207134:	00800c84 	movi	r2,50
 1207138:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 120713c:	e0bffc17 	ldw	r2,-16(fp)
 1207140:	10c00a17 	ldw	r3,40(r2)
 1207144:	e0bfff17 	ldw	r2,-4(fp)
 1207148:	1885883a 	add	r2,r3,r2
 120714c:	10800023 	ldbuio	r2,0(r2)
 1207150:	10803fcc 	andi	r2,r2,255
 1207154:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 1207158:	0100fa04 	movi	r4,1000
 120715c:	12039f00 	call	12039f0 <usleep>
    timeout--;
 1207160:	e0bffb17 	ldw	r2,-20(fp)
 1207164:	10bfffc4 	addi	r2,r2,-1
 1207168:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 120716c:	e0bffd03 	ldbu	r2,-12(fp)
 1207170:	10803fcc 	andi	r2,r2,255
 1207174:	1080020c 	andi	r2,r2,8
 1207178:	1000021e 	bne	r2,zero,1207184 <alt_erase_block_amd+0x140>
 120717c:	e0bffb17 	ldw	r2,-20(fp)
 1207180:	00bfee16 	blt	zero,r2,120713c <__alt_mem_instruction_tcm+0xff20713c>


  timeout = flash->erase_timeout;
 1207184:	e0bffc17 	ldw	r2,-16(fp)
 1207188:	10803217 	ldw	r2,200(r2)
 120718c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 1207190:	00001506 	br	12071e8 <alt_erase_block_amd+0x1a4>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 1207194:	e0bffc17 	ldw	r2,-16(fp)
 1207198:	10c00a17 	ldw	r3,40(r2)
 120719c:	e0bfff17 	ldw	r2,-4(fp)
 12071a0:	1885883a 	add	r2,r3,r2
 12071a4:	10800023 	ldbuio	r2,0(r2)
 12071a8:	10803fcc 	andi	r2,r2,255
 12071ac:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 12071b0:	e0bffd03 	ldbu	r2,-12(fp)
 12071b4:	10803fcc 	andi	r2,r2,255
 12071b8:	1080201c 	xori	r2,r2,128
 12071bc:	10bfe004 	addi	r2,r2,-128
 12071c0:	10000b16 	blt	r2,zero,12071f0 <alt_erase_block_amd+0x1ac>
 12071c4:	e0bffd03 	ldbu	r2,-12(fp)
 12071c8:	10803fcc 	andi	r2,r2,255
 12071cc:	1080080c 	andi	r2,r2,32
 12071d0:	1000071e 	bne	r2,zero,12071f0 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 12071d4:	0100fa04 	movi	r4,1000
 12071d8:	12039f00 	call	12039f0 <usleep>
    timeout -= 1000;
 12071dc:	e0bffb17 	ldw	r2,-20(fp)
 12071e0:	10bf0604 	addi	r2,r2,-1000
 12071e4:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 12071e8:	e0bffb17 	ldw	r2,-20(fp)
 12071ec:	00bfe916 	blt	zero,r2,1207194 <__alt_mem_instruction_tcm+0xff207194>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 12071f0:	e0bffb17 	ldw	r2,-20(fp)
 12071f4:	00800316 	blt	zero,r2,1207204 <alt_erase_block_amd+0x1c0>
  {
    ret_code = -ETIMEDOUT;
 12071f8:	00bfe304 	movi	r2,-116
 12071fc:	e0bffa15 	stw	r2,-24(fp)
 1207200:	00000e06 	br	120723c <alt_erase_block_amd+0x1f8>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 1207204:	e0bffc17 	ldw	r2,-16(fp)
 1207208:	10c00a17 	ldw	r3,40(r2)
 120720c:	e0bfff17 	ldw	r2,-4(fp)
 1207210:	1885883a 	add	r2,r3,r2
 1207214:	10800023 	ldbuio	r2,0(r2)
 1207218:	10803fcc 	andi	r2,r2,255
 120721c:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 1207220:	e0bffd03 	ldbu	r2,-12(fp)
 1207224:	10803fcc 	andi	r2,r2,255
 1207228:	1080201c 	xori	r2,r2,128
 120722c:	10bfe004 	addi	r2,r2,-128
 1207230:	10000216 	blt	r2,zero,120723c <alt_erase_block_amd+0x1f8>
    {
      ret_code = -EIO;
 1207234:	00bffec4 	movi	r2,-5
 1207238:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  
  return ret_code;
 120723c:	e0bffa17 	ldw	r2,-24(fp)
}
 1207240:	e037883a 	mov	sp,fp
 1207244:	dfc00117 	ldw	ra,4(sp)
 1207248:	df000017 	ldw	fp,0(sp)
 120724c:	dec00204 	addi	sp,sp,8
 1207250:	f800283a 	ret

01207254 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 1207254:	defff804 	addi	sp,sp,-32
 1207258:	dfc00715 	stw	ra,28(sp)
 120725c:	df000615 	stw	fp,24(sp)
 1207260:	df000604 	addi	fp,sp,24
 1207264:	e13ffd15 	stw	r4,-12(fp)
 1207268:	e17ffe15 	stw	r5,-8(fp)
 120726c:	3005883a 	mov	r2,r6
 1207270:	e0bfff05 	stb	r2,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 1207274:	e0bffd17 	ldw	r2,-12(fp)
 1207278:	10803117 	ldw	r2,196(r2)
 120727c:	10801924 	muli	r2,r2,100
 1207280:	e0bffa15 	stw	r2,-24(fp)
  int ret_code = 0;
 1207284:	e03ffb15 	stw	zero,-20(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 1207288:	e0bffd17 	ldw	r2,-12(fp)
 120728c:	10c00a17 	ldw	r3,40(r2)
 1207290:	e0bffe17 	ldw	r2,-8(fp)
 1207294:	1885883a 	add	r2,r3,r2
 1207298:	10800023 	ldbuio	r2,0(r2)
 120729c:	10803fcc 	andi	r2,r2,255
 12072a0:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 12072a4:	00001606 	br	1207300 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 12072a8:	e0bffc03 	ldbu	r2,-16(fp)
 12072ac:	10c03fcc 	andi	r3,r2,255
 12072b0:	e0bfff03 	ldbu	r2,-4(fp)
 12072b4:	1884f03a 	xor	r2,r3,r2
 12072b8:	1080200c 	andi	r2,r2,128
 12072bc:	10001226 	beq	r2,zero,1207308 <alt_wait_for_command_to_complete_amd+0xb4>
        (value & 0x20))
 12072c0:	e0bffc03 	ldbu	r2,-16(fp)
 12072c4:	10803fcc 	andi	r2,r2,255
 12072c8:	1080080c 	andi	r2,r2,32
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 12072cc:	10000e1e 	bne	r2,zero,1207308 <alt_wait_for_command_to_complete_amd+0xb4>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 12072d0:	01000044 	movi	r4,1
 12072d4:	12039f00 	call	12039f0 <usleep>
    timeout--;
 12072d8:	e0bffa17 	ldw	r2,-24(fp)
 12072dc:	10bfffc4 	addi	r2,r2,-1
 12072e0:	e0bffa15 	stw	r2,-24(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 12072e4:	e0bffd17 	ldw	r2,-12(fp)
 12072e8:	10c00a17 	ldw	r3,40(r2)
 12072ec:	e0bffe17 	ldw	r2,-8(fp)
 12072f0:	1885883a 	add	r2,r3,r2
 12072f4:	10800023 	ldbuio	r2,0(r2)
 12072f8:	10803fcc 	andi	r2,r2,255
 12072fc:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 1207300:	e0bffa17 	ldw	r2,-24(fp)
 1207304:	00bfe816 	blt	zero,r2,12072a8 <__alt_mem_instruction_tcm+0xff2072a8>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 1207308:	e0bffa17 	ldw	r2,-24(fp)
 120730c:	1000031e 	bne	r2,zero,120731c <alt_wait_for_command_to_complete_amd+0xc8>
  {
    ret_code = -ETIMEDOUT;
 1207310:	00bfe304 	movi	r2,-116
 1207314:	e0bffb15 	stw	r2,-20(fp)
 1207318:	00000f06 	br	1207358 <alt_wait_for_command_to_complete_amd+0x104>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 120731c:	e0bffd17 	ldw	r2,-12(fp)
 1207320:	10c00a17 	ldw	r3,40(r2)
 1207324:	e0bffe17 	ldw	r2,-8(fp)
 1207328:	1885883a 	add	r2,r3,r2
 120732c:	10800023 	ldbuio	r2,0(r2)
 1207330:	10803fcc 	andi	r2,r2,255
 1207334:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 1207338:	e0bffc03 	ldbu	r2,-16(fp)
 120733c:	10c03fcc 	andi	r3,r2,255
 1207340:	e0bfff03 	ldbu	r2,-4(fp)
 1207344:	1884f03a 	xor	r2,r3,r2
 1207348:	1080200c 	andi	r2,r2,128
 120734c:	10000226 	beq	r2,zero,1207358 <alt_wait_for_command_to_complete_amd+0x104>
    {
      ret_code = -EIO;
 1207350:	00bffec4 	movi	r2,-5
 1207354:	e0bffb15 	stw	r2,-20(fp)
    }
  }    
  return ret_code;
 1207358:	e0bffb17 	ldw	r2,-20(fp)
}
 120735c:	e037883a 	mov	sp,fp
 1207360:	dfc00117 	ldw	ra,4(sp)
 1207364:	df000017 	ldw	fp,0(sp)
 1207368:	dec00204 	addi	sp,sp,8
 120736c:	f800283a 	ret

01207370 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 1207370:	defff904 	addi	sp,sp,-28
 1207374:	dfc00615 	stw	ra,24(sp)
 1207378:	df000515 	stw	fp,20(sp)
 120737c:	df000504 	addi	fp,sp,20
 1207380:	e13ffd15 	stw	r4,-12(fp)
 1207384:	e17ffe15 	stw	r5,-8(fp)
 1207388:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 120738c:	e03ffb15 	stw	zero,-20(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 1207390:	e0bffd17 	ldw	r2,-12(fp)
 1207394:	10803417 	ldw	r2,208(r2)
 1207398:	e0fffd17 	ldw	r3,-12(fp)
 120739c:	18c00a17 	ldw	r3,40(r3)
 12073a0:	1809883a 	mov	r4,r3
 12073a4:	01415544 	movi	r5,1365
 12073a8:	01802a84 	movi	r6,170
 12073ac:	103ee83a 	callr	r2
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 12073b0:	e0bffd17 	ldw	r2,-12(fp)
 12073b4:	10803417 	ldw	r2,208(r2)
 12073b8:	e0fffd17 	ldw	r3,-12(fp)
 12073bc:	18c00a17 	ldw	r3,40(r3)
 12073c0:	1809883a 	mov	r4,r3
 12073c4:	0140aa84 	movi	r5,682
 12073c8:	01801544 	movi	r6,85
 12073cc:	103ee83a 	callr	r2
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 12073d0:	e0bffd17 	ldw	r2,-12(fp)
 12073d4:	10803417 	ldw	r2,208(r2)
 12073d8:	e0fffd17 	ldw	r3,-12(fp)
 12073dc:	18c00a17 	ldw	r3,40(r3)
 12073e0:	1809883a 	mov	r4,r3
 12073e4:	01415544 	movi	r5,1365
 12073e8:	01802804 	movi	r6,160
 12073ec:	103ee83a 	callr	r2
  
  value = *src_addr;
 12073f0:	e0bfff17 	ldw	r2,-4(fp)
 12073f4:	10800003 	ldbu	r2,0(r2)
 12073f8:	e0bffc05 	stb	r2,-16(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 12073fc:	e13ffd17 	ldw	r4,-12(fp)
 1207400:	e17ffe17 	ldw	r5,-8(fp)
 1207404:	e1bfff17 	ldw	r6,-4(fp)
 1207408:	12040a00 	call	12040a0 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 120740c:	e0bffc03 	ldbu	r2,-16(fp)
 1207410:	e13ffd17 	ldw	r4,-12(fp)
 1207414:	e17ffe17 	ldw	r5,-8(fp)
 1207418:	100d883a 	mov	r6,r2
 120741c:	12072540 	call	1207254 <alt_wait_for_command_to_complete_amd>
 1207420:	e0bffb15 	stw	r2,-20(fp)
                                                  offset,
                                                  value);
  return ret_code;
 1207424:	e0bffb17 	ldw	r2,-20(fp)
  
}
 1207428:	e037883a 	mov	sp,fp
 120742c:	dfc00117 	ldw	ra,4(sp)
 1207430:	df000017 	ldw	fp,0(sp)
 1207434:	dec00204 	addi	sp,sp,8
 1207438:	f800283a 	ret

0120743c <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 120743c:	defff704 	addi	sp,sp,-36
 1207440:	dfc00815 	stw	ra,32(sp)
 1207444:	df000715 	stw	fp,28(sp)
 1207448:	df000704 	addi	fp,sp,28
 120744c:	e13ffc15 	stw	r4,-16(fp)
 1207450:	e17ffd15 	stw	r5,-12(fp)
 1207454:	e1bffe15 	stw	r6,-8(fp)
 1207458:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 120745c:	e03ffa15 	stw	zero,-24(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 1207460:	e0bffc17 	ldw	r2,-16(fp)
 1207464:	e0bffb15 	stw	r2,-20(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 1207468:	e13ffb17 	ldw	r4,-20(fp)
 120746c:	e17ffd17 	ldw	r5,-12(fp)
 1207470:	12076440 	call	1207644 <alt_unlock_block_intel>
 1207474:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
 1207478:	e0bffa17 	ldw	r2,-24(fp)
 120747c:	1000091e 	bne	r2,zero,12074a4 <alt_program_intel+0x68>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 1207480:	00804834 	movhi	r2,288
 1207484:	109def04 	addi	r2,r2,30652
 1207488:	d8800015 	stw	r2,0(sp)
 120748c:	e13ffb17 	ldw	r4,-20(fp)
 1207490:	e17ffe17 	ldw	r5,-8(fp)
 1207494:	e1bfff17 	ldw	r6,-4(fp)
 1207498:	e1c00217 	ldw	r7,8(fp)
 120749c:	12041f80 	call	12041f8 <alt_flash_program_block>
 12074a0:	e0bffa15 	stw	r2,-24(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 12074a4:	e0bffa17 	ldw	r2,-24(fp)
}
 12074a8:	e037883a 	mov	sp,fp
 12074ac:	dfc00117 	ldw	ra,4(sp)
 12074b0:	df000017 	ldw	fp,0(sp)
 12074b4:	dec00204 	addi	sp,sp,8
 12074b8:	f800283a 	ret

012074bc <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 12074bc:	defff804 	addi	sp,sp,-32
 12074c0:	dfc00715 	stw	ra,28(sp)
 12074c4:	df000615 	stw	fp,24(sp)
 12074c8:	df000604 	addi	fp,sp,24
 12074cc:	e13ffe15 	stw	r4,-8(fp)
 12074d0:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 12074d4:	e03ffa15 	stw	zero,-24(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 12074d8:	e0bffe17 	ldw	r2,-8(fp)
 12074dc:	e0bffc15 	stw	r2,-16(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 12074e0:	e0bffc17 	ldw	r2,-16(fp)
 12074e4:	10803217 	ldw	r2,200(r2)
 12074e8:	e0bffb15 	stw	r2,-20(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 12074ec:	e13ffc17 	ldw	r4,-16(fp)
 12074f0:	e17fff17 	ldw	r5,-4(fp)
 12074f4:	12076440 	call	1207644 <alt_unlock_block_intel>
 12074f8:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
 12074fc:	e0bffa17 	ldw	r2,-24(fp)
 1207500:	10004a1e 	bne	r2,zero,120762c <alt_erase_block_intel+0x170>
  {

    /* Clear status priort to erase operation */   
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x50);
 1207504:	e0bffc17 	ldw	r2,-16(fp)
 1207508:	10803617 	ldw	r2,216(r2)
 120750c:	e0fffc17 	ldw	r3,-16(fp)
 1207510:	19000a17 	ldw	r4,40(r3)
 1207514:	e0ffff17 	ldw	r3,-4(fp)
 1207518:	20c7883a 	add	r3,r4,r3
 120751c:	1809883a 	mov	r4,r3
 1207520:	01401404 	movi	r5,80
 1207524:	103ee83a 	callr	r2
    
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 1207528:	e0bffc17 	ldw	r2,-16(fp)
 120752c:	10803617 	ldw	r2,216(r2)
 1207530:	e0fffc17 	ldw	r3,-16(fp)
 1207534:	19000a17 	ldw	r4,40(r3)
 1207538:	e0ffff17 	ldw	r3,-4(fp)
 120753c:	20c7883a 	add	r3,r4,r3
 1207540:	1809883a 	mov	r4,r3
 1207544:	01400804 	movi	r5,32
 1207548:	103ee83a 	callr	r2
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 120754c:	e0bffc17 	ldw	r2,-16(fp)
 1207550:	10803617 	ldw	r2,216(r2)
 1207554:	e0fffc17 	ldw	r3,-16(fp)
 1207558:	19000a17 	ldw	r4,40(r3)
 120755c:	e0ffff17 	ldw	r3,-4(fp)
 1207560:	20c7883a 	add	r3,r4,r3
 1207564:	1809883a 	mov	r4,r3
 1207568:	01403404 	movi	r5,208
 120756c:	103ee83a 	callr	r2

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 1207570:	e0bffc17 	ldw	r2,-16(fp)
 1207574:	10c00a17 	ldw	r3,40(r2)
 1207578:	e0bfff17 	ldw	r2,-4(fp)
 120757c:	1885883a 	add	r2,r3,r2
 1207580:	10800023 	ldbuio	r2,0(r2)
 1207584:	10803fcc 	andi	r2,r2,255
 1207588:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 120758c:	e0bffd03 	ldbu	r2,-12(fp)
 1207590:	10803fcc 	andi	r2,r2,255
 1207594:	1080201c 	xori	r2,r2,128
 1207598:	10bfe004 	addi	r2,r2,-128
 120759c:	1000010e 	bge	r2,zero,12075a4 <alt_erase_block_intel+0xe8>
      {
        break;
 12075a0:	00000706 	br	12075c0 <alt_erase_block_intel+0x104>
      }
      usleep(1000);
 12075a4:	0100fa04 	movi	r4,1000
 12075a8:	12039f00 	call	12039f0 <usleep>
      timeout -= 1000;
 12075ac:	e0bffb17 	ldw	r2,-20(fp)
 12075b0:	10bf0604 	addi	r2,r2,-1000
 12075b4:	e0bffb15 	stw	r2,-20(fp)
    }while(timeout > 0);
 12075b8:	e0bffb17 	ldw	r2,-20(fp)
 12075bc:	00bfec16 	blt	zero,r2,1207570 <__alt_mem_instruction_tcm+0xff207570>
    
    if (timeout <= 0)
 12075c0:	e0bffb17 	ldw	r2,-20(fp)
 12075c4:	00800316 	blt	zero,r2,12075d4 <alt_erase_block_intel+0x118>
    {
      ret_code = -ETIMEDOUT;
 12075c8:	00bfe304 	movi	r2,-116
 12075cc:	e0bffa15 	stw	r2,-24(fp)
 12075d0:	00000d06 	br	1207608 <alt_erase_block_intel+0x14c>
    }
    else if (status & 0x7f)
 12075d4:	e0bffd03 	ldbu	r2,-12(fp)
 12075d8:	10803fcc 	andi	r2,r2,255
 12075dc:	10801fcc 	andi	r2,r2,127
 12075e0:	10000926 	beq	r2,zero,1207608 <alt_erase_block_intel+0x14c>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 12075e4:	00bffec4 	movi	r2,-5
 12075e8:	e0bffa15 	stw	r2,-24(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 12075ec:	e0bffc17 	ldw	r2,-16(fp)
 12075f0:	10c00a17 	ldw	r3,40(r2)
 12075f4:	e0bfff17 	ldw	r2,-4(fp)
 12075f8:	1885883a 	add	r2,r3,r2
 12075fc:	10800023 	ldbuio	r2,0(r2)
 1207600:	10803fcc 	andi	r2,r2,255
 1207604:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 1207608:	e0bffc17 	ldw	r2,-16(fp)
 120760c:	10803617 	ldw	r2,216(r2)
 1207610:	e0fffc17 	ldw	r3,-16(fp)
 1207614:	19000a17 	ldw	r4,40(r3)
 1207618:	e0ffff17 	ldw	r3,-4(fp)
 120761c:	20c7883a 	add	r3,r4,r3
 1207620:	1809883a 	mov	r4,r3
 1207624:	01403fc4 	movi	r5,255
 1207628:	103ee83a 	callr	r2
  }
  
  return ret_code;
 120762c:	e0bffa17 	ldw	r2,-24(fp)
}
 1207630:	e037883a 	mov	sp,fp
 1207634:	dfc00117 	ldw	ra,4(sp)
 1207638:	df000017 	ldw	fp,0(sp)
 120763c:	dec00204 	addi	sp,sp,8
 1207640:	f800283a 	ret

01207644 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 1207644:	defff904 	addi	sp,sp,-28
 1207648:	dfc00615 	stw	ra,24(sp)
 120764c:	df000515 	stw	fp,20(sp)
 1207650:	df000504 	addi	fp,sp,20
 1207654:	e13ffe15 	stw	r4,-8(fp)
 1207658:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 120765c:	e03ffb15 	stw	zero,-20(fp)
  int timeout = flash->write_timeout * 100;
 1207660:	e0bffe17 	ldw	r2,-8(fp)
 1207664:	10803117 	ldw	r2,196(r2)
 1207668:	10801924 	muli	r2,r2,100
 120766c:	e0bffc15 	stw	r2,-16(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 1207670:	e0bffe17 	ldw	r2,-8(fp)
 1207674:	10803617 	ldw	r2,216(r2)
 1207678:	e0fffe17 	ldw	r3,-8(fp)
 120767c:	19000a17 	ldw	r4,40(r3)
 1207680:	e0ffff17 	ldw	r3,-4(fp)
 1207684:	20c7883a 	add	r3,r4,r3
 1207688:	1809883a 	mov	r4,r3
 120768c:	01402404 	movi	r5,144
 1207690:	103ee83a 	callr	r2
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 1207694:	e0bffe17 	ldw	r2,-8(fp)
 1207698:	10c00a17 	ldw	r3,40(r2)
 120769c:	e0bfff17 	ldw	r2,-4(fp)
 12076a0:	10800104 	addi	r2,r2,4
 12076a4:	1885883a 	add	r2,r3,r2
 12076a8:	10800023 	ldbuio	r2,0(r2)
 12076ac:	10803fcc 	andi	r2,r2,255
 12076b0:	e0bffd05 	stb	r2,-12(fp)
  if (locked & 0x1)
 12076b4:	e0bffd03 	ldbu	r2,-12(fp)
 12076b8:	1080004c 	andi	r2,r2,1
 12076bc:	10003026 	beq	r2,zero,1207780 <alt_unlock_block_intel+0x13c>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 12076c0:	e0bffe17 	ldw	r2,-8(fp)
 12076c4:	10803617 	ldw	r2,216(r2)
 12076c8:	e0fffe17 	ldw	r3,-8(fp)
 12076cc:	19000a17 	ldw	r4,40(r3)
 12076d0:	e0ffff17 	ldw	r3,-4(fp)
 12076d4:	20c7883a 	add	r3,r4,r3
 12076d8:	1809883a 	mov	r4,r3
 12076dc:	01401804 	movi	r5,96
 12076e0:	103ee83a 	callr	r2
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 12076e4:	e0bffe17 	ldw	r2,-8(fp)
 12076e8:	10803617 	ldw	r2,216(r2)
 12076ec:	e0fffe17 	ldw	r3,-8(fp)
 12076f0:	19000a17 	ldw	r4,40(r3)
 12076f4:	e0ffff17 	ldw	r3,-4(fp)
 12076f8:	20c7883a 	add	r3,r4,r3
 12076fc:	1809883a 	mov	r4,r3
 1207700:	01403404 	movi	r5,208
 1207704:	103ee83a 	callr	r2

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 1207708:	e0bffe17 	ldw	r2,-8(fp)
 120770c:	10c00a17 	ldw	r3,40(r2)
 1207710:	e0bfff17 	ldw	r2,-4(fp)
 1207714:	1885883a 	add	r2,r3,r2
 1207718:	10800023 	ldbuio	r2,0(r2)
 120771c:	10803fcc 	andi	r2,r2,255
 1207720:	e0bffd45 	stb	r2,-11(fp)
      if (status & 0x80)
 1207724:	e0bffd43 	ldbu	r2,-11(fp)
 1207728:	10803fcc 	andi	r2,r2,255
 120772c:	1080201c 	xori	r2,r2,128
 1207730:	10bfe004 	addi	r2,r2,-128
 1207734:	1000010e 	bge	r2,zero,120773c <alt_unlock_block_intel+0xf8>
      {
        break;
 1207738:	00000706 	br	1207758 <alt_unlock_block_intel+0x114>
      }
      timeout--;
 120773c:	e0bffc17 	ldw	r2,-16(fp)
 1207740:	10bfffc4 	addi	r2,r2,-1
 1207744:	e0bffc15 	stw	r2,-16(fp)
      usleep(1);
 1207748:	01000044 	movi	r4,1
 120774c:	12039f00 	call	12039f0 <usleep>
    }while(timeout > 0);
 1207750:	e0bffc17 	ldw	r2,-16(fp)
 1207754:	00bfec16 	blt	zero,r2,1207708 <__alt_mem_instruction_tcm+0xff207708>

    if (timeout == 0)
 1207758:	e0bffc17 	ldw	r2,-16(fp)
 120775c:	1000031e 	bne	r2,zero,120776c <alt_unlock_block_intel+0x128>
    {
      ret_code = -ETIMEDOUT;
 1207760:	00bfe304 	movi	r2,-116
 1207764:	e0bffb15 	stw	r2,-20(fp)
 1207768:	00000506 	br	1207780 <alt_unlock_block_intel+0x13c>
    }
    else if (status & 0x7f)
 120776c:	e0bffd43 	ldbu	r2,-11(fp)
 1207770:	10801fcc 	andi	r2,r2,127
 1207774:	10000226 	beq	r2,zero,1207780 <alt_unlock_block_intel+0x13c>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 1207778:	00bffec4 	movi	r2,-5
 120777c:	e0bffb15 	stw	r2,-20(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 1207780:	e0bffe17 	ldw	r2,-8(fp)
 1207784:	10803617 	ldw	r2,216(r2)
 1207788:	e0fffe17 	ldw	r3,-8(fp)
 120778c:	19000a17 	ldw	r4,40(r3)
 1207790:	e0ffff17 	ldw	r3,-4(fp)
 1207794:	20c7883a 	add	r3,r4,r3
 1207798:	1809883a 	mov	r4,r3
 120779c:	01403fc4 	movi	r5,255
 12077a0:	103ee83a 	callr	r2

  return ret_code;
 12077a4:	e0bffb17 	ldw	r2,-20(fp)
}
 12077a8:	e037883a 	mov	sp,fp
 12077ac:	dfc00117 	ldw	ra,4(sp)
 12077b0:	df000017 	ldw	fp,0(sp)
 12077b4:	dec00204 	addi	sp,sp,8
 12077b8:	f800283a 	ret

012077bc <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 12077bc:	defff904 	addi	sp,sp,-28
 12077c0:	dfc00615 	stw	ra,24(sp)
 12077c4:	df000515 	stw	fp,20(sp)
 12077c8:	df000504 	addi	fp,sp,20
 12077cc:	e13ffd15 	stw	r4,-12(fp)
 12077d0:	e17ffe15 	stw	r5,-8(fp)
 12077d4:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 12077d8:	e03ffb15 	stw	zero,-20(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 12077dc:	e0bffd17 	ldw	r2,-12(fp)
 12077e0:	10803617 	ldw	r2,216(r2)
 12077e4:	e0fffd17 	ldw	r3,-12(fp)
 12077e8:	19000a17 	ldw	r4,40(r3)
 12077ec:	e0fffe17 	ldw	r3,-8(fp)
 12077f0:	20c7883a 	add	r3,r4,r3
 12077f4:	1809883a 	mov	r4,r3
 12077f8:	01401004 	movi	r5,64
 12077fc:	103ee83a 	callr	r2
  alt_write_value_to_flash(flash, offset, src_addr);
 1207800:	e13ffd17 	ldw	r4,-12(fp)
 1207804:	e17ffe17 	ldw	r5,-8(fp)
 1207808:	e1bfff17 	ldw	r6,-4(fp)
 120780c:	12040a00 	call	12040a0 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 1207810:	e0bffd17 	ldw	r2,-12(fp)
 1207814:	10c00a17 	ldw	r3,40(r2)
 1207818:	e0bffe17 	ldw	r2,-8(fp)
 120781c:	1885883a 	add	r2,r3,r2
 1207820:	10800023 	ldbuio	r2,0(r2)
 1207824:	10803fcc 	andi	r2,r2,255
 1207828:	e0bffc05 	stb	r2,-16(fp)
  }while(!(status & 0x80));
 120782c:	e0bffc03 	ldbu	r2,-16(fp)
 1207830:	10803fcc 	andi	r2,r2,255
 1207834:	1080201c 	xori	r2,r2,128
 1207838:	10bfe004 	addi	r2,r2,-128
 120783c:	103ff40e 	bge	r2,zero,1207810 <__alt_mem_instruction_tcm+0xff207810>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 1207840:	e0bffc03 	ldbu	r2,-16(fp)
 1207844:	10801fcc 	andi	r2,r2,127
 1207848:	10000226 	beq	r2,zero,1207854 <alt_write_word_intel+0x98>
  {
    ret_code = -EIO;
 120784c:	00bffec4 	movi	r2,-5
 1207850:	e0bffb15 	stw	r2,-20(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 1207854:	e0bffd17 	ldw	r2,-12(fp)
 1207858:	10803617 	ldw	r2,216(r2)
 120785c:	e0fffd17 	ldw	r3,-12(fp)
 1207860:	19000a17 	ldw	r4,40(r3)
 1207864:	e0fffe17 	ldw	r3,-8(fp)
 1207868:	20c7883a 	add	r3,r4,r3
 120786c:	1809883a 	mov	r4,r3
 1207870:	01403fc4 	movi	r5,255
 1207874:	103ee83a 	callr	r2
  
  return ret_code;
 1207878:	e0bffb17 	ldw	r2,-20(fp)
}
 120787c:	e037883a 	mov	sp,fp
 1207880:	dfc00117 	ldw	ra,4(sp)
 1207884:	df000017 	ldw	fp,0(sp)
 1207888:	dec00204 	addi	sp,sp,8
 120788c:	f800283a 	ret

01207890 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 1207890:	defffa04 	addi	sp,sp,-24
 1207894:	dfc00515 	stw	ra,20(sp)
 1207898:	df000415 	stw	fp,16(sp)
 120789c:	df000404 	addi	fp,sp,16
 12078a0:	e13ffe15 	stw	r4,-8(fp)
 12078a4:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 12078a8:	e0bfff17 	ldw	r2,-4(fp)
 12078ac:	10800017 	ldw	r2,0(r2)
 12078b0:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 12078b4:	e13ffe17 	ldw	r4,-8(fp)
 12078b8:	12005680 	call	1200568 <strlen>
 12078bc:	10800044 	addi	r2,r2,1
 12078c0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 12078c4:	00000d06 	br	12078fc <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 12078c8:	e0bffc17 	ldw	r2,-16(fp)
 12078cc:	10c00217 	ldw	r3,8(r2)
 12078d0:	e0bffd17 	ldw	r2,-12(fp)
 12078d4:	1809883a 	mov	r4,r3
 12078d8:	e17ffe17 	ldw	r5,-8(fp)
 12078dc:	100d883a 	mov	r6,r2
 12078e0:	1207b340 	call	1207b34 <memcmp>
 12078e4:	1000021e 	bne	r2,zero,12078f0 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 12078e8:	e0bffc17 	ldw	r2,-16(fp)
 12078ec:	00000706 	br	120790c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 12078f0:	e0bffc17 	ldw	r2,-16(fp)
 12078f4:	10800017 	ldw	r2,0(r2)
 12078f8:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 12078fc:	e0fffc17 	ldw	r3,-16(fp)
 1207900:	e0bfff17 	ldw	r2,-4(fp)
 1207904:	18bff01e 	bne	r3,r2,12078c8 <__alt_mem_instruction_tcm+0xff2078c8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 1207908:	0005883a 	mov	r2,zero
}
 120790c:	e037883a 	mov	sp,fp
 1207910:	dfc00117 	ldw	ra,4(sp)
 1207914:	df000017 	ldw	fp,0(sp)
 1207918:	dec00204 	addi	sp,sp,8
 120791c:	f800283a 	ret

01207920 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 1207920:	defffb04 	addi	sp,sp,-20
 1207924:	dfc00415 	stw	ra,16(sp)
 1207928:	df000315 	stw	fp,12(sp)
 120792c:	df000304 	addi	fp,sp,12
 1207930:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 1207934:	00804874 	movhi	r2,289
 1207938:	10a6d204 	addi	r2,r2,-25784
 120793c:	10800017 	ldw	r2,0(r2)
 1207940:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 1207944:	00003106 	br	1207a0c <alt_find_file+0xec>
  {
    len = strlen(next->name);
 1207948:	e0bffd17 	ldw	r2,-12(fp)
 120794c:	10800217 	ldw	r2,8(r2)
 1207950:	1009883a 	mov	r4,r2
 1207954:	12005680 	call	1200568 <strlen>
 1207958:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 120795c:	e0bffd17 	ldw	r2,-12(fp)
 1207960:	10c00217 	ldw	r3,8(r2)
 1207964:	e0bffe17 	ldw	r2,-8(fp)
 1207968:	10bfffc4 	addi	r2,r2,-1
 120796c:	1885883a 	add	r2,r3,r2
 1207970:	10800003 	ldbu	r2,0(r2)
 1207974:	10803fcc 	andi	r2,r2,255
 1207978:	1080201c 	xori	r2,r2,128
 120797c:	10bfe004 	addi	r2,r2,-128
 1207980:	10800bd8 	cmpnei	r2,r2,47
 1207984:	1000031e 	bne	r2,zero,1207994 <alt_find_file+0x74>
    {
      len -= 1;
 1207988:	e0bffe17 	ldw	r2,-8(fp)
 120798c:	10bfffc4 	addi	r2,r2,-1
 1207990:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 1207994:	e0bffe17 	ldw	r2,-8(fp)
 1207998:	e0ffff17 	ldw	r3,-4(fp)
 120799c:	1885883a 	add	r2,r3,r2
 12079a0:	10800003 	ldbu	r2,0(r2)
 12079a4:	10803fcc 	andi	r2,r2,255
 12079a8:	1080201c 	xori	r2,r2,128
 12079ac:	10bfe004 	addi	r2,r2,-128
 12079b0:	10800be0 	cmpeqi	r2,r2,47
 12079b4:	1000081e 	bne	r2,zero,12079d8 <alt_find_file+0xb8>
 12079b8:	e0bffe17 	ldw	r2,-8(fp)
 12079bc:	e0ffff17 	ldw	r3,-4(fp)
 12079c0:	1885883a 	add	r2,r3,r2
 12079c4:	10800003 	ldbu	r2,0(r2)
 12079c8:	10803fcc 	andi	r2,r2,255
 12079cc:	1080201c 	xori	r2,r2,128
 12079d0:	10bfe004 	addi	r2,r2,-128
 12079d4:	10000a1e 	bne	r2,zero,1207a00 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
 12079d8:	e0bffd17 	ldw	r2,-12(fp)
 12079dc:	10c00217 	ldw	r3,8(r2)
 12079e0:	e0bffe17 	ldw	r2,-8(fp)
 12079e4:	1809883a 	mov	r4,r3
 12079e8:	e17fff17 	ldw	r5,-4(fp)
 12079ec:	100d883a 	mov	r6,r2
 12079f0:	1207b340 	call	1207b34 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 12079f4:	1000021e 	bne	r2,zero,1207a00 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 12079f8:	e0bffd17 	ldw	r2,-12(fp)
 12079fc:	00000806 	br	1207a20 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
 1207a00:	e0bffd17 	ldw	r2,-12(fp)
 1207a04:	10800017 	ldw	r2,0(r2)
 1207a08:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 1207a0c:	e0fffd17 	ldw	r3,-12(fp)
 1207a10:	00804874 	movhi	r2,289
 1207a14:	10a6d204 	addi	r2,r2,-25784
 1207a18:	18bfcb1e 	bne	r3,r2,1207948 <__alt_mem_instruction_tcm+0xff207948>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 1207a1c:	0005883a 	mov	r2,zero
}
 1207a20:	e037883a 	mov	sp,fp
 1207a24:	dfc00117 	ldw	ra,4(sp)
 1207a28:	df000017 	ldw	fp,0(sp)
 1207a2c:	dec00204 	addi	sp,sp,8
 1207a30:	f800283a 	ret

01207a34 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 1207a34:	defffc04 	addi	sp,sp,-16
 1207a38:	df000315 	stw	fp,12(sp)
 1207a3c:	df000304 	addi	fp,sp,12
 1207a40:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 1207a44:	00bffa04 	movi	r2,-24
 1207a48:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1207a4c:	e03ffd15 	stw	zero,-12(fp)
 1207a50:	00001d06 	br	1207ac8 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
 1207a54:	00804874 	movhi	r2,289
 1207a58:	10a21f04 	addi	r2,r2,-30596
 1207a5c:	e0fffd17 	ldw	r3,-12(fp)
 1207a60:	18c00324 	muli	r3,r3,12
 1207a64:	10c5883a 	add	r2,r2,r3
 1207a68:	10800017 	ldw	r2,0(r2)
 1207a6c:	1000131e 	bne	r2,zero,1207abc <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
 1207a70:	00804874 	movhi	r2,289
 1207a74:	10a21f04 	addi	r2,r2,-30596
 1207a78:	e0fffd17 	ldw	r3,-12(fp)
 1207a7c:	18c00324 	muli	r3,r3,12
 1207a80:	10c5883a 	add	r2,r2,r3
 1207a84:	e0ffff17 	ldw	r3,-4(fp)
 1207a88:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 1207a8c:	00804874 	movhi	r2,289
 1207a90:	10a6d604 	addi	r2,r2,-25768
 1207a94:	10c00017 	ldw	r3,0(r2)
 1207a98:	e0bffd17 	ldw	r2,-12(fp)
 1207a9c:	1880040e 	bge	r3,r2,1207ab0 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
 1207aa0:	00804874 	movhi	r2,289
 1207aa4:	10a6d604 	addi	r2,r2,-25768
 1207aa8:	e0fffd17 	ldw	r3,-12(fp)
 1207aac:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
 1207ab0:	e0bffd17 	ldw	r2,-12(fp)
 1207ab4:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 1207ab8:	00000606 	br	1207ad4 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1207abc:	e0bffd17 	ldw	r2,-12(fp)
 1207ac0:	10800044 	addi	r2,r2,1
 1207ac4:	e0bffd15 	stw	r2,-12(fp)
 1207ac8:	e0bffd17 	ldw	r2,-12(fp)
 1207acc:	10800810 	cmplti	r2,r2,32
 1207ad0:	103fe01e 	bne	r2,zero,1207a54 <__alt_mem_instruction_tcm+0xff207a54>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 1207ad4:	e0bffe17 	ldw	r2,-8(fp)
}
 1207ad8:	e037883a 	mov	sp,fp
 1207adc:	df000017 	ldw	fp,0(sp)
 1207ae0:	dec00104 	addi	sp,sp,4
 1207ae4:	f800283a 	ret

01207ae8 <atexit>:
 1207ae8:	200b883a 	mov	r5,r4
 1207aec:	000d883a 	mov	r6,zero
 1207af0:	0009883a 	mov	r4,zero
 1207af4:	000f883a 	mov	r7,zero
 1207af8:	1207bb01 	jmpi	1207bb0 <__register_exitproc>

01207afc <exit>:
 1207afc:	defffe04 	addi	sp,sp,-8
 1207b00:	000b883a 	mov	r5,zero
 1207b04:	dc000015 	stw	r16,0(sp)
 1207b08:	dfc00115 	stw	ra,4(sp)
 1207b0c:	2021883a 	mov	r16,r4
 1207b10:	1207cc40 	call	1207cc4 <__call_exitprocs>
 1207b14:	00804874 	movhi	r2,289
 1207b18:	10a6ce04 	addi	r2,r2,-25800
 1207b1c:	11000017 	ldw	r4,0(r2)
 1207b20:	20800f17 	ldw	r2,60(r4)
 1207b24:	10000126 	beq	r2,zero,1207b2c <exit+0x30>
 1207b28:	103ee83a 	callr	r2
 1207b2c:	8009883a 	mov	r4,r16
 1207b30:	1207f840 	call	1207f84 <_exit>

01207b34 <memcmp>:
 1207b34:	01c000c4 	movi	r7,3
 1207b38:	3980192e 	bgeu	r7,r6,1207ba0 <memcmp+0x6c>
 1207b3c:	2144b03a 	or	r2,r4,r5
 1207b40:	11c4703a 	and	r2,r2,r7
 1207b44:	10000f26 	beq	r2,zero,1207b84 <memcmp+0x50>
 1207b48:	20800003 	ldbu	r2,0(r4)
 1207b4c:	28c00003 	ldbu	r3,0(r5)
 1207b50:	10c0151e 	bne	r2,r3,1207ba8 <memcmp+0x74>
 1207b54:	31bfff84 	addi	r6,r6,-2
 1207b58:	01ffffc4 	movi	r7,-1
 1207b5c:	00000406 	br	1207b70 <memcmp+0x3c>
 1207b60:	20800003 	ldbu	r2,0(r4)
 1207b64:	28c00003 	ldbu	r3,0(r5)
 1207b68:	31bfffc4 	addi	r6,r6,-1
 1207b6c:	10c00e1e 	bne	r2,r3,1207ba8 <memcmp+0x74>
 1207b70:	21000044 	addi	r4,r4,1
 1207b74:	29400044 	addi	r5,r5,1
 1207b78:	31fff91e 	bne	r6,r7,1207b60 <__alt_mem_instruction_tcm+0xff207b60>
 1207b7c:	0005883a 	mov	r2,zero
 1207b80:	f800283a 	ret
 1207b84:	20c00017 	ldw	r3,0(r4)
 1207b88:	28800017 	ldw	r2,0(r5)
 1207b8c:	1880041e 	bne	r3,r2,1207ba0 <memcmp+0x6c>
 1207b90:	31bfff04 	addi	r6,r6,-4
 1207b94:	21000104 	addi	r4,r4,4
 1207b98:	29400104 	addi	r5,r5,4
 1207b9c:	39bff936 	bltu	r7,r6,1207b84 <__alt_mem_instruction_tcm+0xff207b84>
 1207ba0:	303fe91e 	bne	r6,zero,1207b48 <__alt_mem_instruction_tcm+0xff207b48>
 1207ba4:	003ff506 	br	1207b7c <__alt_mem_instruction_tcm+0xff207b7c>
 1207ba8:	10c5c83a 	sub	r2,r2,r3
 1207bac:	f800283a 	ret

01207bb0 <__register_exitproc>:
 1207bb0:	00804874 	movhi	r2,289
 1207bb4:	defffa04 	addi	sp,sp,-24
 1207bb8:	10a6ce04 	addi	r2,r2,-25800
 1207bbc:	dc000315 	stw	r16,12(sp)
 1207bc0:	14000017 	ldw	r16,0(r2)
 1207bc4:	dc400415 	stw	r17,16(sp)
 1207bc8:	dfc00515 	stw	ra,20(sp)
 1207bcc:	80805217 	ldw	r2,328(r16)
 1207bd0:	2023883a 	mov	r17,r4
 1207bd4:	10003626 	beq	r2,zero,1207cb0 <__register_exitproc+0x100>
 1207bd8:	10c00117 	ldw	r3,4(r2)
 1207bdc:	010007c4 	movi	r4,31
 1207be0:	20c00e16 	blt	r4,r3,1207c1c <__register_exitproc+0x6c>
 1207be4:	1a400044 	addi	r9,r3,1
 1207be8:	8800211e 	bne	r17,zero,1207c70 <__register_exitproc+0xc0>
 1207bec:	18c00084 	addi	r3,r3,2
 1207bf0:	18c7883a 	add	r3,r3,r3
 1207bf4:	18c7883a 	add	r3,r3,r3
 1207bf8:	12400115 	stw	r9,4(r2)
 1207bfc:	10c7883a 	add	r3,r2,r3
 1207c00:	19400015 	stw	r5,0(r3)
 1207c04:	0005883a 	mov	r2,zero
 1207c08:	dfc00517 	ldw	ra,20(sp)
 1207c0c:	dc400417 	ldw	r17,16(sp)
 1207c10:	dc000317 	ldw	r16,12(sp)
 1207c14:	dec00604 	addi	sp,sp,24
 1207c18:	f800283a 	ret
 1207c1c:	00800034 	movhi	r2,0
 1207c20:	10800004 	addi	r2,r2,0
 1207c24:	10002526 	beq	r2,zero,1207cbc <__register_exitproc+0x10c>
 1207c28:	01006404 	movi	r4,400
 1207c2c:	d9400015 	stw	r5,0(sp)
 1207c30:	d9800115 	stw	r6,4(sp)
 1207c34:	d9c00215 	stw	r7,8(sp)
 1207c38:	00000000 	call	0 <__reset-0x800000>
 1207c3c:	d9400017 	ldw	r5,0(sp)
 1207c40:	d9800117 	ldw	r6,4(sp)
 1207c44:	d9c00217 	ldw	r7,8(sp)
 1207c48:	10001c26 	beq	r2,zero,1207cbc <__register_exitproc+0x10c>
 1207c4c:	80c05217 	ldw	r3,328(r16)
 1207c50:	10000115 	stw	zero,4(r2)
 1207c54:	02400044 	movi	r9,1
 1207c58:	10c00015 	stw	r3,0(r2)
 1207c5c:	80805215 	stw	r2,328(r16)
 1207c60:	10006215 	stw	zero,392(r2)
 1207c64:	10006315 	stw	zero,396(r2)
 1207c68:	0007883a 	mov	r3,zero
 1207c6c:	883fdf26 	beq	r17,zero,1207bec <__alt_mem_instruction_tcm+0xff207bec>
 1207c70:	18d1883a 	add	r8,r3,r3
 1207c74:	4211883a 	add	r8,r8,r8
 1207c78:	1211883a 	add	r8,r2,r8
 1207c7c:	41802215 	stw	r6,136(r8)
 1207c80:	01000044 	movi	r4,1
 1207c84:	11806217 	ldw	r6,392(r2)
 1207c88:	20c8983a 	sll	r4,r4,r3
 1207c8c:	310cb03a 	or	r6,r6,r4
 1207c90:	11806215 	stw	r6,392(r2)
 1207c94:	41c04215 	stw	r7,264(r8)
 1207c98:	01800084 	movi	r6,2
 1207c9c:	89bfd31e 	bne	r17,r6,1207bec <__alt_mem_instruction_tcm+0xff207bec>
 1207ca0:	11806317 	ldw	r6,396(r2)
 1207ca4:	3108b03a 	or	r4,r6,r4
 1207ca8:	11006315 	stw	r4,396(r2)
 1207cac:	003fcf06 	br	1207bec <__alt_mem_instruction_tcm+0xff207bec>
 1207cb0:	80805304 	addi	r2,r16,332
 1207cb4:	80805215 	stw	r2,328(r16)
 1207cb8:	003fc706 	br	1207bd8 <__alt_mem_instruction_tcm+0xff207bd8>
 1207cbc:	00bfffc4 	movi	r2,-1
 1207cc0:	003fd106 	br	1207c08 <__alt_mem_instruction_tcm+0xff207c08>

01207cc4 <__call_exitprocs>:
 1207cc4:	00804874 	movhi	r2,289
 1207cc8:	10a6ce04 	addi	r2,r2,-25800
 1207ccc:	10800017 	ldw	r2,0(r2)
 1207cd0:	defff404 	addi	sp,sp,-48
 1207cd4:	dd800815 	stw	r22,32(sp)
 1207cd8:	d8800015 	stw	r2,0(sp)
 1207cdc:	10805204 	addi	r2,r2,328
 1207ce0:	dd000615 	stw	r20,24(sp)
 1207ce4:	dc800415 	stw	r18,16(sp)
 1207ce8:	dfc00b15 	stw	ra,44(sp)
 1207cec:	df000a15 	stw	fp,40(sp)
 1207cf0:	ddc00915 	stw	r23,36(sp)
 1207cf4:	dd400715 	stw	r21,28(sp)
 1207cf8:	dcc00515 	stw	r19,20(sp)
 1207cfc:	dc400315 	stw	r17,12(sp)
 1207d00:	dc000215 	stw	r16,8(sp)
 1207d04:	2025883a 	mov	r18,r4
 1207d08:	2829883a 	mov	r20,r5
 1207d0c:	d8800115 	stw	r2,4(sp)
 1207d10:	05bfffc4 	movi	r22,-1
 1207d14:	d8800017 	ldw	r2,0(sp)
 1207d18:	14c05217 	ldw	r19,328(r2)
 1207d1c:	98001d26 	beq	r19,zero,1207d94 <__call_exitprocs+0xd0>
 1207d20:	dd400117 	ldw	r21,4(sp)
 1207d24:	98800117 	ldw	r2,4(r19)
 1207d28:	173fffc4 	addi	fp,r2,-1
 1207d2c:	e0000d16 	blt	fp,zero,1207d64 <__call_exitprocs+0xa0>
 1207d30:	14000044 	addi	r16,r2,1
 1207d34:	8421883a 	add	r16,r16,r16
 1207d38:	8421883a 	add	r16,r16,r16
 1207d3c:	84402004 	addi	r17,r16,128
 1207d40:	9c63883a 	add	r17,r19,r17
 1207d44:	9c21883a 	add	r16,r19,r16
 1207d48:	a0001e26 	beq	r20,zero,1207dc4 <__call_exitprocs+0x100>
 1207d4c:	80804017 	ldw	r2,256(r16)
 1207d50:	15001c26 	beq	r2,r20,1207dc4 <__call_exitprocs+0x100>
 1207d54:	e73fffc4 	addi	fp,fp,-1
 1207d58:	843fff04 	addi	r16,r16,-4
 1207d5c:	8c7fff04 	addi	r17,r17,-4
 1207d60:	e5bff91e 	bne	fp,r22,1207d48 <__alt_mem_instruction_tcm+0xff207d48>
 1207d64:	00800034 	movhi	r2,0
 1207d68:	10800004 	addi	r2,r2,0
 1207d6c:	10000926 	beq	r2,zero,1207d94 <__call_exitprocs+0xd0>
 1207d70:	98800117 	ldw	r2,4(r19)
 1207d74:	1000311e 	bne	r2,zero,1207e3c <__call_exitprocs+0x178>
 1207d78:	98800017 	ldw	r2,0(r19)
 1207d7c:	10003426 	beq	r2,zero,1207e50 <__call_exitprocs+0x18c>
 1207d80:	9809883a 	mov	r4,r19
 1207d84:	a8800015 	stw	r2,0(r21)
 1207d88:	00000000 	call	0 <__reset-0x800000>
 1207d8c:	acc00017 	ldw	r19,0(r21)
 1207d90:	983fe41e 	bne	r19,zero,1207d24 <__alt_mem_instruction_tcm+0xff207d24>
 1207d94:	dfc00b17 	ldw	ra,44(sp)
 1207d98:	df000a17 	ldw	fp,40(sp)
 1207d9c:	ddc00917 	ldw	r23,36(sp)
 1207da0:	dd800817 	ldw	r22,32(sp)
 1207da4:	dd400717 	ldw	r21,28(sp)
 1207da8:	dd000617 	ldw	r20,24(sp)
 1207dac:	dcc00517 	ldw	r19,20(sp)
 1207db0:	dc800417 	ldw	r18,16(sp)
 1207db4:	dc400317 	ldw	r17,12(sp)
 1207db8:	dc000217 	ldw	r16,8(sp)
 1207dbc:	dec00c04 	addi	sp,sp,48
 1207dc0:	f800283a 	ret
 1207dc4:	98800117 	ldw	r2,4(r19)
 1207dc8:	80c00017 	ldw	r3,0(r16)
 1207dcc:	10bfffc4 	addi	r2,r2,-1
 1207dd0:	17001526 	beq	r2,fp,1207e28 <__call_exitprocs+0x164>
 1207dd4:	80000015 	stw	zero,0(r16)
 1207dd8:	183fde26 	beq	r3,zero,1207d54 <__alt_mem_instruction_tcm+0xff207d54>
 1207ddc:	00800044 	movi	r2,1
 1207de0:	1708983a 	sll	r4,r2,fp
 1207de4:	98806217 	ldw	r2,392(r19)
 1207de8:	9dc00117 	ldw	r23,4(r19)
 1207dec:	2084703a 	and	r2,r4,r2
 1207df0:	1000061e 	bne	r2,zero,1207e0c <__call_exitprocs+0x148>
 1207df4:	183ee83a 	callr	r3
 1207df8:	98800117 	ldw	r2,4(r19)
 1207dfc:	15ffc51e 	bne	r2,r23,1207d14 <__alt_mem_instruction_tcm+0xff207d14>
 1207e00:	a8800017 	ldw	r2,0(r21)
 1207e04:	14ffd326 	beq	r2,r19,1207d54 <__alt_mem_instruction_tcm+0xff207d54>
 1207e08:	003fc206 	br	1207d14 <__alt_mem_instruction_tcm+0xff207d14>
 1207e0c:	98806317 	ldw	r2,396(r19)
 1207e10:	2084703a 	and	r2,r4,r2
 1207e14:	1000061e 	bne	r2,zero,1207e30 <__call_exitprocs+0x16c>
 1207e18:	89400017 	ldw	r5,0(r17)
 1207e1c:	9009883a 	mov	r4,r18
 1207e20:	183ee83a 	callr	r3
 1207e24:	003ff406 	br	1207df8 <__alt_mem_instruction_tcm+0xff207df8>
 1207e28:	9f000115 	stw	fp,4(r19)
 1207e2c:	003fea06 	br	1207dd8 <__alt_mem_instruction_tcm+0xff207dd8>
 1207e30:	89000017 	ldw	r4,0(r17)
 1207e34:	183ee83a 	callr	r3
 1207e38:	003fef06 	br	1207df8 <__alt_mem_instruction_tcm+0xff207df8>
 1207e3c:	98800017 	ldw	r2,0(r19)
 1207e40:	982b883a 	mov	r21,r19
 1207e44:	1027883a 	mov	r19,r2
 1207e48:	983fb61e 	bne	r19,zero,1207d24 <__alt_mem_instruction_tcm+0xff207d24>
 1207e4c:	003fd106 	br	1207d94 <__alt_mem_instruction_tcm+0xff207d94>
 1207e50:	0005883a 	mov	r2,zero
 1207e54:	003ffa06 	br	1207e40 <__alt_mem_instruction_tcm+0xff207e40>

01207e58 <udivmodsi4>:
 1207e58:	2900182e 	bgeu	r5,r4,1207ebc <udivmodsi4+0x64>
 1207e5c:	28001716 	blt	r5,zero,1207ebc <udivmodsi4+0x64>
 1207e60:	00800804 	movi	r2,32
 1207e64:	00c00044 	movi	r3,1
 1207e68:	00000206 	br	1207e74 <udivmodsi4+0x1c>
 1207e6c:	10001126 	beq	r2,zero,1207eb4 <udivmodsi4+0x5c>
 1207e70:	28000516 	blt	r5,zero,1207e88 <udivmodsi4+0x30>
 1207e74:	294b883a 	add	r5,r5,r5
 1207e78:	10bfffc4 	addi	r2,r2,-1
 1207e7c:	18c7883a 	add	r3,r3,r3
 1207e80:	293ffa36 	bltu	r5,r4,1207e6c <__alt_mem_instruction_tcm+0xff207e6c>
 1207e84:	18000b26 	beq	r3,zero,1207eb4 <udivmodsi4+0x5c>
 1207e88:	0005883a 	mov	r2,zero
 1207e8c:	21400236 	bltu	r4,r5,1207e98 <udivmodsi4+0x40>
 1207e90:	2149c83a 	sub	r4,r4,r5
 1207e94:	10c4b03a 	or	r2,r2,r3
 1207e98:	1806d07a 	srli	r3,r3,1
 1207e9c:	280ad07a 	srli	r5,r5,1
 1207ea0:	183ffa1e 	bne	r3,zero,1207e8c <__alt_mem_instruction_tcm+0xff207e8c>
 1207ea4:	3000011e 	bne	r6,zero,1207eac <udivmodsi4+0x54>
 1207ea8:	f800283a 	ret
 1207eac:	2005883a 	mov	r2,r4
 1207eb0:	f800283a 	ret
 1207eb4:	0005883a 	mov	r2,zero
 1207eb8:	003ffa06 	br	1207ea4 <__alt_mem_instruction_tcm+0xff207ea4>
 1207ebc:	00c00044 	movi	r3,1
 1207ec0:	003ff106 	br	1207e88 <__alt_mem_instruction_tcm+0xff207e88>

01207ec4 <__divsi3>:
 1207ec4:	defffe04 	addi	sp,sp,-8
 1207ec8:	dfc00115 	stw	ra,4(sp)
 1207ecc:	dc000015 	stw	r16,0(sp)
 1207ed0:	20000b16 	blt	r4,zero,1207f00 <__divsi3+0x3c>
 1207ed4:	0021883a 	mov	r16,zero
 1207ed8:	28000c16 	blt	r5,zero,1207f0c <__divsi3+0x48>
 1207edc:	000d883a 	mov	r6,zero
 1207ee0:	1207e580 	call	1207e58 <udivmodsi4>
 1207ee4:	0407c83a 	sub	r3,zero,r16
 1207ee8:	1884f03a 	xor	r2,r3,r2
 1207eec:	1405883a 	add	r2,r2,r16
 1207ef0:	dfc00117 	ldw	ra,4(sp)
 1207ef4:	dc000017 	ldw	r16,0(sp)
 1207ef8:	dec00204 	addi	sp,sp,8
 1207efc:	f800283a 	ret
 1207f00:	0109c83a 	sub	r4,zero,r4
 1207f04:	04000044 	movi	r16,1
 1207f08:	283ff40e 	bge	r5,zero,1207edc <__alt_mem_instruction_tcm+0xff207edc>
 1207f0c:	014bc83a 	sub	r5,zero,r5
 1207f10:	8400005c 	xori	r16,r16,1
 1207f14:	003ff106 	br	1207edc <__alt_mem_instruction_tcm+0xff207edc>

01207f18 <__modsi3>:
 1207f18:	defffd04 	addi	sp,sp,-12
 1207f1c:	dfc00215 	stw	ra,8(sp)
 1207f20:	dc400115 	stw	r17,4(sp)
 1207f24:	dc000015 	stw	r16,0(sp)
 1207f28:	20000c16 	blt	r4,zero,1207f5c <__modsi3+0x44>
 1207f2c:	0023883a 	mov	r17,zero
 1207f30:	0021883a 	mov	r16,zero
 1207f34:	28000d16 	blt	r5,zero,1207f6c <__modsi3+0x54>
 1207f38:	01800044 	movi	r6,1
 1207f3c:	1207e580 	call	1207e58 <udivmodsi4>
 1207f40:	1404f03a 	xor	r2,r2,r16
 1207f44:	8885883a 	add	r2,r17,r2
 1207f48:	dfc00217 	ldw	ra,8(sp)
 1207f4c:	dc400117 	ldw	r17,4(sp)
 1207f50:	dc000017 	ldw	r16,0(sp)
 1207f54:	dec00304 	addi	sp,sp,12
 1207f58:	f800283a 	ret
 1207f5c:	0109c83a 	sub	r4,zero,r4
 1207f60:	04400044 	movi	r17,1
 1207f64:	043fffc4 	movi	r16,-1
 1207f68:	283ff30e 	bge	r5,zero,1207f38 <__alt_mem_instruction_tcm+0xff207f38>
 1207f6c:	014bc83a 	sub	r5,zero,r5
 1207f70:	003ff106 	br	1207f38 <__alt_mem_instruction_tcm+0xff207f38>

01207f74 <__udivsi3>:
 1207f74:	000d883a 	mov	r6,zero
 1207f78:	1207e581 	jmpi	1207e58 <udivmodsi4>

01207f7c <__umodsi3>:
 1207f7c:	01800044 	movi	r6,1
 1207f80:	1207e581 	jmpi	1207e58 <udivmodsi4>

01207f84 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 1207f84:	defffd04 	addi	sp,sp,-12
 1207f88:	df000215 	stw	fp,8(sp)
 1207f8c:	df000204 	addi	fp,sp,8
 1207f90:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 1207f94:	0001883a 	nop
 1207f98:	e0bfff17 	ldw	r2,-4(fp)
 1207f9c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 1207fa0:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 1207fa4:	10000226 	beq	r2,zero,1207fb0 <_exit+0x2c>
    ALT_SIM_FAIL();
 1207fa8:	002af070 	cmpltui	zero,zero,43969
 1207fac:	00000106 	br	1207fb4 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 1207fb0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 1207fb4:	003fff06 	br	1207fb4 <__alt_mem_instruction_tcm+0xff207fb4>
